diff -Naur linux-4.5/arch/arm/boot/dts/Makefile wm8505_linux4.5/arch/arm/boot/dts/Makefile
--- linux-4.5/arch/arm/boot/dts/Makefile	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/arch/arm/boot/dts/Makefile	2019-03-29 13:27:41.000000000 -0700
@@ -754,7 +754,6 @@
 dtb-$(CONFIG_ARCH_VT8500) += \
 	vt8500-bv07.dtb \
 	wm8505-ref.dtb \
-	wm8650-mid.dtb \
 	wm8750-apc8750.dtb \
 	wm8850-w70v2.dtb
 dtb-$(CONFIG_ARCH_ZYNQ) += \
diff -Naur linux-4.5/arch/arm/boot/dts/oMakefile wm8505_linux4.5/arch/arm/boot/dts/oMakefile
--- linux-4.5/arch/arm/boot/dts/oMakefile	1969-12-31 17:00:00.000000000 -0700
+++ wm8505_linux4.5/arch/arm/boot/dts/oMakefile	2019-03-29 13:27:30.000000000 -0700
@@ -0,0 +1,821 @@
+ifeq ($(CONFIG_OF),y)
+
+dtb-$(CONFIG_ARCH_ALPINE) += \
+	alpine-db.dtb
+dtb-$(CONFIG_MACH_ASM9260) += \
+	alphascale-asm9260-devkit.dtb
+# Keep at91 dtb files sorted alphabetically for each SoC
+dtb-$(CONFIG_SOC_SAM_V4_V5) += \
+	at91rm9200ek.dtb \
+	mpa1600.dtb \
+	animeo_ip.dtb \
+	at91-qil_a9260.dtb \
+	aks-cdu.dtb \
+	ethernut5.dtb \
+	evk-pro3.dtb \
+	tny_a9260.dtb \
+	usb_a9260.dtb \
+	at91sam9261ek.dtb \
+	at91sam9263ek.dtb \
+	tny_a9263.dtb \
+	usb_a9263.dtb \
+	at91-foxg20.dtb \
+	at91-kizbox.dtb \
+	at91sam9g20ek.dtb \
+	at91sam9g20ek_2mmc.dtb \
+	tny_a9g20.dtb \
+	usb_a9g20.dtb \
+	usb_a9g20_lpw.dtb \
+	at91sam9m10g45ek.dtb \
+	pm9g45.dtb \
+	at91sam9n12ek.dtb \
+	at91sam9rlek.dtb \
+	at91-ariag25.dtb \
+	at91-ariettag25.dtb \
+	at91-cosino_mega2560.dtb \
+	at91-kizboxmini.dtb \
+	at91sam9g15ek.dtb \
+	at91sam9g25ek.dtb \
+	at91sam9g35ek.dtb \
+	at91sam9x25ek.dtb \
+	at91sam9x35ek.dtb
+dtb-$(CONFIG_SOC_SAM_V7) += \
+	at91-kizbox2.dtb \
+	at91-sama5d2_xplained.dtb \
+	at91-sama5d3_xplained.dtb \
+	sama5d31ek.dtb \
+	sama5d33ek.dtb \
+	sama5d34ek.dtb \
+	sama5d35ek.dtb \
+	sama5d36ek.dtb \
+	at91-sama5d4_ma5d4evk.dtb \
+	at91-sama5d4_xplained.dtb \
+	at91-sama5d4ek.dtb \
+	at91-vinco.dtb
+dtb-$(CONFIG_ARCH_ATLAS6) += \
+	atlas6-evb.dtb
+dtb-$(CONFIG_ARCH_ATLAS7) += \
+	atlas7-evb.dtb
+dtb-$(CONFIG_ARCH_AXXIA) += \
+	axm5516-amarillo.dtb
+dtb-$(CONFIG_ARCH_BCM2835) += \
+	bcm2835-rpi-b.dtb \
+	bcm2835-rpi-b-rev2.dtb \
+	bcm2835-rpi-b-plus.dtb \
+	bcm2835-rpi-a-plus.dtb \
+	bcm2836-rpi-2-b.dtb
+dtb-$(CONFIG_ARCH_BCM_5301X) += \
+	bcm4708-asus-rt-ac56u.dtb \
+	bcm4708-asus-rt-ac68u.dtb \
+	bcm4708-buffalo-wzr-1750dhp.dtb \
+	bcm4708-luxul-xwc-1000.dtb \
+	bcm4708-netgear-r6250.dtb \
+	bcm4708-netgear-r6300-v2.dtb \
+	bcm4708-smartrg-sr400ac.dtb \
+	bcm47081-asus-rt-n18u.dtb \
+	bcm47081-buffalo-wzr-600dhp2.dtb \
+	bcm47081-buffalo-wzr-900dhp.dtb \
+	bcm4709-asus-rt-ac87u.dtb \
+	bcm4709-buffalo-wxr-1900dhp.dtb \
+	bcm4709-netgear-r7000.dtb \
+	bcm4709-netgear-r8000.dtb \
+	bcm94708.dtb \
+	bcm94709.dtb \
+	bcm953012k.dtb
+dtb-$(CONFIG_ARCH_BCM_63XX) += \
+	bcm963138dvt.dtb
+dtb-$(CONFIG_ARCH_BCM_CYGNUS) += \
+	bcm911360_entphn.dtb \
+	bcm911360k.dtb \
+	bcm958300k.dtb \
+	bcm958305k.dtb
+dtb-$(CONFIG_ARCH_BCM_MOBILE) += \
+	bcm28155-ap.dtb \
+	bcm21664-garnet.dtb
+dtb-$(CONFIG_ARCH_BCM_NSP) += \
+	bcm958625k.dtb
+dtb-$(CONFIG_ARCH_BERLIN) += \
+	berlin2-sony-nsz-gs7.dtb \
+	berlin2cd-google-chromecast.dtb \
+	berlin2q-marvell-dmp.dtb
+dtb-$(CONFIG_ARCH_BRCMSTB) += \
+	bcm7445-bcm97445svmb.dtb
+dtb-$(CONFIG_ARCH_DAVINCI) += \
+	da850-enbw-cmc.dtb \
+	da850-evm.dtb
+dtb-$(CONFIG_ARCH_DIGICOLOR) += \
+	cx92755_equinox.dtb
+dtb-$(CONFIG_ARCH_EFM32) += \
+	efm32gg-dk3750.dtb
+dtb-$(CONFIG_ARCH_EXYNOS3) += \
+	exynos3250-monk.dtb \
+	exynos3250-rinato.dtb
+dtb-$(CONFIG_ARCH_EXYNOS4) += \
+	exynos4210-origen.dtb \
+	exynos4210-smdkv310.dtb \
+	exynos4210-trats.dtb \
+	exynos4210-universal_c210.dtb \
+	exynos4412-odroidu3.dtb \
+	exynos4412-odroidx.dtb \
+	exynos4412-odroidx2.dtb \
+	exynos4412-origen.dtb \
+	exynos4412-smdk4412.dtb \
+	exynos4412-tiny4412.dtb \
+	exynos4412-trats2.dtb
+dtb-$(CONFIG_ARCH_EXYNOS5) += \
+	exynos5250-arndale.dtb \
+	exynos5250-smdk5250.dtb \
+	exynos5250-snow.dtb \
+	exynos5250-snow-rev5.dtb \
+	exynos5250-spring.dtb \
+	exynos5260-xyref5260.dtb \
+	exynos5410-smdk5410.dtb \
+	exynos5420-arndale-octa.dtb \
+	exynos5420-peach-pit.dtb \
+	exynos5420-smdk5420.dtb \
+	exynos5422-odroidxu3.dtb \
+	exynos5422-odroidxu3-lite.dtb \
+	exynos5422-odroidxu4.dtb \
+	exynos5440-sd5v1.dtb \
+	exynos5440-ssdk5440.dtb \
+	exynos5800-peach-pi.dtb
+dtb-$(CONFIG_ARCH_HI3xxx) += \
+	hi3620-hi4511.dtb
+dtb-$(CONFIG_ARCH_HIX5HD2) += \
+	hisi-x5hd2-dkb.dtb
+dtb-$(CONFIG_ARCH_HIGHBANK) += \
+	highbank.dtb \
+	ecx-2000.dtb
+dtb-$(CONFIG_ARCH_HIP01) += \
+	hip01-ca9x2.dtb
+dtb-$(CONFIG_ARCH_HIP04) += \
+	hip04-d01.dtb
+dtb-$(CONFIG_ARCH_INTEGRATOR) += \
+	integratorap.dtb \
+	integratorcp.dtb
+dtb-$(CONFIG_ARCH_KEYSTONE) += \
+	k2hk-evm.dtb \
+	k2l-evm.dtb \
+	k2e-evm.dtb
+dtb-$(CONFIG_MACH_KIRKWOOD) += \
+	kirkwood-b3.dtb \
+	kirkwood-blackarmor-nas220.dtb \
+	kirkwood-cloudbox.dtb \
+	kirkwood-d2net.dtb \
+	kirkwood-db-88f6281.dtb \
+	kirkwood-db-88f6282.dtb \
+	kirkwood-dir665.dtb \
+	kirkwood-dns320.dtb \
+	kirkwood-dns325.dtb \
+	kirkwood-dockstar.dtb \
+	kirkwood-dreamplug.dtb \
+	kirkwood-ds109.dtb \
+	kirkwood-ds110jv10.dtb \
+	kirkwood-ds111.dtb \
+	kirkwood-ds209.dtb \
+	kirkwood-ds210.dtb \
+	kirkwood-ds212.dtb \
+	kirkwood-ds212j.dtb \
+	kirkwood-ds409.dtb \
+	kirkwood-ds409slim.dtb \
+	kirkwood-ds411.dtb \
+	kirkwood-ds411j.dtb \
+	kirkwood-ds411slim.dtb \
+	kirkwood-goflexnet.dtb \
+	kirkwood-guruplug-server-plus.dtb \
+	kirkwood-ib62x0.dtb \
+	kirkwood-iconnect.dtb \
+	kirkwood-iomega_ix2_200.dtb \
+	kirkwood-is2.dtb \
+	kirkwood-km_kirkwood.dtb \
+	kirkwood-laplug.dtb \
+	kirkwood-lschlv2.dtb \
+	kirkwood-lswvl.dtb \
+	kirkwood-lswxl.dtb \
+	kirkwood-lsxhl.dtb \
+	kirkwood-mplcec4.dtb \
+	kirkwood-mv88f6281gtw-ge.dtb \
+	kirkwood-nas2big.dtb \
+	kirkwood-net2big.dtb \
+	kirkwood-net5big.dtb \
+	kirkwood-netgear_readynas_duo_v2.dtb \
+	kirkwood-netgear_readynas_nv+_v2.dtb \
+	kirkwood-ns2.dtb \
+	kirkwood-ns2lite.dtb \
+	kirkwood-ns2max.dtb \
+	kirkwood-ns2mini.dtb \
+	kirkwood-nsa310.dtb \
+	kirkwood-nsa310a.dtb \
+	kirkwood-nsa325.dtb \
+	kirkwood-openblocks_a6.dtb \
+	kirkwood-openblocks_a7.dtb \
+	kirkwood-openrd-base.dtb \
+	kirkwood-openrd-client.dtb \
+	kirkwood-openrd-ultimate.dtb \
+	kirkwood-pogo_e02.dtb \
+	kirkwood-pogoplug-series-4.dtb \
+	kirkwood-rd88f6192.dtb \
+	kirkwood-rd88f6281-z0.dtb \
+	kirkwood-rd88f6281-a.dtb \
+	kirkwood-rs212.dtb \
+	kirkwood-rs409.dtb \
+	kirkwood-rs411.dtb \
+	kirkwood-sheevaplug.dtb \
+	kirkwood-sheevaplug-esata.dtb \
+	kirkwood-t5325.dtb \
+	kirkwood-topkick.dtb \
+	kirkwood-ts219-6281.dtb \
+	kirkwood-ts219-6282.dtb \
+	kirkwood-ts419-6281.dtb \
+	kirkwood-ts419-6282.dtb
+dtb-$(CONFIG_ARCH_LPC18XX) += \
+	lpc4337-ciaa.dtb \
+	lpc4350-hitex-eval.dtb \
+	lpc4357-ea4357-devkit.dtb
+dtb-$(CONFIG_ARCH_LPC32XX) += \
+	ea3250.dtb phy3250.dtb
+dtb-$(CONFIG_MACH_MESON6) += \
+	meson6-atv1200.dtb
+dtb-$(CONFIG_MACH_MESON8) += \
+	meson8-minix-neo-x8.dtb
+dtb-$(CONFIG_ARCH_MMP) += \
+	pxa168-aspenite.dtb \
+	pxa910-dkb.dtb \
+	mmp2-brownstone.dtb
+dtb-$(CONFIG_MACH_MESON8B) += \
+	meson8b-mxq.dtb \
+	meson8b-odroidc1.dtb
+dtb-$(CONFIG_ARCH_MOXART) += \
+	moxart-uc7112lx.dtb
+dtb-$(CONFIG_SOC_IMX1) += \
+	imx1-ads.dtb \
+	imx1-apf9328.dtb
+dtb-$(CONFIG_SOC_IMX25) += \
+	imx25-eukrea-mbimxsd25-baseboard.dtb \
+	imx25-eukrea-mbimxsd25-baseboard-cmo-qvga.dtb \
+	imx25-eukrea-mbimxsd25-baseboard-dvi-svga.dtb \
+	imx25-eukrea-mbimxsd25-baseboard-dvi-vga.dtb \
+	imx25-karo-tx25.dtb \
+	imx25-pdk.dtb
+dtb-$(CONFIG_SOC_IMX27) += \
+	imx27-apf27.dtb \
+	imx27-apf27dev.dtb \
+	imx27-eukrea-mbimxsd27-baseboard.dtb \
+	imx27-pdk.dtb \
+	imx27-phytec-phycore-rdk.dtb \
+	imx27-phytec-phycard-s-rdk.dtb
+dtb-$(CONFIG_SOC_IMX31) += \
+	imx31-bug.dtb
+dtb-$(CONFIG_SOC_IMX35) += \
+	imx35-eukrea-mbimxsd35-baseboard.dtb \
+	imx35-pdk.dtb
+dtb-$(CONFIG_SOC_IMX50) += \
+	imx50-evk.dtb
+dtb-$(CONFIG_SOC_IMX51) += \
+	imx51-apf51.dtb \
+	imx51-apf51dev.dtb \
+	imx51-babbage.dtb \
+	imx51-digi-connectcore-jsk.dtb \
+	imx51-eukrea-mbimxsd51-baseboard.dtb \
+	imx51-ts4800.dtb
+dtb-$(CONFIG_SOC_IMX53) += \
+	imx53-ard.dtb \
+	imx53-m53evk.dtb \
+	imx53-mba53.dtb \
+	imx53-qsb.dtb \
+	imx53-qsrb.dtb \
+	imx53-smd.dtb \
+	imx53-tx53-x03x.dtb \
+	imx53-tx53-x13x.dtb \
+	imx53-voipac-bsb.dtb
+dtb-$(CONFIG_SOC_IMX6Q) += \
+	imx6dl-apf6dev.dtb \
+	imx6dl-aristainetos_4.dtb \
+	imx6dl-aristainetos_7.dtb \
+	imx6dl-aristainetos2_4.dtb \
+	imx6dl-aristainetos2_7.dtb \
+	imx6dl-cubox-i.dtb \
+	imx6dl-dfi-fs700-m60.dtb \
+	imx6dl-gw51xx.dtb \
+	imx6dl-gw52xx.dtb \
+	imx6dl-gw53xx.dtb \
+	imx6dl-gw54xx.dtb \
+	imx6dl-gw551x.dtb \
+	imx6dl-gw552x.dtb \
+	imx6dl-hummingboard.dtb \
+	imx6dl-nit6xlite.dtb \
+	imx6dl-nitrogen6x.dtb \
+	imx6dl-phytec-pbab01.dtb \
+	imx6dl-rex-basic.dtb \
+	imx6dl-riotboard.dtb \
+	imx6dl-sabreauto.dtb \
+	imx6dl-sabrelite.dtb \
+	imx6dl-sabresd.dtb \
+	imx6dl-tx6dl-comtft.dtb \
+	imx6dl-tx6u-801x.dtb \
+	imx6dl-tx6u-811x.dtb \
+	imx6dl-udoo.dtb \
+	imx6dl-wandboard.dtb \
+	imx6dl-wandboard-revb1.dtb \
+	imx6q-apf6dev.dtb \
+	imx6q-arm2.dtb \
+	imx6q-cm-fx6.dtb \
+	imx6q-cubox-i.dtb \
+	imx6q-dfi-fs700-m60.dtb \
+	imx6q-dmo-edmqmx6.dtb \
+	imx6q-gk802.dtb \
+	imx6q-gw51xx.dtb \
+	imx6q-gw52xx.dtb \
+	imx6q-gw53xx.dtb \
+	imx6q-gw5400-a.dtb \
+	imx6q-gw54xx.dtb \
+	imx6q-gw551x.dtb \
+	imx6q-gw552x.dtb \
+	imx6q-hummingboard.dtb \
+	imx6q-nitrogen6x.dtb \
+	imx6q-nitrogen6_max.dtb \
+	imx6q-novena.dtb \
+	imx6q-phytec-pbab01.dtb \
+	imx6q-rex-pro.dtb \
+	imx6q-sabreauto.dtb \
+	imx6q-sabrelite.dtb \
+	imx6q-sabresd.dtb \
+	imx6q-sbc6x.dtb \
+	imx6q-tbs2910.dtb \
+	imx6q-tx6q-1010.dtb \
+	imx6q-tx6q-1010-comtft.dtb \
+	imx6q-tx6q-1020.dtb \
+	imx6q-tx6q-1020-comtft.dtb \
+	imx6q-tx6q-1110.dtb \
+	imx6q-udoo.dtb \
+	imx6q-wandboard.dtb \
+	imx6q-wandboard-revb1.dtb
+dtb-$(CONFIG_SOC_IMX6SL) += \
+	imx6sl-evk.dtb \
+	imx6sl-warp.dtb
+dtb-$(CONFIG_SOC_IMX6SX) += \
+	imx6sx-sabreauto.dtb \
+	imx6sx-sdb-reva.dtb \
+	imx6sx-sdb.dtb
+dtb-$(CONFIG_SOC_IMX6UL) += \
+	imx6ul-14x14-evk.dtb
+dtb-$(CONFIG_SOC_IMX7D) += \
+	imx7d-cl-som-imx7.dtb \
+	imx7d-sbc-imx7.dtb \
+	imx7d-sdb.dtb
+dtb-$(CONFIG_SOC_LS1021A) += \
+	ls1021a-qds.dtb \
+	ls1021a-twr.dtb
+dtb-$(CONFIG_SOC_VF610) += \
+	vf500-colibri-eval-v3.dtb \
+	vf610-colibri-eval-v3.dtb \
+	vf610m4-colibri.dtb \
+	vf610-cosmic.dtb \
+	vf610m4-cosmic.dtb \
+	vf610-twr.dtb
+dtb-$(CONFIG_ARCH_MXS) += \
+	imx23-evk.dtb \
+	imx23-olinuxino.dtb \
+	imx23-stmp378x_devb.dtb \
+	imx28-apf28.dtb \
+	imx28-apf28dev.dtb \
+	imx28-apx4devkit.dtb \
+	imx28-cfa10036.dtb \
+	imx28-cfa10037.dtb \
+	imx28-cfa10049.dtb \
+	imx28-cfa10055.dtb \
+	imx28-cfa10056.dtb \
+	imx28-cfa10057.dtb \
+	imx28-cfa10058.dtb \
+	imx28-duckbill.dtb \
+	imx28-eukrea-mbmx283lc.dtb \
+	imx28-eukrea-mbmx287lc.dtb \
+	imx28-evk.dtb \
+	imx28-m28cu3.dtb \
+	imx28-m28evk.dtb \
+	imx28-sps1.dtb \
+	imx28-tx28.dtb
+dtb-$(CONFIG_ARCH_NOMADIK) += \
+	ste-nomadik-s8815.dtb \
+	ste-nomadik-nhk15.dtb
+dtb-$(CONFIG_ARCH_NSPIRE) += \
+	nspire-cx.dtb \
+	nspire-tp.dtb \
+	nspire-clp.dtb
+dtb-$(CONFIG_ARCH_OMAP2) += \
+	omap2420-h4.dtb \
+	omap2420-n800.dtb \
+	omap2420-n810.dtb \
+	omap2420-n810-wimax.dtb \
+	omap2430-sdp.dtb
+dtb-$(CONFIG_ARCH_OMAP3) += \
+	am3517-craneboard.dtb \
+	am3517-evm.dtb \
+	am3517_mt_ventoux.dtb \
+	logicpd-torpedo-37xx-devkit.dtb \
+	omap3430-sdp.dtb \
+	omap3-beagle.dtb \
+	omap3-beagle-xm.dtb \
+	omap3-beagle-xm-ab.dtb \
+	omap3-cm-t3517.dtb \
+	omap3-cm-t3530.dtb \
+	omap3-cm-t3730.dtb \
+	omap3-devkit8000.dtb \
+	omap3-devkit8000-lcd43.dtb \
+	omap3-devkit8000-lcd70.dtb \
+	omap3-evm.dtb \
+	omap3-evm-37xx.dtb \
+	omap3-gta04a3.dtb \
+	omap3-gta04a4.dtb \
+	omap3-gta04a5.dtb \
+	omap3-ha.dtb \
+	omap3-ha-lcd.dtb \
+	omap3-igep0020.dtb \
+	omap3-igep0020-rev-f.dtb \
+	omap3-igep0030.dtb \
+	omap3-igep0030-rev-g.dtb \
+	omap3-ldp.dtb \
+	omap3-lilly-dbb056.dtb \
+	omap3-n900.dtb \
+	omap3-n9.dtb \
+	omap3-n950.dtb \
+	omap3-overo-alto35.dtb \
+	omap3-overo-chestnut43.dtb \
+	omap3-overo-gallop43.dtb \
+	omap3-overo-palo35.dtb \
+	omap3-overo-palo43.dtb \
+	omap3-overo-storm-alto35.dtb \
+	omap3-overo-storm-chestnut43.dtb \
+	omap3-overo-storm-gallop43.dtb \
+	omap3-overo-storm-palo35.dtb \
+	omap3-overo-storm-palo43.dtb \
+	omap3-overo-storm-summit.dtb \
+	omap3-overo-storm-tobi.dtb \
+	omap3-overo-storm-tobiduo.dtb \
+	omap3-overo-summit.dtb \
+	omap3-overo-tobi.dtb \
+	omap3-overo-tobiduo.dtb \
+	omap3-pandora-600mhz.dtb \
+	omap3-pandora-1ghz.dtb \
+	omap3-sbc-t3517.dtb \
+	omap3-sbc-t3530.dtb \
+	omap3-sbc-t3730.dtb \
+	omap3-thunder.dtb \
+	omap3-zoom3.dtb
+dtb-$(CONFIG_SOC_TI81XX) += \
+	dm8148-evm.dtb \
+	dm8148-t410.dtb \
+	dm8168-evm.dtb \
+	dra62x-j5eco-evm.dtb
+dtb-$(CONFIG_SOC_AM33XX) += \
+	am335x-baltos-ir5221.dtb \
+	am335x-base0033.dtb \
+	am335x-bone.dtb \
+	am335x-boneblack.dtb \
+	am335x-bonegreen.dtb \
+	am335x-chiliboard.dtb \
+	am335x-cm-t335.dtb \
+	am335x-evm.dtb \
+	am335x-evmsk.dtb \
+	am335x-lxm.dtb \
+	am335x-nano.dtb \
+	am335x-pepper.dtb \
+	am335x-shc.dtb \
+	am335x-sbc-t335.dtb \
+	am335x-sl50.dtb \
+	am335x-wega-rdk.dtb
+dtb-$(CONFIG_ARCH_OMAP4) += \
+	omap4-duovero-parlor.dtb \
+	omap4-panda.dtb \
+	omap4-panda-a4.dtb \
+	omap4-panda-es.dtb \
+	omap4-sdp.dtb \
+	omap4-sdp-es23plus.dtb \
+	omap4-var-dvk-om44.dtb \
+	omap4-var-stk-om44.dtb
+dtb-$(CONFIG_SOC_AM43XX) += \
+	am43x-epos-evm.dtb \
+	am437x-cm-t43.dtb \
+	am437x-gp-evm.dtb \
+	am437x-idk-evm.dtb \
+	am437x-sbc-t43.dtb \
+	am437x-sk-evm.dtb
+dtb-$(CONFIG_SOC_OMAP5) += \
+	omap5-cm-t54.dtb \
+	omap5-igep0050.dtb \
+	omap5-sbc-t54.dtb \
+	omap5-uevm.dtb
+dtb-$(CONFIG_SOC_DRA7XX) += \
+	am57xx-beagle-x15.dtb \
+	am57xx-cl-som-am57x.dtb \
+	am57xx-sbc-am57x.dtb \
+	dra7-evm.dtb \
+	dra72-evm.dtb
+dtb-$(CONFIG_ARCH_ORION5X) += \
+	orion5x-lacie-d2-network.dtb \
+	orion5x-lacie-ethernet-disk-mini-v2.dtb \
+	orion5x-linkstation-lswtgl.dtb \
+	orion5x-lswsgl.dtb \
+	orion5x-maxtor-shared-storage-2.dtb \
+	orion5x-rd88f5182-nas.dtb
+dtb-$(CONFIG_ARCH_PRIMA2) += \
+	prima2-evb.dtb
+dtb-$(CONFIG_ARCH_QCOM) += \
+	qcom-apq8064-cm-qs600.dtb \
+	qcom-apq8064-ifc6410.dtb \
+	qcom-apq8064-sony-xperia-yuga.dtb \
+	qcom-apq8074-dragonboard.dtb \
+	qcom-apq8084-ifc6540.dtb \
+	qcom-apq8084-mtp.dtb \
+	qcom-ipq8064-ap148.dtb \
+	qcom-msm8660-surf.dtb \
+	qcom-msm8960-cdp.dtb \
+	qcom-msm8974-sony-xperia-honami.dtb
+dtb-$(CONFIG_ARCH_REALVIEW) += \
+	arm-realview-pb1176.dtb \
+	arm-realview-pb11mp.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += \
+	rk3036-evb.dtb \
+	rk3036-kylin.dtb \
+	rk3066a-bqcurie2.dtb \
+	rk3066a-marsboard.dtb \
+	rk3066a-rayeager.dtb \
+	rk3188-radxarock.dtb \
+	rk3228-evb.dtb \
+	rk3288-evb-act8846.dtb \
+	rk3288-evb-rk808.dtb \
+	rk3288-firefly-beta.dtb \
+	rk3288-firefly.dtb \
+	rk3288-popmetal.dtb \
+	rk3288-r89.dtb \
+	rk3288-rock2-square.dtb \
+	rk3288-veyron-brain.dtb \
+	rk3288-veyron-jaq.dtb \
+	rk3288-veyron-jerry.dtb \
+	rk3288-veyron-mickey.dtb \
+	rk3288-veyron-minnie.dtb \
+	rk3288-veyron-pinky.dtb \
+	rk3288-veyron-speedy.dtb
+dtb-$(CONFIG_ARCH_S3C24XX) += \
+	s3c2416-smdk2416.dtb
+dtb-$(CONFIG_ARCH_S3C64XX) += \
+	s3c6410-mini6410.dtb \
+	s3c6410-smdk6410.dtb
+dtb-$(CONFIG_ARCH_S5PV210) += \
+	s5pv210-aquila.dtb \
+	s5pv210-goni.dtb \
+	s5pv210-smdkc110.dtb \
+	s5pv210-smdkv210.dtb \
+	s5pv210-torbreck.dtb
+dtb-$(CONFIG_ARCH_SHMOBILE_MULTI) += \
+	emev2-kzm9d.dtb \
+	r7s72100-genmai.dtb \
+	r8a73a4-ape6evm.dtb \
+	r8a7740-armadillo800eva.dtb \
+	r8a7778-bockw.dtb \
+	r8a7779-marzen.dtb \
+	r8a7790-lager.dtb \
+	r8a7791-koelsch.dtb \
+	r8a7791-porter.dtb \
+	r8a7793-gose.dtb \
+	r8a7794-alt.dtb \
+	r8a7794-silk.dtb \
+	sh73a0-kzm9g.dtb
+dtb-$(CONFIG_ARCH_SOCFPGA) += \
+	socfpga_arria5_socdk.dtb \
+	socfpga_arria10_socdk_sdmmc.dtb \
+	socfpga_cyclone5_mcvevk.dtb \
+	socfpga_cyclone5_socdk.dtb \
+	socfpga_cyclone5_de0_sockit.dtb \
+	socfpga_cyclone5_sockit.dtb \
+	socfpga_cyclone5_socrates.dtb \
+	socfpga_vt.dtb
+dtb-$(CONFIG_ARCH_SPEAR13XX) += \
+	spear1310-evb.dtb \
+	spear1340-evb.dtb
+dtb-$(CONFIG_ARCH_SPEAR3XX) += \
+	spear300-evb.dtb \
+	spear310-evb.dtb \
+	spear320-evb.dtb \
+	spear320-hmi.dtb
+dtb-$(CONFIG_ARCH_SPEAR6XX) += \
+	spear600-evb.dtb
+dtb-$(CONFIG_ARCH_STI) += \
+	stih407-b2120.dtb \
+	stih410-b2120.dtb \
+	stih415-b2000.dtb \
+	stih415-b2020.dtb \
+	stih416-b2000.dtb \
+	stih416-b2020.dtb \
+	stih416-b2020e.dtb \
+	stih418-b2199.dtb
+dtb-$(CONFIG_ARCH_STM32)+= \
+	stm32f429-disco.dtb \
+	stm32429i-eval.dtb
+dtb-$(CONFIG_MACH_SUN4I) += \
+	sun4i-a10-a1000.dtb \
+	sun4i-a10-ba10-tvbox.dtb \
+	sun4i-a10-chuwi-v7-cw0825.dtb \
+	sun4i-a10-cubieboard.dtb \
+	sun4i-a10-gemei-g9.dtb \
+	sun4i-a10-hackberry.dtb \
+	sun4i-a10-hyundai-a7hd.dtb \
+	sun4i-a10-inet1.dtb \
+	sun4i-a10-inet97fv2.dtb \
+	sun4i-a10-inet9f-rev03.dtb \
+	sun4i-a10-itead-iteaduino-plus.dtb \
+	sun4i-a10-jesurun-q5.dtb \
+	sun4i-a10-marsboard.dtb \
+	sun4i-a10-mini-xplus.dtb \
+	sun4i-a10-mk802.dtb \
+	sun4i-a10-mk802ii.dtb \
+	sun4i-a10-olinuxino-lime.dtb \
+	sun4i-a10-pcduino.dtb \
+	sun4i-a10-pcduino2.dtb \
+	sun4i-a10-pov-protab2-ips9.dtb
+dtb-$(CONFIG_MACH_SUN5I) += \
+	sun5i-a10s-auxtek-t003.dtb \
+	sun5i-a10s-auxtek-t004.dtb \
+	sun5i-a10s-mk802.dtb \
+	sun5i-a10s-olinuxino-micro.dtb \
+	sun5i-a10s-r7-tv-dongle.dtb \
+	sun5i-a10s-wobo-i5.dtb \
+	sun5i-a13-empire-electronix-d709.dtb \
+	sun5i-a13-hsg-h702.dtb \
+	sun5i-a13-inet-98v-rev2.dtb \
+	sun5i-a13-olinuxino.dtb \
+	sun5i-a13-olinuxino-micro.dtb \
+	sun5i-a13-q8-tablet.dtb \
+	sun5i-a13-utoo-p66.dtb \
+	sun5i-r8-chip.dtb
+dtb-$(CONFIG_MACH_SUN6I) += \
+	sun6i-a31-app4-evb1.dtb \
+	sun6i-a31-colombus.dtb \
+	sun6i-a31-hummingbird.dtb \
+	sun6i-a31-i7.dtb \
+	sun6i-a31-m9.dtb \
+	sun6i-a31-mele-a1000g-quad.dtb \
+	sun6i-a31s-cs908.dtb \
+	sun6i-a31s-primo81.dtb \
+	sun6i-a31s-sina31s.dtb \
+	sun6i-a31s-sinovoip-bpi-m2.dtb \
+	sun6i-a31s-yones-toptech-bs1078-v2.dtb
+dtb-$(CONFIG_MACH_SUN7I) += \
+	sun7i-a20-bananapi.dtb \
+	sun7i-a20-bananapro.dtb \
+	sun7i-a20-cubieboard2.dtb \
+	sun7i-a20-cubietruck.dtb \
+	sun7i-a20-hummingbird.dtb \
+	sun7i-a20-i12-tvbox.dtb \
+	sun7i-a20-icnova-swac.dtb \
+	sun7i-a20-m3.dtb \
+	sun7i-a20-mk808c.dtb \
+	sun7i-a20-olimex-som-evb.dtb \
+	sun7i-a20-olinuxino-lime.dtb \
+	sun7i-a20-olinuxino-lime2.dtb \
+	sun7i-a20-olinuxino-micro.dtb \
+	sun7i-a20-orangepi.dtb \
+	sun7i-a20-orangepi-mini.dtb \
+	sun7i-a20-pcduino3.dtb \
+	sun7i-a20-pcduino3-nano.dtb \
+	sun7i-a20-wexler-tab7200.dtb \
+	sun7i-a20-wits-pro-a20-dkt.dtb
+dtb-$(CONFIG_MACH_SUN8I) += \
+	sun8i-a23-evb.dtb \
+	sun8i-a23-gt90h-v4.dtb \
+	sun8i-a23-ippo-q8h-v5.dtb \
+	sun8i-a23-ippo-q8h-v1.2.dtb \
+	sun8i-a23-q8-tablet.dtb \
+	sun8i-a33-et-q8-v1.6.dtb \
+	sun8i-a33-ga10h-v1.1.dtb \
+	sun8i-a33-ippo-q8h-v1.2.dtb \
+	sun8i-a33-q8-tablet.dtb \
+	sun8i-a33-sinlinx-sina33.dtb \
+	sun8i-h3-orangepi-plus.dtb
+dtb-$(CONFIG_MACH_SUN9I) += \
+	sun9i-a80-optimus.dtb \
+	sun9i-a80-cubieboard4.dtb
+dtb-$(CONFIG_ARCH_TANGO) += \
+	tango4-vantage-1172.dtb
+dtb-$(CONFIG_ARCH_TEGRA_2x_SOC) += \
+	tegra20-harmony.dtb \
+	tegra20-iris-512.dtb \
+	tegra20-medcom-wide.dtb \
+	tegra20-paz00.dtb \
+	tegra20-plutux.dtb \
+	tegra20-seaboard.dtb \
+	tegra20-tec.dtb \
+	tegra20-trimslice.dtb \
+	tegra20-ventana.dtb \
+	tegra20-whistler.dtb
+dtb-$(CONFIG_ARCH_TEGRA_3x_SOC) += \
+	tegra30-apalis-eval.dtb \
+	tegra30-beaver.dtb \
+	tegra30-cardhu-a02.dtb \
+	tegra30-cardhu-a04.dtb \
+	tegra30-colibri-eval-v3.dtb
+dtb-$(CONFIG_ARCH_TEGRA_114_SOC) += \
+	tegra114-dalmore.dtb \
+	tegra114-roth.dtb \
+	tegra114-tn7.dtb
+dtb-$(CONFIG_ARCH_TEGRA_124_SOC) += \
+	tegra124-jetson-tk1.dtb \
+	tegra124-nyan-big.dtb \
+	tegra124-nyan-blaze.dtb \
+	tegra124-venice2.dtb
+dtb-$(CONFIG_ARCH_U300) += \
+	ste-u300.dtb
+dtb-$(CONFIG_ARCH_U8500) += \
+	ste-snowball.dtb \
+	ste-hrefprev60-stuib.dtb \
+	ste-hrefprev60-tvk.dtb \
+	ste-hrefv60plus-stuib.dtb \
+	ste-hrefv60plus-tvk.dtb \
+	ste-ccu8540.dtb \
+	ste-ccu9540.dtb
+dtb-$(CONFIG_ARCH_UNIPHIER) += \
+	uniphier-ph1-ld4-ref.dtb \
+	uniphier-ph1-ld6b-ref.dtb \
+	uniphier-ph1-pro4-ref.dtb \
+	uniphier-ph1-sld3-ref.dtb \
+	uniphier-ph1-sld8-ref.dtb \
+	uniphier-proxstream2-gentil.dtb \
+	uniphier-proxstream2-vodka.dtb
+dtb-$(CONFIG_ARCH_VERSATILE) += \
+	versatile-ab.dtb \
+	versatile-pb.dtb
+dtb-$(CONFIG_ARCH_VEXPRESS) += \
+	vexpress-v2p-ca5s.dtb \
+	vexpress-v2p-ca9.dtb \
+	vexpress-v2p-ca15-tc1.dtb \
+	vexpress-v2p-ca15_a7.dtb
+dtb-$(CONFIG_ARCH_VIRT) += \
+	xenvm-4.2.dtb
+dtb-$(CONFIG_ARCH_VT8500) += \
+	vt8500-bv07.dtb \
+	wm8505-ref.dtb \
+	wm8650-mid.dtb \
+	wm8750-apc8750.dtb \
+	wm8850-w70v2.dtb
+dtb-$(CONFIG_ARCH_ZYNQ) += \
+	zynq-parallella.dtb \
+	zynq-zc702.dtb \
+	zynq-zc706.dtb \
+	zynq-zed.dtb \
+	zynq-zybo.dtb
+dtb-$(CONFIG_MACH_ARMADA_370) += \
+	armada-370-db.dtb \
+	armada-370-dlink-dns327l.dtb \
+	armada-370-mirabox.dtb \
+	armada-370-netgear-rn102.dtb \
+	armada-370-netgear-rn104.dtb \
+	armada-370-rd.dtb \
+	armada-370-seagate-nas-2bay.dtb \
+	armada-370-seagate-nas-4bay.dtb \
+	armada-370-seagate-personal-cloud.dtb \
+	armada-370-seagate-personal-cloud-2bay.dtb \
+	armada-370-synology-ds213j.dtb
+dtb-$(CONFIG_MACH_ARMADA_375) += \
+	armada-375-db.dtb
+dtb-$(CONFIG_MACH_ARMADA_38X) += \
+	armada-385-db-ap.dtb \
+	armada-385-linksys-caiman.dtb \
+	armada-385-linksys-cobra.dtb \
+	armada-388-clearfog.dtb \
+	armada-388-db.dtb \
+	armada-388-gp.dtb \
+	armada-388-rd.dtb
+dtb-$(CONFIG_MACH_ARMADA_39X) += \
+	armada-398-db.dtb
+dtb-$(CONFIG_MACH_ARMADA_XP) += \
+	armada-xp-axpwifiap.dtb \
+	armada-xp-db.dtb \
+	armada-xp-gp.dtb \
+	armada-xp-lenovo-ix4-300d.dtb \
+	armada-xp-linksys-mamba.dtb \
+	armada-xp-matrix.dtb \
+	armada-xp-netgear-rn2120.dtb \
+	armada-xp-openblocks-ax3-4.dtb \
+	armada-xp-synology-ds414.dtb
+dtb-$(CONFIG_MACH_DOVE) += \
+	dove-cubox.dtb \
+	dove-cubox-es.dtb \
+	dove-d2plug.dtb \
+	dove-d3plug.dtb \
+	dove-dove-db.dtb \
+	dove-sbc-a510.dtb
+dtb-$(CONFIG_ARCH_MEDIATEK) += \
+	mt2701-evb.dtb \
+	mt6580-evbp1.dtb \
+	mt6589-aquaris5.dtb \
+	mt6592-evb.dtb \
+	mt8127-moose.dtb \
+	mt8135-evbp1.dtb
+dtb-$(CONFIG_ARCH_ZX) += zx296702-ad1.dtb
+endif
+
+dtstree		:= $(srctree)/$(src)
+dtb-$(CONFIG_OF_ALL_DTBS) := $(patsubst $(dtstree)/%.dts,%.dtb, $(wildcard $(dtstree)/*.dts))
+
+always		:= $(dtb-y)
+clean-files	:= *.dtb
diff -Naur linux-4.5/arch/arm/boot/dts/vt8500-bv07.dts wm8505_linux4.5/arch/arm/boot/dts/vt8500-bv07.dts
--- linux-4.5/arch/arm/boot/dts/vt8500-bv07.dts	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/arch/arm/boot/dts/vt8500-bv07.dts	2019-03-28 09:01:27.000000000 -0700
@@ -11,6 +11,14 @@
 
 / {
 	model = "Benign BV07 Netbook";
+
+	backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm 0 50000>;
+
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <5>;
+	};
 };
 
 &fb {
@@ -31,6 +39,20 @@
 	};
 };
 
+&uart0 {
+	status = "okay";
+};
+
+&pinctrl {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c>;
+
+	i2c: i2c {
+		wm,pins = <88 89 90 91>;
+		wm,function = <2>;
+	};
+};
+
 &uart0 {
 	status = "okay";
 };
diff -Naur linux-4.5/arch/arm/boot/dts/vt8500.dtsi wm8505_linux4.5/arch/arm/boot/dts/vt8500.dtsi
--- linux-4.5/arch/arm/boot/dts/vt8500.dtsi	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/arch/arm/boot/dts/vt8500.dtsi	2019-03-28 09:01:27.000000000 -0700
@@ -65,6 +65,19 @@
 					clock-frequency = <24000000>;
 				};
 
+				ref25: ref25M {
+ 					#clock-cells = <0>;
+ 					compatible = "fixed-clock";
+					clock-frequency = <25000000>;
+				};
+
+				pllb: pllb {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-pll-clock";
+					clocks = <&ref25>;
+					reg = <0x204>;
+				};
+
 				clkuart0: uart0 {
 					#clock-cells = <0>;
 					compatible = "via,vt8500-device-clock";
@@ -96,9 +109,25 @@
 					enable-reg = <0x250>;
 					enable-bit = <4>;
 				};
+
+				clkpwm: pwm {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x348>;
+					enable-reg = <0x250>;
+					enable-bit = <14>;
+				};
 			};
 		};
 
+		pwm: pwm@d8220000 {
+			#pwm-cells = <3>;
+			compatible = "via,vt8500-pwm";
+			reg = <0xd8220000 0x100>;
+			clocks = <&clkpwm>;
+		};
+
 		timer@d8130100 {
 			compatible = "via,vt8500-timer";
 			reg = <0xd8130100 0x28>;
diff -Naur linux-4.5/arch/arm/boot/dts/wm8505.dtsi wm8505_linux4.5/arch/arm/boot/dts/wm8505.dtsi
--- linux-4.5/arch/arm/boot/dts/wm8505.dtsi	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/arch/arm/boot/dts/wm8505.dtsi	2019-03-28 09:01:27.000000000 -0700
@@ -21,13 +21,14 @@
 		};
 	};
 
- 	aliases {
+	aliases {
 		serial0 = &uart0;
 		serial1 = &uart1;
 		serial2 = &uart2;
 		serial3 = &uart3;
 		serial4 = &uart4;
 		serial5 = &uart5;
+		i2c0 = &i2c_0;
  	};
 
 	soc {
@@ -54,7 +55,7 @@
 		};
 
 		pinctrl: pinctrl@d8110000 {
-			compatible = "wm,wm8505-pinctrl";
+			compatible = "wm,wm8505-pinctrl","wm,prizm-pinctrl";
 			reg = <0xd8110000 0x10000>;
 			interrupt-controller;
 			#interrupt-cells = <2>;
@@ -194,9 +195,49 @@
 					enable-reg = <0x254>;
 					enable-bit = <18>;
 				};
+
+				clkpwm: pwm {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x348>;
+					enable-reg = <0x250>;
+					enable-bit = <10>;
+				};
+
+				clksf: sf {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x314>;
+					enable-reg = <0x254>;
+					enable-bit = <23>;
+				};
+
+				clki2c0: i2c0clk {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x36C>;
+					enable-reg = <0x250>;
+					enable-bit = <5>;
+				};
 			};
 		};
 
+		pwm: pwm@d8220000 {
+			#pwm-cells = <3>;
+			compatible = "via,vt8500-pwm";
+			reg = <0xd8220000 0x100>;
+			clocks = <&clkpwm>;
+		};
+
+		sf@d8002000 {
+			compatible = "wm,wm8505-sf";
+			reg = <0xd8002000 0x400>;
+			clocks = <&clksf>;
+		};
+
 		timer@d8130100 {
 			compatible = "via,vt8500-timer";
 			reg = <0xd8130100 0x28>;
@@ -286,5 +327,30 @@
 			clocks = <&clksdhc>;
 			bus-width = <4>;
 		};
+
+		keyboard@d8008800 {
+			compatible = "intel,8042";
+			reg = <0xD8008800 0x100>;
+			interrupts = <23 4>;
+			command-reg = <0x04>;
+			status-reg = <0x04>;
+			data-reg = <0x00>;
+			init-reset;
+		};
+
+		i2c_0: i2c@d8280000 {
+			compatible = "wm,wm8505-i2c";
+			reg = <0xd8280000 0x1000>;
+			interrupts = <19>;
+			clocks = <&clki2c0>;
+			clock-frequency = <400000>;
+		};
+
+		eth0@d8004000 {
+			compatible = "via,velocity-vt6110";
+			reg = <0xd8004000 0x400>;
+			interrupts = <10>;
+			no-eeprom;
+		};
 	};
 };
diff -Naur linux-4.5/arch/arm/boot/dts/wm8505-ref.dts wm8505_linux4.5/arch/arm/boot/dts/wm8505-ref.dts
--- linux-4.5/arch/arm/boot/dts/wm8505-ref.dts	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/arch/arm/boot/dts/wm8505-ref.dts	2019-03-28 09:01:27.000000000 -0700
@@ -11,6 +11,21 @@
 
 / {
 	model = "Wondermedia WM8505 Netbook";
+
+	backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm 0 50000 0>;
+
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <5>;
+	};
+
+	powerkey: pwrkey@0 {
+		compatible = "wm,power-keypad";
+		interrupt-parent = <&intc0>;
+		interrupts = <22>;
+		keymap = <116>; /* KEY_POWER */
+	};
 };
 
 &fb {
@@ -31,6 +46,20 @@
 	};
 };
 
+&uart0 {
+	status = "okay";
+};
+
+&pinctrl {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c>;
+
+	i2c: i2c {
+		wm,pins = <320 321 322 323 324 325>;
+		wm,function = <2>;
+	};
+};
+
 &uart0 {
 	status = "okay";
 };
diff -Naur linux-4.5/arch/arm/boot/dts/wm8650.dtsi wm8505_linux4.5/arch/arm/boot/dts/wm8650.dtsi
--- linux-4.5/arch/arm/boot/dts/wm8650.dtsi	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/arch/arm/boot/dts/wm8650.dtsi	2019-03-28 09:01:27.000000000 -0700
@@ -21,9 +21,11 @@
 		};
 	};
 
- 	aliases {
+	aliases {
 		serial0 = &uart0;
 		serial1 = &uart1;
+		i2c0 = &i2c_0;
+		i2c1 = &i2c_1;
 	};
 
 	soc {
@@ -50,7 +52,7 @@
 		};
 
 		pinctrl: pinctrl@d8110000 {
-			compatible = "wm,wm8650-pinctrl";
+			compatible = "wm,wm8650-pinctrl","wm,prizm-pinctrl";
 			reg = <0xd8110000 0x10000>;
 			interrupt-controller;
 			#interrupt-cells = <2>;
@@ -166,9 +168,83 @@
 					enable-reg = <0x254>;
 					enable-bit = <18>;
 				};
+
+				clkpwm: pwm {
+ 					#clock-cells = <0>;
+ 					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x348>;
+					enable-reg = <0x250>;
+					enable-bit = <10>;
+ 				};
+
+				clksf: sf {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x314>;
+					enable-reg = <0x254>;
+					enable-bit = <23>;
+				};
+
+				clki2c0: i2c0clk {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x36C>;
+					enable-reg = <0x250>;
+					enable-bit = <5>;
+				};
+
+				clki2c1: i2c1clk {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x378>;
+					enable-reg = <0x250>;
+					enable-bit = <9>;
+				};
 			};
 		};
 
+		pwm: pwm@d8220000 {
+			#pwm-cells = <3>;
+			compatible = "via,vt8500-pwm";
+			reg = <0xd8220000 0x100>;
+			clocks = <&clkpwm>;
+		};
+
+		sf@d8002000 {
+			compatible = "wm,wm8505-sf";
+			reg = <0xd8002000 0x400>;
+			clocks = <&clksf>;
+		};
+
+		sdhc@d800a000 {
+			compatible = "wm,wm8505-sdhc";
+			reg = <0xd800a000 0x1000>;
+			interrupts = <20 21>;
+			clocks = <&clksdhc>;
+			bus-width = <4>;
+			sdon-inverted;
+		};
+
+		i2c_0: i2c@d8280000 {
+			compatible = "wm,wm8505-i2c";
+			reg = <0xd8280000 0x1000>;
+			interrupts = <19>;
+			clocks = <&clki2c0>;
+			clock-frequency = <400000>;
+		};
+
+		i2c_1: i2c@d8320000 {
+			compatible = "wm,wm8505-i2c";
+			reg = <0xd8320000 0x1000>;
+			interrupts = <34>;
+			clocks = <&clki2c1>;
+			clock-frequency = <400000>;
+		};
+
 		timer@d8130100 {
 			compatible = "via,vt8500-timer";
 			reg = <0xd8130100 0x28>;
diff -Naur linux-4.5/arch/arm/boot/dts/wm8650-mid.dts wm8505_linux4.5/arch/arm/boot/dts/wm8650-mid.dts
--- linux-4.5/arch/arm/boot/dts/wm8650-mid.dts	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/arch/arm/boot/dts/wm8650-mid.dts	2019-03-28 09:01:27.000000000 -0700
@@ -11,6 +11,21 @@
 
 / {
 	model = "Wondermedia WM8650-MID Tablet";
+
+	backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm 0 50000>;
+
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <5>;
+	};
+
+	powerkey: pwrkey@0 {
+		compatible = "wm,power-keypad";
+		interrupt-parent = <&intc0>;
+		interrupts = <22>;
+		keymap = <116>; /* KEY_POWER */
+	};
 };
 
 &fb {
@@ -32,6 +47,21 @@
 	};
 };
 
+&uart0 {
+	status = "okay";
+};
+
+&pinctrl {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c>;
+
+	i2c: i2c {
+		wm,pins = <168 169 76 77>;
+		wm,function = <2>; /* alt */
+		wm,pull = <2>; /* pull-up */
+	};
+};
+
 &uart0 {
 	status = "okay";
 };
diff -Naur linux-4.5/arch/arm/boot/dts/wm8750-apc8750.dts wm8505_linux4.5/arch/arm/boot/dts/wm8750-apc8750.dts
--- linux-4.5/arch/arm/boot/dts/wm8750-apc8750.dts	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/arch/arm/boot/dts/wm8750-apc8750.dts	2019-03-28 09:01:27.000000000 -0700
@@ -12,17 +12,103 @@
 
 / {
 	model = "VIA APC8750";
+
+	fb@d8050800 {
+		compatible = "wm,wm8505-fb";
+		reg = <0xd8050800 0x200>;
+		bits-per-pixel = <16>;
+		clocks = <&clkdvo>;
+
+		display-timings {
+			native-mode = <&timing0>;
+			timing0: 1024x768 {
+				clock-frequency = <65000000>;
+				hactive = <1024>;
+				vactive = <768>;
+				hfront-porch = <25>;
+				hback-porch = <295>;
+				hsync-len = <136>;
+				vback-porch = <36>;
+				vfront-porch = <2>;
+				vsync-len = <6>;
+			};
+		};
+	};
+
+	powerkey: pwrkey@0 {
+		compatible = "wm,power-keypad";
+		interrupt-parent = <&intc0>;
+		interrupts = <22>;
+		keymap = <116>; /* KEY_POWER */
+	};
+};
+
+&nand {
+	nand-ecc-mode = "hw";
+	nand-bus-width = <8>;
+	nand-on-flash-bbt;
+
+	partition@0 {
+		label = "w-load";
+		reg = <0x00000000 0x100000>;
+	};
+	partition@100000 {
+		label = "u-boot env cfg";
+		reg = <0x00100000 0x900000>;
+	};
+	partition@A00000 {
+		label = "u-boot";
+		reg = <0x00A00000 0x900000>;
+	};
+	partition@1300000 {
+		label = "kernel";
+		reg = <0x01300000 0x800000>;
+	};
+	partition@1B00000 {
+		label = "initrd";
+		reg = <0x01B00000 0x600000>;
+	};
+	partition@2100000 {
+		label = "filesystem";
+		reg = <0x02100000 0x10000000>;
+	};
+	partition@12100000 {
+		label = "u-boot-logo";
+		reg = <0x12100000 0x200000>;
+	};
+	partition@12300000 {
+		label = "kernel-logo";
+		reg = <0x12300000 0x400000>;
+	};
+	partition@16300000 {
+		label = "android-data";
+		reg = <0x16300000 0x40000000>;
+	};
+	partition@56300000 {
+		label = "android-cache";
+		reg = <0x56300000 0x8000000>;
+	};
+	partition@5E300000 {
+		label = "LocalDisk";
+		reg = <0x5E300000 0x21D00000>;
+	};
 };
 
 &pinctrl {
 	pinctrl-names = "default";
-	pinctrl-0 = <&i2c>;
+	pinctrl-0 = <&i2c &vga>;
 
 	i2c: i2c {
 		wm,pins = <168 169 170 171>;
 		wm,function = <2>;	/* alt */
 		wm,pull = <2>;	/* pull-up */
 	};
+
+	vga: vga {
+		wm,pins = <72 73 74 75 76 77 78 79>;
+		wm,function = <2>;	/* alt */
+	};
+
 };
 
 &uart0 {
diff -Naur linux-4.5/arch/arm/boot/dts/wm8750.dtsi wm8505_linux4.5/arch/arm/boot/dts/wm8750.dtsi
--- linux-4.5/arch/arm/boot/dts/wm8750.dtsi	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/arch/arm/boot/dts/wm8750.dtsi	2019-03-28 09:01:27.000000000 -0700
@@ -56,7 +56,7 @@
 		};
 
 		pinctrl: pinctrl@d8110000 {
-			compatible = "wm,wm8750-pinctrl";
+			compatible = "wm,wm8750-pinctrl","wm,prizm-pinctrl";
 			reg = <0xd8110000 0x10000>;
 			interrupt-controller;
 			#interrupt-cells = <2>;
@@ -147,6 +147,15 @@
 					divisor-reg = <0x310>;
 				};
 
+				clkdvo: dvo {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllc>;
+					divisor-reg = <0x36C>;
+					enable-reg = <0x258>;
+					enable-bit = <30>;
+				};
+
 				clkuart0: uart0 {
 					#clock-cells = <0>;
 					compatible = "via,vt8500-device-clock";
@@ -214,6 +223,24 @@
 					enable-bit = <0>;
 				};
 
+				clksf: sf {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x314>;
+					enable-reg = <0x254>;
+					enable-bit = <23>;
+				};
+
+				clknand: nand {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x318>;
+					enable-reg = <0x254>;
+					enable-bit = <16>;
+				};
+
 				clki2c0: i2c0clk {
 					#clock-cells = <0>;
 					compatible = "via,vt8500-device-clock";
@@ -234,6 +261,21 @@
 			};
 		};
 
+		nand: nand@d8002000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "wm,wm8750-nand";
+			reg = <0xd8009000 0x400>;
+			clocks = <&clknand>;
+			interrupts = <28 29>;
+		};
+
+		sf@d8002000 {
+			compatible = "wm,wm8505-sf";
+			reg = <0xd8002000 0x400>;
+			clocks = <&clksf>;
+		};
+
 		pwm: pwm@d8220000 {
 			#pwm-cells = <3>;
 			compatible = "via,vt8500-pwm";
@@ -343,5 +385,12 @@
 			clocks = <&clki2c1>;
 			clock-frequency = <400000>;
 		};
+
+		eth0@d8320000 {
+			compatible = "via,velocity-vt6110";
+			reg = <0xd8004000 0x400>;
+			interrupts = <10>;
+			no-eeprom;
+		};
 	};
 };
diff -Naur linux-4.5/arch/arm/boot/dts/wm8850.dtsi wm8505_linux4.5/arch/arm/boot/dts/wm8850.dtsi
--- linux-4.5/arch/arm/boot/dts/wm8850.dtsi	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/arch/arm/boot/dts/wm8850.dtsi	2019-03-28 09:01:27.000000000 -0700
@@ -27,6 +27,10 @@
 		serial1 = &uart1;
 		serial2 = &uart2;
 		serial3 = &uart3;
+		i2c0 = &i2c_0;
+		i2c1 = &i2c_1;
+		i2c2 = &i2c_2;
+		i2c3 = &i2c_3;
 	};
 
 	soc {
@@ -53,7 +57,7 @@
 		};
 
 		pinctrl: pinctrl@d8110000 {
-			compatible = "wm,wm8850-pinctrl";
+			compatible = "wm,wm8850-pinctrl","wm,prizm-pinctrl";
 			reg = <0xd8110000 0x10000>;
 			interrupt-controller;
 			#interrupt-cells = <2>;
@@ -69,12 +73,6 @@
 				#address-cells = <1>;
 				#size-cells = <0>;
 
-				ref25: ref25M {
-					#clock-cells = <0>;
-					compatible = "fixed-clock";
-					clock-frequency = <25000000>;
-				};
-
 				ref24: ref24M {
 					#clock-cells = <0>;
 					compatible = "fixed-clock";
@@ -208,6 +206,51 @@
 					enable-reg = <0x250>;
 					enable-bit = <0>;
 				};
+
+				clksf: sf {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x314>;
+					enable-reg = <0x254>;
+					enable-bit = <23>;
+				};
+
+				clki2c0: i2c0clk {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x3A0>;
+					enable-reg = <0x250>;
+					enable-bit = <8>;
+				};
+
+				clki2c1: i2c1clk {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x3A4>;
+					enable-reg = <0x250>;
+					enable-bit = <9>;
+				};
+
+				clki2c2: i2c2clk {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x3A8>;
+					enable-reg = <0x250>;
+					enable-bit = <10>;
+				};
+
+				clki2c3: i2c3clk {
+					#clock-cells = <0>;
+					compatible = "via,vt8500-device-clock";
+					clocks = <&pllb>;
+					divisor-reg = <0x3AC>;
+					enable-reg = <0x250>;
+					enable-bit = <11>;
+				};
 			};
 		};
 
@@ -221,6 +264,12 @@
 			reg = <0xd8050400 0x100>;
 		};
 
+		sf@d8002000 {
+			compatible = "wm,wm8505-sf";
+			reg = <0xd8002000 0x400>;
+			clocks = <&clksf>;
+		};
+
 		pwm: pwm@d8220000 {
 			#pwm-cells = <3>;
 			compatible = "via,vt8500-pwm";
@@ -304,5 +353,37 @@
 			reg = <0xd8004000 0x100>;
 			interrupts = <10>;
                 };
+
+		i2c_0: i2c@d8280000 {
+			compatible = "wm,wm8505-i2c";
+			reg = <0xd8280000 0x1000>;
+			interrupts = <19>;
+			clocks = <&clki2c0>;
+			clock-frequency = <400000>;
+		};
+
+		i2c_1: i2c@d8320000 {
+			compatible = "wm,wm8505-i2c";
+			reg = <0xd8320000 0x1000>;
+			interrupts = <18>;
+			clocks = <&clki2c1>;
+			clock-frequency = <400000>;
+		};
+
+		i2c_2: i2c@d83a0000 {
+			compatible = "wm,wm8505-i2c";
+			reg = <0xd83A0000 0x1000>;
+			interrupts = <7>;
+			clocks = <&clki2c2>;
+			clock-frequency = <400000>;
+		};
+
+		i2c_3: i2c@d83b0000 {
+			compatible = "wm,wm8505-i2c";
+			reg = <0xd83B0000 0x1000>;
+			interrupts = <15>;
+			clocks = <&clki2c3>;
+			clock-frequency = <400000>;
+		};
 	};
 };
diff -Naur linux-4.5/arch/arm/boot/dts/wm8850-w70v2.dts wm8505_linux4.5/arch/arm/boot/dts/wm8850-w70v2.dts
--- linux-4.5/arch/arm/boot/dts/wm8850-w70v2.dts	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/arch/arm/boot/dts/wm8850-w70v2.dts	2019-03-28 09:01:27.000000000 -0700
@@ -23,6 +23,13 @@
 		brightness-levels = <0 40 60 80 100 130 190 255>;
 		default-brightness-level = <5>;
 	};
+
+	powerkey: pwrkey@0 {
+		compatible = "wm,power-keypad";
+		interrupt-parent = <&intc0>;
+		interrupts = <22>;
+		keymap = <116>; /* KEY_POWER */
+	};
 };
 
 &fb {
@@ -43,6 +50,21 @@
 	};
 };
 
+&uart0 {
+	status = "okay";
+};
+
+&pinctrl {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c>;
+
+	i2c: i2c {
+		wm,pins = <168 169 170 171 172 173>;
+		wm,function = <2>;	/* alt */
+		wm,pull = <2>;	/* pull-up */
+	};
+};
+
 &uart0 {
 	status = "okay";
 };
diff -Naur linux-4.5/arch/arm/mach-vt8500/vt8500.c wm8505_linux4.5/arch/arm/mach-vt8500/vt8500.c
--- linux-4.5/arch/arm/mach-vt8500/vt8500.c	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/arch/arm/mach-vt8500/vt8500.c	2019-03-28 09:01:28.000000000 -0700
@@ -32,9 +32,6 @@
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
 
-#define LEGACY_GPIO_BASE	0xD8110000
-#define LEGACY_PMC_BASE		0xD8130000
-
 /* Registers in GPIO Controller */
 #define VT8500_GPIO_MUX_REG	0x200
 
@@ -75,89 +72,61 @@
 static void __init vt8500_init(void)
 {
 	struct device_node *np;
-#if defined(CONFIG_FB_VT8500) || defined(CONFIG_FB_WM8505)
 	struct device_node *fb;
-	void __iomem *gpio_base;
-#endif
+	void __iomem *base;
 
-#ifdef CONFIG_FB_VT8500
 	fb = of_find_compatible_node(NULL, NULL, "via,vt8500-fb");
 	if (fb) {
-		np = of_find_compatible_node(NULL, NULL, "via,vt8500-gpio");
-		if (np) {
-			gpio_base = of_iomap(np, 0);
-
-			if (!gpio_base)
-				pr_err("%s: of_iomap(gpio_mux) failed\n",
-								__func__);
+		np = of_find_compatible_node(NULL, NULL, "via,vt8500-pinctrl");
+		if (!np) {
+			pr_err("pinctrl node required for framebuffer\n");
+			BUG();
+		}
 
-			of_node_put(np);
+		base = of_iomap(np, 0);
+		if (base) {
+			writel(readl(base + VT8500_GPIO_MUX_REG) | 1,
+			       base + VT8500_GPIO_MUX_REG);
+			iounmap(base);
 		} else {
-			gpio_base = ioremap(LEGACY_GPIO_BASE, 0x1000);
-			if (!gpio_base)
-				pr_err("%s: ioremap(legacy_gpio_mux) failed\n",
-								__func__);
+			pr_err("%s: of_iomap(gpio_mux) failed\n", __func__);
 		}
-		if (gpio_base) {
-			writel(readl(gpio_base + VT8500_GPIO_MUX_REG) | 1,
-				gpio_base + VT8500_GPIO_MUX_REG);
-			iounmap(gpio_base);
-		} else
-			pr_err("%s: Could not remap GPIO mux\n", __func__);
 
+		of_node_put(np);
 		of_node_put(fb);
 	}
-#endif
 
-#ifdef CONFIG_FB_WM8505
 	fb = of_find_compatible_node(NULL, NULL, "wm,wm8505-fb");
 	if (fb) {
-		np = of_find_compatible_node(NULL, NULL, "wm,wm8505-gpio");
-		if (!np)
-			np = of_find_compatible_node(NULL, NULL,
-							"wm,wm8650-gpio");
-		if (np) {
-			gpio_base = of_iomap(np, 0);
-
-			if (!gpio_base)
-				pr_err("%s: of_iomap(gpio_mux) failed\n",
-								__func__);
+		np = of_find_compatible_node(NULL, NULL, "wm,prizm-pinctrl");
+		if (!np) {
+			pr_err("pinctrl node required for framebuffer\n");
+			BUG();
+		}
 
-			of_node_put(np);
+		base = of_iomap(np, 0);
+		if (base) {
+			writel(readl(base + VT8500_GPIO_MUX_REG) |
+			       0x80000000, base + VT8500_GPIO_MUX_REG);
+			iounmap(base);
 		} else {
-			gpio_base = ioremap(LEGACY_GPIO_BASE, 0x1000);
-			if (!gpio_base)
-				pr_err("%s: ioremap(legacy_gpio_mux) failed\n",
-								__func__);
+			pr_err("%s: of_iomap(gpio_mux) failed\n", __func__);
 		}
-		if (gpio_base) {
-			writel(readl(gpio_base + VT8500_GPIO_MUX_REG) |
-				0x80000000, gpio_base + VT8500_GPIO_MUX_REG);
-			iounmap(gpio_base);
-		} else
-			pr_err("%s: Could not remap GPIO mux\n", __func__);
 
+		of_node_put(np);
 		of_node_put(fb);
 	}
-#endif
 
 	np = of_find_compatible_node(NULL, NULL, "via,vt8500-pmc");
 	if (np) {
 		pmc_base = of_iomap(np, 0);
-
-		if (!pmc_base)
-			pr_err("%s:of_iomap(pmc) failed\n", __func__);
+		if (pmc_base)
+			pm_power_off = &vt8500_power_off;
+		else
+			pr_err("%s: of_iomap(pmc) failed\n", __func__);
 
 		of_node_put(np);
-	} else {
-		pmc_base = ioremap(LEGACY_PMC_BASE, 0x1000);
-		if (!pmc_base)
-			pr_err("%s:ioremap(power_off) failed\n", __func__);
 	}
-	if (pmc_base)
-		pm_power_off = &vt8500_power_off;
-	else
-		pr_err("%s: PMC Hibernation register could not be remapped, not enabling power off!\n", __func__);
 
 	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
 }
diff -Naur linux-4.5/Documentation/devicetree/bindings/input/intel-8042.txt wm8505_linux4.5/Documentation/devicetree/bindings/input/intel-8042.txt
--- linux-4.5/Documentation/devicetree/bindings/input/intel-8042.txt	1969-12-31 17:00:00.000000000 -0700
+++ wm8505_linux4.5/Documentation/devicetree/bindings/input/intel-8042.txt	2019-03-28 09:01:26.000000000 -0700
@@ -0,0 +1,29 @@
+* Intel 8042 Keyboard controller
+
+Required properties:
+- compatible: should be "intel,8042"
+- regs: memory for keyboard controller
+- interrupts: two interrupts should be specified (keyboard and aux).
+- command-reg: offset in memory for command register
+- status-reg: offset in memory for status register
+- data-reg: offset in memory for data register
+
+Optional properties:
+- init-reset: Controller should be reset on init and cleanup
+
+Optional linux specific properties:
+- linux,kbd_phys_desc: defaults to i8042/serio0
+- linux,aux_phys_desc: defaults to i8042/serio1
+- linux,mux_phys_desc: defaults to i8042/serio%d
+
+
+Example:
+	keyboard@d8008800 {
+		compatible = "intel,8042";
+		reg = <0xD8008800 0x100>;
+		interrupts = <23 4>;
+		command-reg = <0x04>;
+		status-reg = <0x04>;
+		data-reg = <0x00>;
+		mux-ports = <2>;
+	};
diff -Naur linux-4.5/Documentation/devicetree/bindings/input/vt8500-power-keypad.txt wm8505_linux4.5/Documentation/devicetree/bindings/input/vt8500-power-keypad.txt
--- linux-4.5/Documentation/devicetree/bindings/input/vt8500-power-keypad.txt	1969-12-31 17:00:00.000000000 -0700
+++ wm8505_linux4.5/Documentation/devicetree/bindings/input/vt8500-power-keypad.txt	2019-03-28 09:01:26.000000000 -0700
@@ -0,0 +1,17 @@
+* Wondermedia Power Keypad device tree bindings
+
+Wondermedia SoCs have a single irq-driven power button attached to
+the power management controller.
+
+Required SoC Specific Properties:
+- compatible: should be one of the following
+   - "wm,power-keypad": For all Wondermedia 8xxx-series SoCs.
+- interrupts: should be the power management controller wakeup interrupt.
+- keymap: linux keycode to generate when power button pressed.
+
+Example:
+	powerkey: pwrkey@0 {
+		compatible = "wm,power-keypad";
+		interrupts = <22>;
+		keymap = <116>; /* KEY_POWER */
+	};
diff -Naur linux-4.5/drivers/input/keyboard/Kconfig wm8505_linux4.5/drivers/input/keyboard/Kconfig
--- linux-4.5/drivers/input/keyboard/Kconfig	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/input/keyboard/Kconfig	2019-03-28 09:01:45.000000000 -0700
@@ -663,6 +663,16 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called twl4030_keypad.
 
+config KEYBOARD_WMT_POWER_KEYPAD
+	tristate "Wondermedia Power keypad support"
+	depends on ARCH_VT8500
+	help
+	  Say Y here to enable support for the power button keypad
+	  on Wondermedia 8xxx-series SoCs.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called wmt_power_keypad.
+
 config KEYBOARD_XTKBD
 	tristate "XT keyboard"
 	select SERIO
diff -Naur linux-4.5/drivers/input/keyboard/Makefile wm8505_linux4.5/drivers/input/keyboard/Makefile
--- linux-4.5/drivers/input/keyboard/Makefile	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/input/keyboard/Makefile	2019-03-28 09:01:45.000000000 -0700
@@ -61,5 +61,6 @@
 obj-$(CONFIG_KEYBOARD_TC3589X)		+= tc3589x-keypad.o
 obj-$(CONFIG_KEYBOARD_TEGRA)		+= tegra-kbc.o
 obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
+obj-$(CONFIG_KEYBOARD_WMT_POWER_KEYPAD)	+= wmt_power_keypad.o
 obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
 obj-$(CONFIG_KEYBOARD_W90P910)		+= w90p910_keypad.o
diff -Naur linux-4.5/drivers/input/keyboard/wmt_power_keypad.c wm8505_linux4.5/drivers/input/keyboard/wmt_power_keypad.c
--- linux-4.5/drivers/input/keyboard/wmt_power_keypad.c	1969-12-31 17:00:00.000000000 -0700
+++ wm8505_linux4.5/drivers/input/keyboard/wmt_power_keypad.c	2019-03-28 09:01:45.000000000 -0700
@@ -0,0 +1,175 @@
+/* Wondermedia Power Keypad
+ *
+ * Copyright (C) 2012 Tony Prisk <linux@prisktech.co.nz>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/bitops.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_device.h>
+
+static void __iomem *pmc_base;
+static struct input_dev *kpad_power;
+static spinlock_t kpad_power_lock;
+static int power_button_pressed;
+static struct timer_list kpad_power_timer;
+static unsigned int kpad_power_code;
+
+static inline void kpad_power_timeout(unsigned long fcontext)
+{
+	u32 status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&kpad_power_lock, flags);
+
+	status = readl(pmc_base + 0x14);
+
+	if (power_button_pressed) {
+		input_report_key(kpad_power, kpad_power_code, 0);
+		input_sync(kpad_power);
+		power_button_pressed = 0;
+	}
+
+	spin_unlock_irqrestore(&kpad_power_lock, flags);
+}
+
+static irqreturn_t kpad_power_isr(int irq_num, void *data)
+{
+	u32 status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&kpad_power_lock, flags);
+
+	status = readl(pmc_base + 0x14);
+	udelay(100);
+	writel(status, pmc_base + 0x14);
+
+	if (status & BIT(14)) {
+		if (!power_button_pressed) {
+			input_report_key(kpad_power, kpad_power_code, 1);
+			input_sync(kpad_power);
+
+			power_button_pressed = 1;
+
+			mod_timer(&kpad_power_timer,
+				  jiffies + msecs_to_jiffies(500));
+		}
+	}
+
+	spin_unlock_irqrestore(&kpad_power_lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static int vt8500_pwr_kpad_probe(struct platform_device *pdev)
+{
+	struct device_node *np;
+	u32 status;
+	int err;
+	int irq;
+
+	np = of_find_compatible_node(NULL, NULL, "via,vt8500-pmc");
+	if (!np) {
+		dev_err(&pdev->dev, "pmc node not found\n");
+		return -EINVAL;
+	}
+
+	pmc_base = of_iomap(np, 0);
+	if (!pmc_base) {
+		dev_err(&pdev->dev, "unable to map pmc memory\n");
+		return -ENOMEM;
+	}
+
+	np = pdev->dev.of_node;
+	if (!np) {
+		dev_err(&pdev->dev, "devicenode not found\n");
+		return -ENODEV;
+	}
+
+	err = of_property_read_u32(np, "keymap", &kpad_power_code);
+	if (err) {
+		dev_warn(&pdev->dev, "defaulting to KEY_POWER\n");
+		kpad_power_code = KEY_POWER;
+	}
+
+	/* set power button to soft-power */
+	status = readl(pmc_base + 0x54);
+	writel(status | 1, pmc_base + 0x54);
+
+	/* clear any pending interrupts */
+	status = readl(pmc_base + 0x14);
+	writel(status, pmc_base + 0x14);
+
+	kpad_power = input_allocate_device();
+	if (!kpad_power) {
+		dev_err(&pdev->dev, "failed to allocate input device\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&kpad_power_lock);
+	setup_timer(&kpad_power_timer, kpad_power_timeout,
+				       (unsigned long)kpad_power);
+
+	irq = irq_of_parse_and_map(np, 0);
+	err = request_irq(irq, &kpad_power_isr, 0, "pwrbtn", NULL);
+	if (err < 0) {
+		dev_err(&pdev->dev, "failed to request irq\n");
+		return err;
+	}
+
+	kpad_power->evbit[0] = BIT_MASK(EV_KEY);
+	set_bit(kpad_power_code, kpad_power->keybit);
+
+	kpad_power->name = "wmt_power_keypad";
+	kpad_power->phys = "wmt_power_keypad";
+	kpad_power->keycode = &kpad_power_code;
+	kpad_power->keycodesize = sizeof(unsigned int);
+	kpad_power->keycodemax = 1;
+
+	err = input_register_device(kpad_power);
+	if (err < 0) {
+		dev_err(&pdev->dev, "failed to register input device\n");
+		return err;
+	}
+
+	return 0;
+}
+
+static struct of_device_id vt8500_pwr_kpad_dt_ids[] = {
+	{ .compatible = "wm,power-keypad" },
+	{ /* Sentinel */ },
+};
+
+static struct platform_driver vt8500_pwr_kpad_driver = {
+	.probe		= vt8500_pwr_kpad_probe,
+	.driver		= {
+		.name	= "wmt-power-keypad",
+		.owner	= THIS_MODULE,
+		.of_match_table = vt8500_pwr_kpad_dt_ids,
+	},
+};
+
+module_platform_driver(vt8500_pwr_kpad_driver);
+
+MODULE_DESCRIPTION("Wondermedia Power Keypad Driver");
+MODULE_AUTHOR("Tony Prisk <linux@prisktech.co.nz>");
+MODULE_LICENSE("GPL v2");
+MODULE_DEVICE_TABLE(of, vt8500_pwr_kpad_dt_ids);
diff -Naur linux-4.5/drivers/input/serio/i8042.c wm8505_linux4.5/drivers/input/serio/i8042.c
--- linux-4.5/drivers/input/serio/i8042.c	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/input/serio/i8042.c	2019-03-28 09:01:45.000000000 -0700
@@ -1547,12 +1547,18 @@
 	return 0;
 }
 
+static struct of_device_id i8042_dt_ids[] = {
+	{ .compatible = "intel,8042" },
+	{ /* Sentinel */ },
+};
+
 static struct platform_driver i8042_driver = {
 	.driver		= {
 		.name	= "i8042",
 #ifdef CONFIG_PM
 		.pm	= &i8042_pm_ops,
 #endif
+		.of_match_table = i8042_dt_ids,
 	},
 	.remove		= i8042_remove,
 	.shutdown	= i8042_shutdown,
@@ -1564,7 +1570,9 @@
 
 static int __init i8042_init(void)
 {
+#ifndef CONFIG_SERIO_I8042_DT
 	struct platform_device *pdev;
+#endif
 	int err;
 
 	dbg_init();
@@ -1577,12 +1585,17 @@
 	if (err)
 		goto err_platform_exit;
 
+#ifdef CONFIG_SERIO_I8042_DT
+	err = platform_driver_probe(&i8042_driver, i8042_probe);
+	if (err)
+		goto err_platform_exit;
+#else
 	pdev = platform_create_bundle(&i8042_driver, i8042_probe, NULL, 0, NULL, 0);
 	if (IS_ERR(pdev)) {
 		err = PTR_ERR(pdev);
 		goto err_platform_exit;
 	}
-
+#endif
 	bus_register_notifier(&serio_bus, &i8042_kbd_bind_notifier_block);
 	panic_blink = i8042_panic_blink;
 
diff -Naur linux-4.5/drivers/input/serio/i8042-dt.h wm8505_linux4.5/drivers/input/serio/i8042-dt.h
--- linux-4.5/drivers/input/serio/i8042-dt.h	1969-12-31 17:00:00.000000000 -0700
+++ wm8505_linux4.5/drivers/input/serio/i8042-dt.h	2019-03-28 09:01:45.000000000 -0700
@@ -0,0 +1,125 @@
+#ifndef _I8042_DT_H
+#define _I8042_DT_H
+
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+/*
+ * Names.
+ */
+
+static void __iomem *dt_base;
+static const char *dt_kbd_phys_desc;
+static const char *dt_aux_phys_desc;
+static const char *dt_mux_phys_desc;
+static int dt_kbd_irq;
+static int dt_aux_irq;
+static unsigned int dt_command_reg;
+static unsigned int dt_status_reg;
+static unsigned int dt_data_reg;
+
+#define I8042_KBD_PHYS_DESC	dt_kbd_phys_desc
+#define I8042_AUX_PHYS_DESC	dt_aux_phys_desc
+#define I8042_MUX_PHYS_DESC	dt_mux_phys_desc
+
+#define I8042_KBD_IRQ		(dt_kbd_irq)
+#define I8042_AUX_IRQ		(dt_aux_irq)
+
+#define I8042_COMMAND_REG	(dt_command_reg)
+#define I8042_STATUS_REG	(dt_status_reg)
+#define I8042_DATA_REG		(dt_data_reg)
+
+
+static inline int i8042_read_data(void)
+{
+	return readb(dt_base + dt_data_reg);
+}
+
+static inline int i8042_read_status(void)
+{
+	return readb(dt_base + dt_status_reg);
+}
+
+static inline void i8042_write_data(int val)
+{
+	writeb(val, dt_base + dt_data_reg);
+}
+
+static inline void i8042_write_command(int val)
+{
+	writeb(val, dt_base + dt_command_reg);
+}
+
+static inline int dt_parse_node(struct device_node *np)
+{
+	int ret;
+
+	dt_base = of_iomap(np, 0);
+	if (!dt_base)
+		return -ENOMEM;
+
+	ret = of_property_read_u32(np, "command-reg", &dt_command_reg);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_u32(np, "status-reg", &dt_status_reg);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_u32(np, "data-reg", &dt_data_reg);
+	if (ret)
+		return ret;
+
+	dt_kbd_irq = irq_of_parse_and_map(np, 0);
+	dt_aux_irq = irq_of_parse_and_map(np, 1);
+
+	ret = of_property_read_string(np, "linux,kbd_phys_desc",
+					&dt_kbd_phys_desc);
+	if (ret)
+		dt_kbd_phys_desc = "i8042/serio0";
+
+	ret = of_property_read_string(np, "linux,aux_phys_desc",
+					&dt_aux_phys_desc);
+	if (ret)
+		dt_aux_phys_desc = "i8042/serio1";
+
+	ret = of_property_read_string(np, "linux,mux_phys_desc",
+					&dt_mux_phys_desc);
+	if (ret)
+		dt_mux_phys_desc = "i8042/serio%d";
+
+	if (of_get_property(np, "init-reset", NULL))
+		i8042_reset = true;
+
+	return 0;
+}
+
+static inline int i8042_platform_init(void)
+{
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, "intel,8042");
+	if (!np) {
+		pr_err("%s: no devicetree node found\n", __func__);
+		return -ENODEV;
+	}
+
+	dt_parse_node(np);
+
+	return 0;
+}
+
+static inline void i8042_platform_exit(void)
+{
+	if (dt_base)
+		iounmap(dt_base);
+}
+
+#endif
diff -Naur linux-4.5/drivers/input/serio/i8042.h wm8505_linux4.5/drivers/input/serio/i8042.h
--- linux-4.5/drivers/input/serio/i8042.h	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/input/serio/i8042.h	2019-03-28 09:01:45.000000000 -0700
@@ -14,7 +14,9 @@
  * Arch-dependent inline functions and defines.
  */
 
-#if defined(CONFIG_MACH_JAZZ)
+#if defined(CONFIG_SERIO_I8042_DT)
+#include "i8042-dt.h"
+#elif defined(CONFIG_MACH_JAZZ)
 #include "i8042-jazzio.h"
 #elif defined(CONFIG_SGI_HAS_I8042)
 #include "i8042-ip22io.h"
diff -Naur linux-4.5/drivers/input/serio/Kconfig wm8505_linux4.5/drivers/input/serio/Kconfig
--- linux-4.5/drivers/input/serio/Kconfig	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/input/serio/Kconfig	2019-03-28 09:01:45.000000000 -0700
@@ -39,6 +39,12 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called i8042.
 
+config SERIO_I8042_DT
+	tristate "i8042 Keyboard controller DT support" if EXPERT || !X86
+	depends on USE_OF
+	select ARCH_MIGHT_HAVE_PC_SERIO
+	select SERIO_I8042
+
 config SERIO_SERPORT
 	tristate "Serial port line discipline"
 	default y
diff -Naur linux-4.5/drivers/mtd/devices/Kconfig wm8505_linux4.5/drivers/mtd/devices/Kconfig
--- linux-4.5/drivers/mtd/devices/Kconfig	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/mtd/devices/Kconfig	2019-03-28 09:01:50.000000000 -0700
@@ -120,6 +120,25 @@
 	  registered by bcma as platform devices. This enables driver for
 	  serial flash memories (only read-only mode is implemented).
 
+config MTD_WMT_SFLASH
+	tristate "WonderMedia Serial Flash Support"
+	depends on MTD
+	help
+	  Enable this option to provide support for the Wondermedia SoC serial
+	  flash controller.
+
+config MTD_WMT_SFLASH_READONLY
+	bool "Disable write support for Wondermedia Serial Flash"
+	depends on MTD_WMT_SFLASH
+	default y
+	help
+	  Select this option to disable write support for Wondermedia SoC
+	  serial flash controller. The option is enabled by default when
+	  selecting Wondermedia Serial Flash Support.
+
+	  WARNING: Incorrectly writing to serial flash may result in an
+	  inability to boot your system.
+
 config MTD_SLRAM
 	tristate "Uncached system RAM"
 	help
diff -Naur linux-4.5/drivers/mtd/devices/Makefile wm8505_linux4.5/drivers/mtd/devices/Makefile
--- linux-4.5/drivers/mtd/devices/Makefile	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/mtd/devices/Makefile	2019-03-28 09:01:50.000000000 -0700
@@ -17,6 +17,7 @@
 obj-$(CONFIG_MTD_BCM47XXSFLASH)	+= bcm47xxsflash.o
 obj-$(CONFIG_MTD_ST_SPI_FSM)    += st_spi_fsm.o
 obj-$(CONFIG_MTD_POWERNV_FLASH)	+= powernv_flash.o
+obj-$(CONFIG_MTD_WMT_SFLASH)	+= wmt_sflash.o
 
 
 CFLAGS_docg3.o			+= -I$(src)
diff -Naur linux-4.5/drivers/mtd/devices/wmt_sflash.c wm8505_linux4.5/drivers/mtd/devices/wmt_sflash.c
--- linux-4.5/drivers/mtd/devices/wmt_sflash.c	1969-12-31 17:00:00.000000000 -0700
+++ wm8505_linux4.5/drivers/mtd/devices/wmt_sflash.c	2019-03-28 09:01:50.000000000 -0700
@@ -0,0 +1,606 @@
+/*
+ * Copyright (C) 2012 Tony Prisk <linux@prisktech.co.nz>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+
+#include <linux/mtd/mtd.h>
+
+/* controller only supports erase size of 64KB */
+#define WMT_ERASESIZE			0x10000
+
+/* Serial Flash controller register offsets */
+#define SF_CHIP_SEL_0_CFG		0x000
+#define SF_CHIP_SEL_1_CFG		0x008
+#define SF_SPI_INTF_CFG			0x040
+#define SF_SPI_RD_WR_CTR		0x050
+#define SF_SPI_WR_EN_CTR		0x060
+#define SF_SPI_ER_CTR			0x070
+#define SF_SPI_ER_START_ADDR		0x074
+#define SF_SPI_ERROR_STATUS		0x080
+#define SF_SPI_MEM_0_SR_ACC		0x100
+#define SF_SPI_MEM_1_SR_ACC		0x110
+#define SF_SPI_PDWN_CTR_0		0x180
+#define SF_SPI_PDWN_CTR_1		0x190
+#define SF_SPI_PROG_CMD_CTR		0x200
+#define SF_SPI_USER_CMD_VAL		0x210
+#define SF_SPI_PROG_CMD_WBF		0x300	/* 64 bytes */
+#define SF_SPI_PROG_CMD_RBF		0x380	/* 64 bytes */
+
+/* SF_SPI_WR_EN_CTR bit fields */
+#define SF_CS0_WR_EN			BIT(0)
+#define SF_CS1_WR_EN			BIT(1)
+
+/* SF_SPI_ER_CTR bit fields */
+#define SF_SEC_ER_EN			BIT(31)
+
+/* SF_SPI_ERROR_STATUS bit fields */
+#define SF_ERR_TIMEOUT			BIT(31)
+#define SF_ERR_WR_PROT			BIT(5)
+#define SF_ERR_MEM_REGION		BIT(4)
+#define SF_ERR_PWR_DWN_ACC		BIT(3)
+#define SF_ERR_PCMD_OP			BIT(2)
+#define SF_ERR_PCMD_ACC			BIT(1)
+#define SF_ERR_MASLOCK			BIT(0)
+
+/*
+ * Serial Flash device manufacturers
+ * Please keep sorted by manufacturers ID
+ */
+#define MFR_SPANSION		0x01
+#define MFR_EON			0x1C
+#define MFR_ATMEL		0x1F
+#define MFR_NUMONYX		0x20
+#define MFR_FUDAN		0xA1
+#define MFR_SST			0xBF
+#define MFR_MXIC		0xC2
+#define MFR_WINBOND		0xEF
+
+/*
+ * SF Device Models
+ * Please keep in the same order as the manufacturers table
+ */
+
+/* Spansion */
+#define SPAN_FL016A		0x0214 /* 2 MB */
+#define SPAN_FL064A		0x0216 /* 8 MB */
+
+/* Eon */
+#define EON_25P16		0x2015 /* 2 MB */
+#define EON_25P64		0x2017 /* 8 MB */
+#define EON_25F40		0x3113 /* 512 KB */
+#define EON_25F16		0x3115 /* 2 MB */
+
+/* Atmel */
+#define AT_25DF041A		0x4401 /* 512KB */
+
+/* Numonyx */
+#define	NX_25P16		0x2015 /* 2 MB */
+#define	NX_25P64		0x2017 /* 8 MB */
+
+/* Fudan Microelectronics Group */
+#define FM_25F04		0x3113 /* 512 KB */
+
+/* SST */
+#define SST_VF016B		0x2541 /* 2 MB */
+
+/* MXIC */
+#define	MX_L512			0x2010 /* 64 KB , 4KB*/
+#define MX_L4005A		0x2013 /* 512 KB */
+#define	MX_L1605D		0x2015 /* 2 MB */
+#define	MX_L3205D		0x2016 /* 4 MB */
+#define	MX_L6405D		0x2017 /* 8 MB */
+#define	MX_L1635D		0x2415 /* 2 MB */
+#define	MX_L3235D		0x5E16 /* 4 MB */
+#define	MX_L12805D		0x2018 /* 16 MB */
+
+/* WinBond */
+#define WB_W25X40BV		0x3013	/* 512 KB */
+#define WB_X16A			0x3015	/* 2 MB */
+#define WB_X32			0x3016	/* 4 MB */
+#define WB_X64			0x3017	/* 8 MB */
+
+
+#define SF_ID(mfr, mdl)		((mfr << 16) | mdl)
+
+#define FLASH_UNKNOWN		0x00ffffff
+
+struct wmt_flash_id {
+	u32	id;
+	u32	size;		/* Size in KB */
+};
+
+static struct wmt_flash_id flash_ids[] = {
+	{ SF_ID(MFR_SPANSION,	SPAN_FL016A),	2048 },
+	{ SF_ID(MFR_SPANSION,	SPAN_FL064A),	8192 },
+	{ SF_ID(MFR_EON,	EON_25P16),	2048 },
+	{ SF_ID(MFR_EON,	EON_25P64),	8192 },
+	{ SF_ID(MFR_EON,	EON_25F40),	512 },
+	{ SF_ID(MFR_EON,	EON_25F16),	2048 },
+	{ SF_ID(MFR_ATMEL,	AT_25DF041A),	512 },
+	{ SF_ID(MFR_NUMONYX,	NX_25P16),	2048 },
+	{ SF_ID(MFR_NUMONYX,	NX_25P64),	8192 },
+	{ SF_ID(MFR_FUDAN,	FM_25F04),	512 },
+	{ SF_ID(MFR_SST,	SST_VF016B),	2048 },
+	{ SF_ID(MFR_MXIC,	MX_L512),	64 },
+	{ SF_ID(MFR_MXIC,	MX_L4005A),	512 },
+	{ SF_ID(MFR_MXIC,	MX_L1605D),	2048 },
+	{ SF_ID(MFR_MXIC,	MX_L3205D),	4192 },
+	{ SF_ID(MFR_MXIC,	MX_L6405D),	8192 },
+	{ SF_ID(MFR_MXIC,	MX_L1635D),	2048 },
+	{ SF_ID(MFR_MXIC,	MX_L3235D),	4192 },
+	{ SF_ID(MFR_MXIC,	MX_L12805D),	16384 },
+	{ SF_ID(MFR_WINBOND,	WB_W25X40BV),	512 },
+	{ SF_ID(MFR_WINBOND,	WB_X16A),	2048 },
+	{ SF_ID(MFR_WINBOND,	WB_X32),	4096 },
+	{ SF_ID(MFR_WINBOND,	WB_X64),	8192 },
+	{ 0, 0 },
+};
+
+struct wmt_sf_chip {
+	u32	id;
+	u32	size;
+	u32	addr_phys;
+	u32	ccr;
+};
+
+struct wmt_sf_data {
+	struct mtd_info		*sf_mtd;
+	struct clk		*sf_clk;
+	struct device		*dev;
+
+	struct wmt_sf_chip	chip[2];
+
+	void __iomem		*base;		/* register virt base */
+
+	void __iomem		*sf_base_virt;	/* mem-mapped sf virt base */
+	u32			sf_base_phys;	/* mem-mapped sf phys base */
+	u32			sf_total_size;
+};
+
+static u32 sf_get_chip_size(struct device *dev, u32 id)
+{
+	int i;
+	for (i = 0; flash_ids[i].id != 0; i++)
+		if (flash_ids[i].id == id)
+			return flash_ids[i].size * 1024;
+
+	dev_err(dev, "Unknown flash id (%08x)\n", id);
+	return 0;
+}
+
+static void sf_calc_ccr(struct wmt_sf_chip *chip)
+{
+	unsigned int cnt = 0, size;
+
+	size = chip->size;
+	while (size) {
+		size >>= 1;
+		cnt++;
+	}
+	cnt -= 16;
+	cnt = cnt << 8;
+	chip->ccr = (chip->addr_phys | cnt);
+}
+
+static int wmt_sf_init_hw(struct wmt_sf_data *info)
+{
+	u32 phys_addr;
+
+	phys_addr = 0xFFFFFFFF;
+	writel(0x00000011, info->base + SF_SPI_RD_WR_CTR);
+	writel(0xFF800800, info->base + SF_CHIP_SEL_0_CFG);
+	writel(0x00030000, info->base + SF_SPI_INTF_CFG);
+
+	info->chip[0].id = FLASH_UNKNOWN;
+	info->chip[1].id = FLASH_UNKNOWN;
+
+	/* Read serial flash ID */
+	writel(0x11, info->base + SF_SPI_RD_WR_CTR);
+	info->chip[0].id = readl(info->base + SF_SPI_MEM_0_SR_ACC);
+	writel(0x01, info->base + SF_SPI_RD_WR_CTR);
+
+	writel(0x11, info->base + SF_SPI_RD_WR_CTR);
+	info->chip[1].id = readl(info->base + SF_SPI_MEM_1_SR_ACC);
+	writel(0x01, info->base + SF_SPI_RD_WR_CTR);
+
+	info->chip[0].size = sf_get_chip_size(info->dev, info->chip[0].id);
+	if (info->chip[0].size == 0)
+		return -1;
+
+	info->chip[0].addr_phys = phys_addr - info->chip[0].size + 1;
+	if (info->chip[0].addr_phys & 0xffff) {
+		dev_err(info->dev, "Chip 0 start address must align to 64KB\n");
+		return -1;
+	}
+	info->sf_base_phys = info->chip[0].addr_phys;
+	info->sf_total_size = info->chip[0].size;
+	pr_info("SFC: Chip 0 @ %08x (size: %d)\n", info->chip[0].addr_phys,
+							info->chip[0].size);
+
+	sf_calc_ccr(&info->chip[0]);
+	writel(info->chip[0].ccr, info->base + SF_CHIP_SEL_0_CFG);
+
+	if (info->chip[1].id != FLASH_UNKNOWN) {
+		info->chip[1].size = sf_get_chip_size(info->dev,
+						      info->chip[1].id);
+		info->chip[1].addr_phys = info->chip[0].addr_phys -
+							info->chip[1].size;
+		if (info->chip[1].addr_phys & 0xffff) {
+			dev_err(info->dev, "Chip 1 start address must align to 64KB\n");
+			info->chip[1].id = FLASH_UNKNOWN;
+			return 0;
+		}
+		info->sf_base_phys = info->chip[1].addr_phys;
+		info->sf_total_size += info->chip[1].size;
+		pr_info("SFC: Chip 1 @ %08x (size: %d)\n",
+				info->chip[1].addr_phys, info->chip[1].size);
+
+		sf_calc_ccr(&info->chip[1]);
+		writel(info->chip[1].ccr, info->base + SF_CHIP_SEL_1_CFG);
+	}
+
+	return 0;
+}
+
+static int sf_check_error(struct device *dev, u32 code)
+{
+	if (code & SF_ERR_TIMEOUT) {
+		dev_err(dev, "Serial flash timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	if (code & SF_ERR_WR_PROT) {
+		dev_err(dev, "Serial flash write-protected\n");
+		return -EIO;
+	}
+
+	if (code & SF_ERR_MEM_REGION) {
+		dev_err(dev, "Serial flash memory region error\n");
+		return -EIO;
+	}
+
+	if (code & SF_ERR_PWR_DWN_ACC) {
+		dev_err(dev, "Serial flash power down access error\n");
+		return -EIO;
+	}
+
+	if (code & SF_ERR_PCMD_OP)	{
+		dev_err(dev, "Serial flash program CMD OP error\n");
+		return -EIO;
+	}
+
+	if (code & SF_ERR_PCMD_ACC) {
+		dev_err(dev, "Serial flash program CMD OP access error\n");
+		return -EIO;
+	}
+
+	if (code & SF_ERR_MASLOCK) {
+		dev_err(dev, "Serial flash master lock error\n");
+		return -EIO;
+	}
+
+	/* no error */
+	return 0;
+}
+
+static int sf_spi_read_status(struct wmt_sf_data *info, int chip)
+{
+	u32 timeout = 0x30000000;
+	u32 temp;
+	int err;
+
+	do {
+		if (chip == 0)
+			temp = readl_relaxed(info->base + SF_SPI_MEM_0_SR_ACC);
+		else
+			temp = readl_relaxed(info->base + SF_SPI_MEM_1_SR_ACC);
+
+		if ((temp & 0x1) == 0x0)
+			break;
+
+		err = sf_check_error(info->dev,
+				     readl(info->base + SF_SPI_ERROR_STATUS));
+		if (err) {
+			writel(0x3f, info->base + SF_SPI_ERROR_STATUS);
+			return err;
+		}
+		timeout--;
+	} while (timeout);
+
+	if (timeout == 0) {
+		dev_err(info->dev, "spi request timed-out\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_MTD_WMT_SFLASH_READONLY
+static int sf_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	return -EINVAL;
+}
+
+static int sf_write(struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf)
+{
+	*retlen = 0;
+	return -EINVAL;
+}
+#else
+static int sf_sector_erase(struct wmt_sf_data *info, u32 addr)
+{
+	int chip;
+	u32 val;
+
+	if ((info->sf_base_phys + addr) < info->chip[0].addr_phys) {
+		chip = 0;
+		writel(SF_CS0_WR_EN, info->base + SF_SPI_WR_EN_CTR);
+	} else {
+		chip = 1;
+		writel(SF_CS1_WR_EN, info->base + SF_SPI_WR_EN_CTR);
+	}
+
+	addr &= ~(info->sf_mtd->erasesize - 1);
+	writel(addr, info->base + SF_SPI_ER_START_ADDR);
+
+	writel(SF_SEC_ER_EN, info->base + SF_SPI_ER_CTR);
+
+	val = sf_spi_read_status(info, chip);
+
+	writel(0, info->base + SF_SPI_WR_EN_CTR);
+	return val;
+}
+
+static int sf_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct wmt_sf_data *info = mtd->priv;
+	int ret;
+
+	ret = clk_enable(info->sf_clk);
+	if (ret)
+		return ret;
+
+	ret = sf_sector_erase(info, (u32)instr->addr);
+	if (ret) {
+		clk_disable(info->sf_clk);
+		return ret;
+	}
+
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+
+	clk_disable(info->sf_clk);
+	return 0;
+}
+
+static int sf_sector_write(struct wmt_sf_data *info, loff_t to, size_t len,
+			   const u_char *buf)
+{
+	int ret;
+	int data_size;
+	u32 count;
+	u32 addr_to = (u32)(info->sf_base_virt) + to;
+
+	ret = clk_enable(info->sf_clk);
+	if (ret)
+		return ret;
+
+	if (sf_spi_read_status(info, 0))
+		return -EBUSY;
+	if (sf_spi_read_status(info, 1))
+		return -EBUSY;
+
+	writel(SF_CS0_WR_EN | SF_CS1_WR_EN, info->base + SF_SPI_WR_EN_CTR);
+
+	count = 0;
+	while (len) {
+		data_size = (len >= 4) ? 4 : 1;
+		memcpy_toio(((u_char *)(addr_to + count)), buf + count,
+								data_size);
+		count += data_size;
+		len -= data_size;
+
+		if (len) {
+			data_size = (len >= 4) ? 4 : 1;
+			memcpy_toio(((u_char *)(addr_to + count)), buf + count,
+								data_size);
+			count += data_size;
+			len -= data_size;
+		}
+
+		ret = sf_spi_read_status(info, 0);
+		if (ret) {
+			clk_disable(info->sf_clk);
+			return ret;
+		}
+	}
+
+	writel(0, info->base + SF_SPI_WR_EN_CTR);
+
+	clk_disable(info->sf_clk);
+
+	return count;
+}
+
+static int sf_write(struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf)
+{
+	struct wmt_sf_data *info = mtd->priv;
+
+	*retlen = sf_sector_write(info, to, len, buf);
+
+	return 0;
+}
+#endif
+
+static int sf_read(struct mtd_info *mtd, loff_t from, size_t len,
+			 size_t *retlen, u_char *buf)
+{
+	int ret;
+	struct wmt_sf_data *info = mtd->priv;
+
+	ret = clk_enable(info->sf_clk);
+	if (ret)
+		return ret;
+
+	if (sf_spi_read_status(info, 0))
+		return -EBUSY;
+	if (sf_spi_read_status(info, 1))
+		return -EBUSY;
+
+	if (from + len > mtd->size) {
+		dev_err(info->dev, "Request out of bounds (from=%llu, len=%d)\n",
+								from, len);
+		return -EINVAL;
+	}
+
+	memcpy_fromio(buf, info->sf_base_virt + from, len);
+	*retlen = len;
+
+	clk_disable(info->sf_clk);
+	return 0;
+}
+
+static int mtdsf_init_device(struct device *dev, struct mtd_info *mtd,
+					unsigned long size, char *name)
+{
+	mtd->name = name;
+	mtd->type = MTD_NORFLASH;
+	mtd->flags = MTD_CAP_NORFLASH;
+	mtd->size = size;
+	mtd->erasesize = WMT_ERASESIZE;
+	mtd->owner = THIS_MODULE;
+	mtd->_erase = sf_erase;
+	mtd->_read = sf_read;
+	mtd->_write = sf_write;
+	mtd->writesize = 1;
+
+	if (mtd_device_register(mtd, NULL, 0)) {
+		dev_err(dev, "Erroring adding MTD device\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int wmt_sf_probe(struct platform_device *pdev)
+{
+	struct wmt_sf_data	*info;
+	struct device_node	*np = pdev->dev.of_node;
+	int err;
+
+	if (!np) {
+		dev_err(&pdev->dev, "Invalid devicetree node\n");
+		return -EINVAL;
+	}
+
+	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		dev_err(&pdev->dev, "Failed to get memory for SF info\n");
+		return -ENOMEM;
+	}
+
+	info->dev = &pdev->dev;
+
+	info->base = of_iomap(np, 0);
+	if (!info->base) {
+		dev_err(&pdev->dev, "Failed to map register memory\n");
+		return -ENOMEM;
+	}
+
+	info->sf_clk = of_clk_get(np, 0);
+	if (!info->sf_clk) {
+		dev_err(&pdev->dev, "Failed to get clock from device tree\n");
+		return -EINVAL;
+	}
+
+	err = clk_prepare_enable(info->sf_clk);
+	if (err)
+		return err;
+
+	err = wmt_sf_init_hw(info);
+
+	clk_disable(info->sf_clk);
+
+	if (err) {
+		dev_err(&pdev->dev, "Failed to initialize SF hardware\n");
+		return -EIO;
+	}
+
+	info->sf_base_virt = devm_ioremap(&pdev->dev, info->sf_base_phys,
+					  info->sf_total_size);
+	if (!info->sf_base_virt) {
+		dev_err(&pdev->dev, "Failed to map serial flash memory\n");
+		return -ENOMEM;
+	}
+
+	info->sf_mtd = devm_kzalloc(&pdev->dev, sizeof(struct mtd_info),
+								GFP_KERNEL);
+	if (!info->sf_mtd) {
+		dev_err(&pdev->dev, "Failed to allocate SFMTD memory\n");
+		return -ENOMEM;
+	}
+
+	err = mtdsf_init_device(info->dev, info->sf_mtd, info->sf_total_size,
+						"Wondermedia SF Device");
+	if (err)
+		return err;
+
+	info->sf_mtd->priv = info;
+	dev_set_drvdata(&pdev->dev, info);
+
+	pr_info("Wondermedia Serial Flash Controller initialized\n");
+
+	return 0;
+}
+
+static int wmt_sf_remove(struct platform_device *pdev)
+{
+	struct wmt_sf_data *info = dev_get_drvdata(&pdev->dev);
+
+	mtd_device_unregister(info->sf_mtd);
+
+	return 0;
+}
+
+static const struct of_device_id wmt_dt_ids[] = {
+	{ .compatible = "wm,wm8505-sf", },
+	{}
+};
+
+static struct platform_driver wmt_sf_driver = {
+	.probe		= wmt_sf_probe,
+	.remove		= wmt_sf_remove,
+	.driver		= {
+		.name	= "wmt-sf",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(wmt_dt_ids),
+	},
+};
+
+module_platform_driver(wmt_sf_driver);
+
+MODULE_AUTHOR("Tony Prisk <linux@prisktech.co.nz>");
+MODULE_DESCRIPTION("Wondermedia SoC Serial Flash driver");
+MODULE_LICENSE("GPL v2");
+
diff -Naur linux-4.5/drivers/mtd/nand/Kconfig wm8505_linux4.5/drivers/mtd/nand/Kconfig
--- linux-4.5/drivers/mtd/nand/Kconfig	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/mtd/nand/Kconfig	2019-03-28 09:01:50.000000000 -0700
@@ -533,6 +533,15 @@
 	  Enables support for NAND Flash chips on the ST Microelectronics
 	  Flexible Static Memory Controller (FSMC)
 
+config MTD_NAND_WMT
+	tristate "Support for NAND on WonderMedia SoCs"
+	depends on ARCH_VT8500
+	help
+	  Enables support for the NAND Flash controller on WonderMedia
+	  WM8xxx-series SoCs.
+
+	  If this drivers is compiled as a module, it will be named wmt_nand.
+
 config MTD_NAND_XWAY
 	tristate "Support for NAND on Lantiq XWAY SoC"
 	depends on LANTIQ && SOC_TYPE_XWAY
diff -Naur linux-4.5/drivers/mtd/nand/Makefile wm8505_linux4.5/drivers/mtd/nand/Makefile
--- linux-4.5/drivers/mtd/nand/Makefile	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/mtd/nand/Makefile	2019-03-28 09:01:50.000000000 -0700
@@ -51,6 +51,7 @@
 obj-$(CONFIG_MTD_NAND_JZ4740)		+= jz4740_nand.o
 obj-$(CONFIG_MTD_NAND_JZ4780)		+= jz4780_nand.o jz4780_bch.o
 obj-$(CONFIG_MTD_NAND_GPMI_NAND)	+= gpmi-nand/
+obj-$(CONFIG_MTD_NAND_WMT)		+= wmt_nand.o
 obj-$(CONFIG_MTD_NAND_XWAY)		+= xway_nand.o
 obj-$(CONFIG_MTD_NAND_BCM47XXNFLASH)	+= bcm47xxnflash/
 obj-$(CONFIG_MTD_NAND_SUNXI)		+= sunxi_nand.o
diff -Naur linux-4.5/drivers/mtd/nand/wmt_nand.c wm8505_linux4.5/drivers/mtd/nand/wmt_nand.c
--- linux-4.5/drivers/mtd/nand/wmt_nand.c	1969-12-31 17:00:00.000000000 -0700
+++ wm8505_linux4.5/drivers/mtd/nand/wmt_nand.c	2019-03-28 09:01:50.000000000 -0700
@@ -0,0 +1,1146 @@
+/*
+ * WonderMedia WM8xxx-series SoC NAND Flash driver
+ *
+ * Copyright (C) 2013 Tony Prisk <linux@prisktech.co.nz>
+ *
+ * Based on GPLv2 source:
+ * Copyright (C) 2011 Darek Marcinkiewicz <reksio@newterm.pl>
+ * Copyright (C) 2010 Alexey Charkov <alchark@gmail.com>
+ * Copyright (C) 2008 WonderMedia Technologies, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_mtd.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+
+#define DRIVER_NAME	"wmt-nand"
+
+#define DMA_BUFFER_SIZE			16384
+#define NAND_DIR_READ			0x00
+#define NAND_DIR_WRITE			0x01
+
+#define REG_DATAPORT			0x00
+#define REG_COMCTRL			0x04
+#define REG_COMPORT0			0x08
+#define REG_COMPORT1_2			0x0C
+#define REG_COMPORT3_4			0x10
+#define REG_COMPORT5_6			0x14
+#define REG_COMPORT7			0x18
+#define REG_COMPORT8_9			0x1C
+#define REG_DMA_COUNTER			0x20
+#define REG_SMC_ENABLE			0x24
+#define REG_MISC_STAT_PORT		0x28
+#define REG_HOST_STAT_CHANGE		0x2C
+#define REG_SMC_DMA_COUNTER		0x30
+#define REG_CALC_CTRL			0x34
+#define REG_CALC_NUM			0x38
+#define REG_CALC_NUM_QU			0x3C
+#define REG_REMAINDER			0x40
+#define REG_CHIP_ENABLE_CTRL		0x44
+#define REG_NAND_TYPE_SEL		0x48
+#define REG_REDUNT_ECC_STAT_MASK	0x4C
+#define REG_READ_CYCLE_PULE_CTRL	0x50
+#define REG_MISC_CTRL			0x54
+#define REG_DUMMY_CTRL			0x58
+#define REG_PAGESIZE_DIVIDER_SEL	0x5C
+#define REG_RW_STROBE_TUNE		0x60
+#define REG_BANK18_ECC_STAT_MASK	0x64
+#define REG_ODD_BANK_PARITY_STAT	0x68
+#define REG_EVEN_BANK_PARITY_STAT	0x6C
+#define REG_REDUNT_AREA_PARITY_STAT	0x70
+#define REG_IDLE_STAT			0x74
+#define REG_PHYS_ADDR			0x78
+#define REG_REDUNT_ECC_STAT		0x7C
+#define REG_BANK18_ECC_STAT		0x80
+#define REG_TIMER_COUNTER_CONFIG	0x84
+#define REG_NANDFLASH_BOOT		0x88
+#define REG_ECC_BCH_CTRL		0x8C
+#define REG_ECC_BCH_INT_MASK		0x90
+#define REG_ECC_BCH_INT_STAT1		0x94
+#define REG_ECC_BCH_INT_STAT2		0x98
+#define REG_ECC_BCH_ERR_POS1		0x9C
+#define REG_ECC_BCH_ERR_POS2		0xA0
+#define REG_ECC_BCH_ERR_POS3		0xA4
+#define REG_ECC_BCH_ERR_POS4		0xA8
+#define REG_ECC_BCH_ERR_POS5		0xAC
+#define REG_ECC_BCH_ERR_POS6		0xB0
+#define REG_ECC_BCH_ERR_POS7		0xB4
+#define REG_ECC_BCH_ERR_POS8		0xB8
+
+#define REG_NFC_DMA_GCR			0x100
+#define REG_NFC_DMA_IER			0x104
+#define REG_NFC_DMA_ISR			0x108
+#define REG_NFC_DMA_DESPR		0x10C
+#define REG_NFC_DMA_RBR			0x110
+#define REG_NFC_DMA_DAR			0x114
+#define REG_NFC_DMA_BAR			0x118
+#define REG_NFC_DMA_CPR			0x11C
+#define REG_NFC_DMA_CCR			0x120
+
+#define REG_ECC_FIFO_0			0x1C0
+#define REG_ECC_FIFO_1			0x1C4
+#define REG_ECC_FIFO_2			0x1C8
+#define REG_ECC_FIFO_3			0x1CC
+#define REG_ECC_FIFO_4			0x1D0
+#define REG_ECC_FIFO_5			0x1D4
+#define REG_ECC_FIFO_6			0x1D8
+#define REG_ECC_FIFO_7			0x1DC
+#define REG_ECC_FIFO_8			0x1E0
+#define REG_ECC_FIFO_9			0x1E4
+#define REG_ECC_FIFO_A			0x1E8
+#define REG_ECC_FIFO_B			0x1EC
+#define REG_ECC_FIFO_C			0x1F0
+#define REG_ECC_FIFO_D			0x1F4
+#define REG_ECC_FIFO_E			0x1F8
+#define REG_ECC_FIFO_F			0x1FC
+
+/* 0x04 */
+#define COMCTRL_TRIGGER_CMD		BIT(0)
+#define COMCTRL_MULT_COMMANDS		BIT(4)
+#define COMCTRL_CYCLES_DMA		0
+#define COMCTRL_CYCLES_NONE		0
+#define COMCTRL_CYCLES_SINGLE		BIT(5)
+#define COMCTRL_NFC_2_NAND		0
+#define COMCTRL_NAND_2_NFC		BIT(6)
+#define COMCTRL_HAS_DATA		0
+#define COMCTRL_NO_DATA			BIT(7)
+#define COMCTRL_OLD_CMD			BIT(10)
+
+/* 0x28 */
+#define MSP_READY			BIT(0)
+#define MSP_TRANSFER_ACTIVE		BIT(1)
+#define MSP_CMD_READY			BIT(2)
+
+/* 0x2C */
+#define HSC_B2R				BIT(3)
+
+/* 0x48 */
+#define TYPESEL_PAGE_512		0
+#define TYPESEL_PAGE_2K			1
+#define TYPESEL_PAGE_4K			2
+#define TYPESEL_PAGE_8K			3
+#define TYPESEL_OLDDATA_EN		BIT(2)
+#define TYPESEL_WIDTH_8			0
+#define TYPESEL_WIDTH_16		BIT(3)
+#define TYPESEL_WP_DIS			BIT(4)
+#define TYPESEL_DIRECT_MAP		BIT(5)
+#define TYPESEL_CHECK_ALLFF		BIT(6)
+
+/* 0x4C */
+#define RESM_MASKABLE_INT_DIS		BIT(6)
+#define RESM_B2R_DIS			BIT(3)
+#define RESM_UNCORRECTABLE_ERR_INT_DIS	BIT(2)
+#define RESM_1BIT_ERR_INT_DIS		BIT(1)
+#define RESM_REDUNTANT_ERR_INT_DIS	BIT(0)
+
+#define RESM_MASK			(RESM_MASKABLE_INT_DIS | \
+					RESM_UNCORRECTABLE_ERR_INT_DIS | \
+					RESM_REDUNTANT_ERR_INT_DIS)
+
+/* 0x50 */
+#define PULE_DIVISOR_MASK		0xffff0000;
+
+/* 0x54 */
+#define MISCCTRL_SOFTWARE_ECC		BIT(2)
+
+/* 0x5C */
+#define PAGE_BLOCK_DIVISOR_MASK		0xE0
+#define PAGE_BLOCK_DIVISOR(x)		((x) << 5)
+
+/* 0x8C */
+#define EBC_ECC_TYPE_MASK		0xFFFFFFF0
+#define EBC_ECC_1BIT			0
+#define EBC_ECC_4BIT			1
+#define EBC_ECC_8BIT			2
+#define EBC_ECC_12BIT			3
+#define EBC_ECC_16BIT			4
+#define EBC_ECC_24BITPER1K		5
+#define EBC_ECC_40BITPER1K		6
+#define EBC_ECC_44BITPER1K		7
+#define EBC_ECC_44BIT			8
+#define EBC_READ_RESUME			BIT(8)
+
+/* 0x90 */
+#define EBIM_INT_EN			(BIT(8) | BIT(0))
+
+/* 0x94 */
+#define EBIS1_ERROR			BIT(0)
+#define EBIS1_CORRECTION_DONE		BIT(8)
+
+/* 0x98 */
+#define EBIS2_ERROR_OOB			BIT(11)
+
+/* 0x100 */
+#define DMA_GCR_DMA_EN			BIT(0)
+#define DMA_GCR_SOFTRESET		BIT(8)
+
+/* 0x108 */
+#define DMA_IER_INT_STS			BIT(0)
+
+/* 0x120 */
+#define DMA_CCR_EVTCODE			0x0f
+#define DMA_CCR_EVT_NO_STATUS		0x00
+#define DMA_CCR_EVT_FF_UNDERRUN		0x01
+#define DMA_CCR_EVT_FF_OVERRUN		0x02
+#define DMA_CCR_EVT_DESP_READ		0x03
+#define DMA_CCR_EVT_DATA_RW		0x04
+#define DMA_CCR_EVT_EARLY_END		0x05
+#define DMA_CCR_EVT_SUCCESS		0x0f
+
+#define DMA_CCR_RUN			BIT(7)
+#define DMA_CCR_IF_TO_PERIPHERAL	0
+#define DMA_CCR_PERIPHERAL_TO_IF	BIT(22)
+
+static struct nand_ecclayout vt8500_oobinfo = {
+	.eccbytes = 7,
+	.eccpos = {24, 25, 26, 27, 28, 29, 30},
+	.oobavail = 24,
+	.oobfree = { {0, 24} }
+};
+
+struct nand_dma_desc {
+	u32 req_count:16;
+	u32 i:1;
+	u32 r1:13;
+	u32 format:1;
+	u32 end:1;
+	u32 addr:32;
+	u32 branch_addr:32;
+	u32 r2:32;
+};
+
+struct nand_priv {
+	struct mtd_info mtd;
+	struct nand_chip nand;
+
+	struct device *dev;
+	void __iomem *reg_base;
+	struct clk *clk;
+
+	dma_addr_t dmaaddr;
+	unsigned char *dmabuf;
+
+	dma_addr_t dma_d_addr;
+	struct nand_dma_desc *dma_desc;
+
+	int dataptr;
+
+	int page;
+
+	int nand_irq;
+	int dma_irq;
+
+	unsigned long dma_status;
+
+	struct completion nand_complete;
+	struct completion dma_complete;
+};
+
+static uint8_t nand_bbt_pattern[] = { 'B', 'b', 't', '0' };
+static uint8_t nand_mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr nand_bbt_main_descr_2048 = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	4,
+	.len = 4,
+	.veroffs = 0,
+	.maxblocks = 4,
+	.pattern = nand_bbt_pattern,
+};
+
+static struct nand_bbt_descr nand_bbt_mirror_descr_2048 = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	4,
+	.len = 4,
+	.veroffs = 0,
+	.maxblocks = 4,
+	.pattern = nand_mirror_pattern,
+};
+
+struct nand_priv *wmt_mtd_to_priv(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct nand_priv, mtd);
+}
+
+int wmt_nand_get_bit(struct nand_priv *priv, int address, unsigned bit)
+{
+	return readl(priv->nand.IO_ADDR_R + address) & bit;
+}
+
+void wmt_nand_set_bit(struct nand_priv *priv, int address, unsigned val)
+{
+	unsigned long t = readl(priv->nand.IO_ADDR_R + address);
+	t |= val;
+	writel(t, priv->nand.IO_ADDR_R + address);
+}
+
+void wmt_nand_clear_bit(struct nand_priv *priv, int address, unsigned bit)
+{
+	unsigned long t = readl(priv->nand.IO_ADDR_R + address);
+	t &= ~bit;
+	writel(t, priv->nand.IO_ADDR_R + address);
+}
+
+#define NAND_MAX_CLOCK_SPEED	50000000
+static int wmt_nand_set_clock(struct nand_priv *priv)
+{
+	unsigned long ptRP = 12000;
+	unsigned long ptRC = 25000;
+	unsigned long ptWP = 12000;
+	unsigned long ptWC = 25000;
+	unsigned long reg;
+	unsigned long pule_reg;
+	unsigned long min_val;
+
+	min_val = min(min(ptRP, ptRC), min(ptWP, ptWC));
+
+	pule_reg = readl(priv->nand.IO_ADDR_R + REG_READ_CYCLE_PULE_CTRL);
+	pule_reg &= PULE_DIVISOR_MASK;
+
+	reg = ptRP / min_val;
+	reg <<= 4;
+
+	reg |= ptRC / min_val;
+	reg <<= 4;
+
+	reg |= ptWP / min_val;
+	reg <<= 4;
+
+	reg |= ptWC / min_val;
+
+	clk_set_rate(priv->clk, NAND_MAX_CLOCK_SPEED);
+
+	writel(pule_reg | reg, priv->nand.IO_ADDR_R + REG_READ_CYCLE_PULE_CTRL);
+
+	return 0;
+}
+
+void __iomem *wmt_nand_addr_cycle_to_reg(struct nand_priv *priv, int cycle)
+{
+	u8 *addr_reg = priv->nand.IO_ADDR_R + REG_COMPORT1_2;
+	return addr_reg + 4 * (cycle / 2) + cycle % 2;
+}
+
+static int wmt_nand_set_addr(struct nand_priv *priv, int column, int page_addr)
+{
+	struct nand_chip *chip = &priv->nand;
+	int addr_cycle = 0;
+	u8 *addr_reg;
+
+	if (column != -1) {
+		addr_reg = wmt_nand_addr_cycle_to_reg(priv, addr_cycle++);
+		writeb(column, addr_reg);
+		column >>= 8;
+
+		addr_reg = wmt_nand_addr_cycle_to_reg(priv, addr_cycle++);
+		writeb(column, addr_reg);
+	}
+
+	if (page_addr != -1) {
+		addr_reg = wmt_nand_addr_cycle_to_reg(priv, addr_cycle++);
+		writeb(page_addr, addr_reg);
+		page_addr >>= 8;
+
+		addr_reg = wmt_nand_addr_cycle_to_reg(priv, addr_cycle++);
+		writeb(page_addr, addr_reg);
+
+		if (chip->chip_shift - chip->page_shift > 16) {
+			page_addr >>= 8;
+			addr_reg = wmt_nand_addr_cycle_to_reg(priv, addr_cycle++);
+			writeb(page_addr, addr_reg);
+		}
+	}
+
+	return addr_cycle;
+}
+
+static void wmt_nand_clear_busy2ready(struct nand_priv *priv)
+{
+	wmt_nand_set_bit(priv, REG_HOST_STAT_CHANGE, HSC_B2R);
+}
+
+static int wmt_nand_get_busy2ready(struct nand_priv *priv)
+{
+	return wmt_nand_get_bit(priv, REG_HOST_STAT_CHANGE, HSC_B2R);
+}
+
+static int wmt_nand_wait_cmd_ready(struct nand_priv *priv)
+{
+	int loop_guard = (1 << 20);
+
+	while (--loop_guard && wmt_nand_get_bit(priv, REG_MISC_STAT_PORT, MSP_CMD_READY))
+		cpu_relax();
+
+	BUG_ON(!loop_guard);
+
+	return 0;
+}
+
+static int wmt_nand_wait_transfer_ready(struct nand_priv *priv)
+{
+	int loop_guard = (1 << 28);
+
+	while (--loop_guard &&
+		wmt_nand_get_bit(priv, REG_MISC_STAT_PORT, MSP_TRANSFER_ACTIVE))
+		cpu_relax();
+
+	BUG_ON(!loop_guard);
+
+	return 0;
+}
+
+static int wmt_nand_device_ready(struct mtd_info *mtd)
+{
+	struct nand_priv *priv = wmt_mtd_to_priv(mtd);
+	return wmt_nand_get_bit(priv, REG_MISC_STAT_PORT, MSP_READY);
+}
+
+static int wmt_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,
+			       uint8_t *buf, int oob_required, int page)
+{
+	struct nand_priv *priv = wmt_mtd_to_priv(mtd);
+
+	chip->read_buf(mtd, buf, mtd->writesize);
+	memcpy_fromio(chip->oob_poi, priv->nand.IO_ADDR_R + REG_ECC_FIFO_0,
+		      min(64u, mtd->oobsize));
+
+	return 0;
+}
+
+static void wmt_nand_setup_dma_transfer(struct nand_priv *priv, int direction)
+{
+	unsigned long tmp;
+
+	writew(priv->mtd.writesize - 1, priv->nand.IO_ADDR_R + REG_DMA_COUNTER);
+
+	if (readl(priv->nand.IO_ADDR_R + REG_NFC_DMA_ISR) & DMA_IER_INT_STS) {
+		int loop_guard = 1 << 20;
+
+		writel(DMA_IER_INT_STS, priv->nand.IO_ADDR_R + REG_NFC_DMA_ISR);
+
+		while (--loop_guard &&
+			(readl(priv->nand.IO_ADDR_R + REG_NFC_DMA_ISR) &
+			DMA_IER_INT_STS))
+			cpu_relax();
+
+		if (!loop_guard) {
+			dev_err(priv->dev,
+				"PDMA interrupt status can't be cleared");
+			dev_err(priv->dev, "REG_NFC_DMA_ISR = 0x%8.8x\n",
+				(unsigned int)readl(priv->nand.IO_ADDR_R +
+						    REG_NFC_DMA_ISR));
+			BUG();
+		}
+	}
+
+	writel(DMA_GCR_SOFTRESET, priv->nand.IO_ADDR_R + REG_NFC_DMA_GCR);
+	writel(DMA_GCR_DMA_EN, priv->nand.IO_ADDR_R + REG_NFC_DMA_GCR);
+	/* check if we really succeeded */
+	BUG_ON((readl(priv->nand.IO_ADDR_R + REG_NFC_DMA_GCR) & DMA_GCR_DMA_EN)
+	       == 0);
+
+	memset(priv->dma_desc, 0, sizeof(*priv->dma_desc));
+	priv->dma_desc->req_count = priv->mtd.writesize;
+	priv->dma_desc->format = 1;
+	priv->dma_desc->i = 1;
+	priv->dma_desc->addr = (u32) priv->dmaaddr;
+	priv->dma_desc->end = 1;
+
+	writel((u32) priv->dma_d_addr, priv->nand.IO_ADDR_R + REG_NFC_DMA_DESPR);
+
+	/* set direction */
+	tmp = readl(priv->nand.IO_ADDR_R + REG_NFC_DMA_CCR);
+	if (direction == NAND_DIR_READ)
+		tmp |= DMA_CCR_PERIPHERAL_TO_IF;
+	else
+		tmp &= ~DMA_CCR_IF_TO_PERIPHERAL;
+	writel(tmp, priv->nand.IO_ADDR_R + REG_NFC_DMA_CCR);
+
+	writel(1, priv->nand.IO_ADDR_R + REG_NFC_DMA_IER);
+
+	tmp = readl(priv->nand.IO_ADDR_R + REG_NFC_DMA_CCR);
+	tmp |= DMA_CCR_RUN;
+	writel(tmp, priv->nand.IO_ADDR_R + REG_NFC_DMA_CCR);
+}
+
+static void wmt_nand_setup_command(struct nand_priv *priv, int flag,
+				 int command_bytes)
+{
+	u8 byte = 0;
+	byte |= flag;
+	byte |= command_bytes << 1;
+	writeb(byte, priv->nand.IO_ADDR_R + REG_COMCTRL);
+}
+
+static void wmt_nand_trigger_command(struct nand_priv *priv, int flag,
+				   int command_bytes)
+{
+	flag |= COMCTRL_TRIGGER_CMD;
+	wmt_nand_setup_command(priv, flag, command_bytes);
+}
+
+static int wmt_nand_wait_dma(struct nand_priv *priv)
+{
+	if (!wait_for_completion_interruptible_timeout
+	    (&priv->dma_complete, msecs_to_jiffies(1000))) {
+		dev_err(priv->dev, "Waiting for dma interrupt failed!\n");
+		return -1;
+	}
+
+	if (priv->dma_status == DMA_CCR_EVT_FF_UNDERRUN)
+		dev_err(priv->dev, "PDMA Buffer under run!\n");
+
+	if (priv->dma_status == DMA_CCR_EVT_FF_OVERRUN)
+		dev_err(priv->dev, "PDMA Buffer over run!\n");
+
+	if (priv->dma_status == DMA_CCR_EVT_DESP_READ)
+		dev_err(priv->dev, "PDMA read Descriptor error!\n");
+
+	if (priv->dma_status == DMA_CCR_EVT_DATA_RW)
+		dev_err(priv->dev,
+			"PDMA read/write memory descriptor error!\n");
+
+	if (priv->dma_status == DMA_CCR_EVT_EARLY_END)
+		dev_err(priv->dev, "PDMA read early end!\n");
+
+	return 0;
+}
+
+static int wmt_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
+			    int page)
+{
+	int addr_cycle;
+	int status;
+	struct nand_priv *priv = wmt_mtd_to_priv(mtd);
+
+	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+	priv->dataptr = 0;
+	addr_cycle = wmt_nand_set_addr(priv, 0, page);
+	wmt_nand_setup_dma_transfer(priv, NAND_DIR_WRITE);
+
+	memset_io(priv->nand.IO_ADDR_R + REG_ECC_FIFO_0, 0xff, 64);
+	memcpy_toio(priv->nand.IO_ADDR_R + REG_ECC_FIFO_0, chip->oob_poi,
+		    min(24u, mtd->oobsize));
+
+	writeb(NAND_CMD_SEQIN, priv->nand.IO_ADDR_W);
+	wmt_nand_trigger_command(priv, COMCTRL_NFC_2_NAND,
+			       addr_cycle + 1);
+
+	wmt_nand_wait_dma(priv);
+
+	wmt_nand_wait_transfer_ready(priv);
+
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+
+}
+
+static int wmt_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+				const uint8_t *buf, int oob_required)
+{
+	int addr_cycle;
+	struct nand_priv *priv = wmt_mtd_to_priv(mtd);
+
+	memset_io(priv->nand.IO_ADDR_R + REG_ECC_FIFO_0, 0xff, 64);
+	memcpy_toio(priv->nand.IO_ADDR_R + REG_ECC_FIFO_0, chip->oob_poi,
+		    min(24u, mtd->oobsize));
+
+	priv->dataptr = 0;
+	chip->write_buf(mtd, buf, mtd->writesize);
+
+	addr_cycle = wmt_nand_set_addr(priv, 0, priv->page);
+
+	wmt_nand_setup_dma_transfer(priv, NAND_DIR_WRITE);
+
+	writeb(NAND_CMD_SEQIN, priv->nand.IO_ADDR_W);
+	wmt_nand_trigger_command(priv, COMCTRL_NFC_2_NAND,
+			       addr_cycle + 1);
+
+	wmt_nand_wait_dma(priv);
+
+	wmt_nand_wait_transfer_ready(priv);
+
+	return 0;
+}
+
+static int wmt_nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+				   uint8_t *buf, int oob_required, int page)
+{
+	struct nand_priv *priv = wmt_mtd_to_priv(mtd);
+
+	chip->read_buf(mtd, buf, mtd->writesize);
+	memcpy_fromio(chip->oob_poi, priv->nand.IO_ADDR_R + REG_ECC_FIFO_0,
+		      min(64u, mtd->oobsize));
+
+	return 0;
+}
+
+static void wmt_nand_select_chip(struct mtd_info *mtd, int chipnr)
+{
+
+	struct nand_priv *priv = wmt_mtd_to_priv(mtd);
+
+	dev_dbg(priv->dev, "Selecting chip nr %d", chipnr);
+
+	switch (chipnr) {
+	case -1:
+		writeb(0xff, priv->nand.IO_ADDR_R + REG_CHIP_ENABLE_CTRL);
+		break;
+	case 0:
+		writeb(0xfe, priv->nand.IO_ADDR_R + REG_CHIP_ENABLE_CTRL);
+		break;
+	default:
+		dev_err(priv->dev, "Only one chip nr 0 is supported, got chip nr:%d", chipnr);
+		BUG();
+		break;
+	}
+}
+
+static void wmt_nand_read_resume(struct nand_priv *priv)
+{
+	wmt_nand_set_bit(priv, REG_ECC_BCH_CTRL, EBC_READ_RESUME);
+}
+
+static u8 wmt_nand_bit_correct(u8 val, int bit)
+{
+	return val ^ (1 << bit);
+}
+
+static void wmt_nand_correct_error(struct nand_priv *priv)
+{
+	int i, err_count, err_byte, err_bit, err_reg, oob, bank, err_idx;
+	u8 v;
+
+	err_count = readl(priv->nand.IO_ADDR_R + REG_ECC_BCH_INT_STAT2) & 0xf;
+	oob = wmt_nand_get_bit(priv, REG_ECC_BCH_INT_STAT2, EBIS2_ERROR_OOB);
+
+	if (!oob)
+		bank = (readl(priv->nand.IO_ADDR_R + REG_ECC_BCH_INT_STAT2) >> 8) & 0x3;
+
+	if (err_count > 4) {
+		dev_info(priv->dev, "Too many errors(%d), cannot correct.\n", err_count);
+		priv->mtd.ecc_stats.failed++;
+		wmt_nand_read_resume(priv);
+		return;
+	}
+
+	for (i = 0; i < err_count; i++) {
+		err_reg = readl(priv->nand.IO_ADDR_R + REG_ECC_BCH_ERR_POS1 + 4 * (i / 2));
+		if (i % 2)
+			err_reg >>= 16;
+		err_reg &= 0x1fff;
+		err_byte = err_reg >> 3;
+		err_bit = err_reg & 0x7;
+
+		dev_info(priv->dev, "Correcting byte: %d, bit: %d\n", err_byte, err_bit);
+
+		if (!oob) {
+			err_idx = priv->nand.ecc.size * bank + err_byte;
+			v = priv->dmabuf[err_idx];
+			v = wmt_nand_bit_correct(v, err_bit);
+			priv->dmabuf[err_idx] = v;
+		} else {
+			v = readb(priv->nand.IO_ADDR_R + REG_ECC_FIFO_0 + err_byte);
+			v = wmt_nand_bit_correct(v, err_bit);
+			writeb(v, priv->nand.IO_ADDR_R + REG_ECC_FIFO_0 + err_byte);
+		}
+	}
+
+	wmt_nand_read_resume(priv);
+}
+
+static int wmt_nand_wait_completion(struct nand_priv *priv)
+{
+	if (!wait_for_completion_interruptible_timeout
+	    (&priv->nand_complete, msecs_to_jiffies(1000))) {
+		dev_err(priv->dev, "Waiting for nand interrupt failed!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void wmt_nand_read_command(struct nand_priv *priv, int page_addr,
+				int column, int command)
+{
+	int addr_cycle;
+	unsigned short tmp;
+
+	if (command == NAND_CMD_READOOB && column != -1)
+		column +=
+		    (priv->nand.ecc.size +
+		     priv->nand.ecc.bytes) * priv->nand.ecc.steps;
+
+	addr_cycle = wmt_nand_set_addr(priv, column, page_addr);
+
+	if (command == NAND_CMD_READ0)
+		wmt_nand_setup_dma_transfer(priv, NAND_DIR_READ);
+
+	tmp = readw(priv->nand.IO_ADDR_R + REG_ECC_BCH_INT_STAT1);
+	tmp |= EBIS1_ERROR | EBIS1_CORRECTION_DONE;
+	writew(tmp, priv->nand.IO_ADDR_R + REG_ECC_BCH_INT_STAT1);
+
+	priv->dataptr = 0;
+
+	writeb(NAND_CMD_READ0, priv->nand.IO_ADDR_W);
+	writeb(NAND_CMD_READSTART,
+	       wmt_nand_addr_cycle_to_reg(priv, addr_cycle));
+	wmt_nand_trigger_command(priv, COMCTRL_NAND_2_NFC |
+				 COMCTRL_MULT_COMMANDS, addr_cycle + 2);
+
+	if (command == NAND_CMD_READ0)
+		wmt_nand_wait_dma(priv);
+
+	wmt_nand_wait_completion(priv);
+}
+
+static void wmt_nand_readid(struct nand_priv *priv, int column)
+{
+	int addr_cycle = 0;
+	int i;
+
+	addr_cycle = wmt_nand_set_addr(priv, 0, -1);
+	writeb(NAND_CMD_READID, priv->nand.IO_ADDR_W);
+
+	wmt_nand_trigger_command(priv, COMCTRL_NO_DATA | COMCTRL_NFC_2_NAND |
+				 COMCTRL_CYCLES_NONE, addr_cycle + 1);
+	wmt_nand_wait_cmd_ready(priv);
+
+	for (i=0; i < column + 8; i++) {
+		wmt_nand_trigger_command(priv, COMCTRL_HAS_DATA |
+					 COMCTRL_NAND_2_NFC |
+					 COMCTRL_CYCLES_SINGLE, 0);
+
+		if (wmt_nand_wait_cmd_ready(priv))
+			dev_warn(priv->dev, "Timed out waiting for command completion before reading byte\n");
+
+		wmt_nand_wait_transfer_ready(priv);
+
+		priv->dmabuf[i] = readb(priv->nand.IO_ADDR_R);
+	}
+
+	priv->dataptr = column;
+}
+
+static void wmt_nand_cmdfunc(struct mtd_info *mtd, unsigned command,
+				int column, int page_addr)
+{
+
+	struct nand_priv *priv = wmt_mtd_to_priv(mtd);
+	int addr_cycle = 0;
+
+	dev_dbg(priv->dev, "Command: %u, column: %x, page_addr: %x\n",
+		command, column, page_addr);
+
+	switch (command) {
+	case NAND_CMD_SEQIN:
+		priv->page = page_addr;
+		return;
+	case NAND_CMD_READID:
+		wmt_nand_readid(priv, column);
+		return;
+	case NAND_CMD_ERASE1:
+		addr_cycle = wmt_nand_set_addr(priv, column, page_addr);
+	case NAND_CMD_RESET:
+	case NAND_CMD_ERASE2:
+	case NAND_CMD_PAGEPROG:
+	case NAND_CMD_STATUS:
+		writeb(command, priv->nand.IO_ADDR_W);
+
+		wmt_nand_trigger_command(priv, COMCTRL_NO_DATA |
+					 COMCTRL_NFC_2_NAND |
+					 COMCTRL_CYCLES_NONE, addr_cycle + 1);
+		if (command == NAND_CMD_ERASE1 || command == NAND_CMD_STATUS
+					       || command == NAND_CMD_READID)
+			wmt_nand_wait_cmd_ready(priv);
+		else
+			wmt_nand_wait_completion(priv);
+
+		break;
+	case NAND_CMD_READOOB:
+	case NAND_CMD_READ0:
+		wmt_nand_read_command(priv, page_addr, column, command);
+		break;
+	default:
+		dev_err(priv->dev,
+			"Command: %u, column: %d, page_addr: %d\n", command,
+			column, page_addr);
+		BUG();
+	}
+}
+
+static int wmt_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+			      int page)
+{
+
+	struct nand_priv *priv = wmt_mtd_to_priv(mtd);
+	uint8_t *buf = chip->oob_poi;
+
+	wmt_nand_set_bit(priv, REG_SMC_ENABLE, 0x02);
+
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+
+	memcpy_fromio(buf, priv->nand.IO_ADDR_R + REG_ECC_FIFO_0,
+		      min(64u, mtd->oobsize));
+
+	wmt_nand_clear_bit(priv, REG_SMC_ENABLE, 0x02);
+	return 0;
+}
+
+static void wmt_nand_init_chip(struct nand_priv *priv)
+{
+	unsigned long t;
+	u32 page_per_block_div;
+	u8 type = TYPESEL_CHECK_ALLFF | TYPESEL_WP_DIS | TYPESEL_DIRECT_MAP |
+		  TYPESEL_WIDTH_8 | TYPESEL_DIRECT_MAP;
+
+	switch (priv->mtd.writesize) {
+	case 512:
+		type |= TYPESEL_PAGE_512;
+		break;
+	case 2048:
+		type |= TYPESEL_PAGE_2K;
+		break;
+	case 4096:
+		type |= TYPESEL_PAGE_4K;
+		break;
+	case 8192:
+		type |= TYPESEL_PAGE_8K;
+		break;
+	default:
+		BUG();
+	}
+
+	writeb(type, priv->nand.IO_ADDR_R + REG_NAND_TYPE_SEL);
+
+	switch (priv->mtd.erasesize / priv->mtd.writesize) {
+	case 16:
+		page_per_block_div = 0;
+		break;
+	case 32:
+		page_per_block_div = 1;
+		break;
+	case 64:
+		page_per_block_div = 2;
+		break;
+	case 128:
+		page_per_block_div = 3;
+		break;
+	case 256:
+		page_per_block_div = 4;
+		break;
+	case 512:
+		page_per_block_div = 5;
+		break;
+	default:
+		BUG();
+	}
+	printk("mtd pages_per_block = %d\n", (2 ^ (page_per_block_div + 4)));
+
+	t = readl(priv->nand.IO_ADDR_R + REG_PAGESIZE_DIVIDER_SEL);
+	t &= ~PAGE_BLOCK_DIVISOR_MASK;
+	t |= PAGE_BLOCK_DIVISOR(page_per_block_div);
+	writel(t, priv->nand.IO_ADDR_R + REG_PAGESIZE_DIVIDER_SEL);
+
+	/* set ecc type */
+	t = readl(priv->nand.IO_ADDR_R + REG_ECC_BCH_CTRL);
+	t &= EBC_ECC_TYPE_MASK;
+
+	if (priv->mtd.writesize >= 8192)
+		t |= EBC_ECC_24BITPER1K;
+	else if (priv->mtd.writesize >= 4096 && priv->mtd.oobsize >= 218)
+		t |= EBC_ECC_12BIT;
+	else if (priv->mtd.writesize > 512)
+		t |= EBC_ECC_4BIT;
+	else
+		t |= EBC_ECC_1BIT;
+
+	writel(t, priv->nand.IO_ADDR_R + REG_ECC_BCH_CTRL);
+
+	/* enable hardware ecc */
+	wmt_nand_clear_bit(priv, REG_MISC_CTRL, MISCCTRL_SOFTWARE_ECC);
+
+	/* enable ecc interrupt */
+	writew(EBIM_INT_EN, priv->nand.IO_ADDR_R + REG_ECC_BCH_INT_MASK);
+}
+
+static void wmt_nand_write_buf(struct mtd_info *mtd, const uint8_t * buf, int len)
+{
+	struct nand_priv *priv = wmt_mtd_to_priv(mtd);
+
+	len = min(len, (DMA_BUFFER_SIZE - priv->dataptr));
+
+	memcpy(priv->dmabuf + priv->dataptr, buf, len);
+	priv->dataptr += len;
+}
+
+static void wmt_nand_read_buf(struct mtd_info *mtd, uint8_t * buf, int len)
+{
+	struct nand_priv *priv = wmt_mtd_to_priv(mtd);
+
+	len = min(len, (DMA_BUFFER_SIZE - priv->dataptr));
+
+	memcpy(buf, priv->dmabuf + priv->dataptr, len);
+	priv->dataptr += len;
+}
+
+static uint8_t wmt_nand_read_byte(struct mtd_info *mtd)
+{
+	uint8_t tmp;
+
+	wmt_nand_read_buf(mtd, &tmp, 1);
+
+	return tmp;
+}
+
+static void wmt_nand_startup(struct nand_priv *priv)
+{
+	wmt_nand_read_resume(priv);
+	writel(RESM_MASK, priv->nand.IO_ADDR_R + REG_REDUNT_ECC_STAT_MASK);
+}
+
+static irqreturn_t wmt_nand_irq(int irq_num, void *_data)
+{
+	struct nand_priv *priv = _data;
+
+	int loop_guard = 1 << 20;
+
+	if (wmt_nand_get_bit(priv, REG_ECC_BCH_INT_STAT1, EBIS1_ERROR)) {
+		wmt_nand_correct_error(priv);
+		return IRQ_HANDLED;
+	}
+
+	while (--loop_guard && !wmt_nand_get_busy2ready(priv))
+		cpu_relax();
+
+	BUG_ON(!loop_guard);
+
+	wmt_nand_clear_busy2ready(priv);
+	complete(&priv->nand_complete);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t wmt_nand_dma_irq(int irq_num, void *_data)
+{
+	struct nand_priv *priv = _data;
+
+	if (readl(priv->nand.IO_ADDR_R + REG_NFC_DMA_ISR) & DMA_IER_INT_STS) {
+		priv->dma_status = readl(priv->nand.IO_ADDR_R + REG_NFC_DMA_CCR) & DMA_CCR_EVTCODE;
+		writel(DMA_IER_INT_STS, priv->nand.IO_ADDR_R + REG_NFC_DMA_ISR);
+	}
+	complete(&priv->dma_complete);
+	return IRQ_HANDLED;
+}
+
+static int wmt_nand_probe(struct platform_device *pdev)
+{
+	struct nand_priv *priv;
+	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
+	struct mtd_part_parser_data mtd_ppd;
+	unsigned int nand_options;
+	int ecc_mode, err;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct nand_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = &pdev->dev;
+	dev_set_drvdata(priv->dev, priv);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->reg_base = devm_ioremap_resource(priv->dev, res);
+	if (IS_ERR(priv->reg_base)) {
+		dev_err(priv->dev, "Failed to map register memory");
+		return PTR_ERR(priv->reg_base);
+	}
+
+	priv->clk = of_clk_get(np, 0);
+	if (IS_ERR(priv->clk)) {
+		dev_err(priv->dev, "Failed to get clock\n");
+		return -EINVAL;
+	}
+
+	priv->dmabuf = dmam_alloc_coherent(priv->dev, DMA_BUFFER_SIZE,
+					   &priv->dmaaddr, GFP_KERNEL);
+	if (!priv->dmabuf) {
+		dev_err(priv->dev, "Failed to allocate dma memory");
+		return -ENOMEM;
+	}
+
+	priv->dma_desc = dmam_alloc_coherent(priv->dev,
+					     sizeof(*priv->dma_desc),
+					     &priv->dma_d_addr, GFP_KERNEL);
+	if (!priv->dma_desc) {
+		dev_err(priv->dev, "Failed to allocate dma descriptor");
+		return -ENOMEM;
+	}
+
+	priv->nand_irq = platform_get_irq(pdev, 0);
+	if (priv->nand_irq == NO_IRQ) {
+		dev_err(priv->dev, "Failed to retrive nand irq");
+		return -EINVAL;
+	}
+
+	priv->dma_irq = platform_get_irq(pdev, 1);
+	if (priv->dma_irq == NO_IRQ) {
+		dev_err(priv->dev, "Failed to retrive nand dma irq");
+		return -EINVAL;
+	}
+
+	if (devm_request_irq(priv->dev, priv->nand_irq, wmt_nand_irq, 0,
+			     "nand", priv)) {
+		dev_err(priv->dev, "Failed to register nand irq handler");
+		return -EINVAL;
+	}
+
+	if (devm_request_irq(priv->dev, priv->dma_irq, wmt_nand_dma_irq, 0,
+			     "nand-dma", priv)) {
+		dev_err(priv->dev, "Failed to register dma irq handler");
+		return -EINVAL;
+	}
+
+	priv->mtd.priv = &priv->nand;
+	priv->mtd.owner = THIS_MODULE;
+	priv->mtd.name = "wmt_nand";
+
+	priv->nand.bbt_td = &nand_bbt_main_descr_2048;
+	priv->nand.bbt_md = &nand_bbt_mirror_descr_2048;
+	
+	ecc_mode = of_get_nand_ecc_mode(np);
+	priv->nand.ecc.mode = ecc_mode < 0 ? NAND_ECC_SOFT : ecc_mode;
+	priv->nand.ecc.layout = &vt8500_oobinfo;
+	priv->nand.ecc.size = 512;
+	priv->nand.ecc.bytes = 8;
+	priv->nand.ecc.steps = 8;
+	priv->nand.ecc.strength = 4;
+
+	priv->nand.buffers = devm_kzalloc(priv->dev, sizeof(*priv->nand.buffers), GFP_KERNEL);
+	if (!priv->nand.buffers) {
+		printk("failed to allocate buffers\n");
+		return -ENOMEM;
+	}
+
+	nand_options = NAND_OWN_BUFFERS | NAND_BBT_LASTBLOCK | NAND_BBT_PERCHIP;
+	if (of_get_nand_on_flash_bbt(np))
+		nand_options |= NAND_BBT_USE_FLASH;
+	if (of_get_nand_bus_width(np) == 16)
+		nand_options |= NAND_BUSWIDTH_16;
+
+	priv->nand.options = nand_options;
+	priv->nand.IO_ADDR_R = priv->reg_base;
+	priv->nand.IO_ADDR_W = priv->reg_base + REG_COMPORT0;
+	priv->nand.cmdfunc = wmt_nand_cmdfunc;
+	priv->nand.dev_ready = wmt_nand_device_ready;
+	priv->nand.read_byte = wmt_nand_read_byte;
+	priv->nand.read_buf = wmt_nand_read_buf;
+	priv->nand.write_buf = wmt_nand_write_buf;
+	priv->nand.select_chip = wmt_nand_select_chip;
+	priv->nand.ecc.read_page = wmt_nand_read_page;
+	priv->nand.ecc.read_page_raw = wmt_nand_read_page_raw;
+	priv->nand.ecc.read_oob = wmt_nand_read_oob;
+	priv->nand.ecc.write_page_raw = wmt_nand_write_page;
+	priv->nand.ecc.write_page = wmt_nand_write_page;
+	priv->nand.ecc.write_oob = wmt_nand_write_oob;
+	priv->nand.chip_delay = 20;
+
+	init_completion(&priv->nand_complete);
+	init_completion(&priv->dma_complete);
+
+	clk_prepare_enable(priv->clk);
+	wmt_nand_startup(priv);
+
+	//wmt_nand_set_clock(priv);
+
+	err = nand_scan_ident(&priv->mtd, 1, NULL);
+	if (err) {
+		printk("nand_scan_ident() failed\n");
+		clk_disable_unprepare(priv->clk);
+		return -ENXIO;
+	}
+
+	printk("mtd erasesize = %d\n", priv->mtd.erasesize);
+	printk("mtd writesize = %d\n", priv->mtd.writesize);
+	wmt_nand_init_chip(priv);
+
+	err = nand_scan_tail(&priv->mtd);
+	if (err) {
+		printk("nand_scan_tail() failed\n");
+		clk_disable_unprepare(priv->clk);
+		return -ENXIO;
+	}
+
+	mtd_ppd.of_node = np;
+	err = mtd_device_parse_register(&priv->mtd, NULL, &mtd_ppd, NULL, 0);
+	if (err) {
+		printk("mtd_device_register() failed\n");
+		nand_release(&priv->mtd);
+		return err;
+	}
+
+	return 0;
+}
+
+static int wmt_nand_remove(struct platform_device *pdev)
+{
+
+	struct nand_priv *priv = dev_get_drvdata(&pdev->dev);
+
+	nand_release(&priv->mtd);
+
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static struct of_device_id wmt_nand_dt_ids[] = {
+	{ .compatible = "wm,wm8750-nand" },
+	{ /* Sentinel */ },
+};
+
+static struct platform_driver wmt_nand_driver = {
+	.probe = wmt_nand_probe,
+	.remove = wmt_nand_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = wmt_nand_dt_ids,
+	}
+};
+
+module_platform_driver(wmt_nand_driver);
+
+MODULE_DESCRIPTION("WonderMedia WM8xxx-series NAND Driver");
+MODULE_AUTHOR("Tony Prisk");
+MODULE_LICENSE("GPL v2");
+MODULE_DEVICE_TABLE(of, wmt_nand_dt_ids);
diff -Naur linux-4.5/drivers/pinctrl/vt8500/pinctrl-wm8750.c wm8505_linux4.5/drivers/pinctrl/vt8500/pinctrl-wm8750.c
--- linux-4.5/drivers/pinctrl/vt8500/pinctrl-wm8750.c	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/pinctrl/vt8500/pinctrl-wm8750.c	2019-03-28 09:01:59.000000000 -0700
@@ -87,6 +87,14 @@
 #define WMT_PIN_VDIN5		WMT_PIN(2, 5)
 #define WMT_PIN_VDIN6		WMT_PIN(2, 6)
 #define WMT_PIN_VDIN7		WMT_PIN(2, 7)
+#define WMT_PIN_VGA0		WMT_PIN(2, 8)
+#define WMT_PIN_VGA1		WMT_PIN(2, 9)
+#define WMT_PIN_VGA2		WMT_PIN(2, 10)
+#define WMT_PIN_VGA3		WMT_PIN(2, 11)
+#define WMT_PIN_VGA4		WMT_PIN(2, 12)
+#define WMT_PIN_VGA5		WMT_PIN(2, 13)
+#define WMT_PIN_VGA6		WMT_PIN(2, 14)
+#define WMT_PIN_VGA7		WMT_PIN(2, 15)
 #define WMT_PIN_SPI0_MOSI	WMT_PIN(2, 24)
 #define WMT_PIN_SPI0_MISO	WMT_PIN(2, 25)
 #define WMT_PIN_SPI0_SS		WMT_PIN(2, 26)
@@ -192,6 +200,14 @@
 	PINCTRL_PIN(WMT_PIN_VDIN5, "vdin5"),
 	PINCTRL_PIN(WMT_PIN_VDIN6, "vdin6"),
 	PINCTRL_PIN(WMT_PIN_VDIN7, "vdin7"),
+	PINCTRL_PIN(WMT_PIN_VGA0, "vga0"),
+	PINCTRL_PIN(WMT_PIN_VGA1, "vga1"),
+	PINCTRL_PIN(WMT_PIN_VGA2, "vga2"),
+	PINCTRL_PIN(WMT_PIN_VGA3, "vga3"),
+	PINCTRL_PIN(WMT_PIN_VGA4, "vga4"),
+	PINCTRL_PIN(WMT_PIN_VGA5, "vga5"),
+	PINCTRL_PIN(WMT_PIN_VGA6, "vga6"),
+	PINCTRL_PIN(WMT_PIN_VGA7, "vga7"),
 	PINCTRL_PIN(WMT_PIN_SPI0_MOSI, "spi0_mosi"),
 	PINCTRL_PIN(WMT_PIN_SPI0_MISO, "spi0_miso"),
 	PINCTRL_PIN(WMT_PIN_SPI0_SS, "spi0_ss"),
@@ -299,6 +315,14 @@
 	"vdin5",
 	"vdin6",
 	"vdin7",
+	"vga0",
+	"vga1",
+	"vga2",
+	"vga3",
+	"vga4",
+	"vga5",
+	"vga6",
+	"vga7",
 	"spi0_mosi",
 	"spi0_miso",
 	"spi0_ss",
diff -Naur linux-4.5/drivers/video/fbdev/Kconfig wm8505_linux4.5/drivers/video/fbdev/Kconfig
--- linux-4.5/drivers/video/fbdev/Kconfig	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/video/fbdev/Kconfig	2019-03-28 09:02:06.000000000 -0700
@@ -1787,6 +1787,14 @@
 	  integrated LCD controller. This driver covers the WM8505, WM8650
 	  and WM8850 SoCs.
 
+config FB_WM8505_VGA
+	bool "Enable VGA output + Disable LCD output"
+	depends on FB_WM8505
+	help
+	  Select this option to enable the VGA output on the APC8750.
+	  Do NOT select this option if you have a netbook or tablet, as it
+	  will disable the LCD output.
+
 config FB_WMT_GE_ROPS
 	bool "VT8500/WM8xxx accelerated raster ops support"
 	depends on (FB = y) && (FB_VT8500 || FB_WM8505)
diff -Naur linux-4.5/drivers/video/fbdev/wm8505fb.c wm8505_linux4.5/drivers/video/fbdev/wm8505fb.c
--- linux-4.5/drivers/video/fbdev/wm8505fb.c	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/video/fbdev/wm8505fb.c	2019-03-28 09:02:06.000000000 -0700
@@ -14,6 +14,7 @@
  * GNU General Public License for more details.
  */
 
+#include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
 #include <linux/fb.h>
@@ -45,6 +46,9 @@
 	struct fb_info		fb;
 	void __iomem		*regbase;
 	unsigned int		contrast;
+#ifdef CONFIG_FB_WM8505_VGA
+	struct clk		*clk_dvo;
+#endif
 };
 
 
@@ -67,7 +71,12 @@
 	 * 0x31C sets the correct color mode (RGB565) for WM8650
 	 * Bit 8+9 (0x300) are ignored on WM8505 as reserved
 	 */
+#ifdef CONFIG_FB_WM8505_VGA
+	writel(0x338,		       fbi->regbase + WMT_GOVR_COLORSPACE);
+#else
 	writel(0x31c,		       fbi->regbase + WMT_GOVR_COLORSPACE);
+#endif
+
 	writel(1,		       fbi->regbase + WMT_GOVR_COLORSPACE1);
 
 	/* Virtual buffer size */
@@ -76,7 +85,13 @@
 
 	/* black magic ;) */
 	writel(0xf,		       fbi->regbase + WMT_GOVR_FHI);
+
+#ifdef CONFIG_FB_WM8505_VGA
+	writel(0xe,		       fbi->regbase + WMT_GOVR_DVO_SET);
+#else
 	writel(4,		       fbi->regbase + WMT_GOVR_DVO_SET);
+#endif
+
 	writel(1,		       fbi->regbase + WMT_GOVR_MIF_ENABLE);
 	writel(1,		       fbi->regbase + WMT_GOVR_REG_UPDATE);
 
@@ -103,11 +118,17 @@
 	writel(h_end,   fbi->regbase + WMT_GOVR_TIMING_H_END);
 	writel(h_all,   fbi->regbase + WMT_GOVR_TIMING_H_ALL);
 	writel(h_sync,  fbi->regbase + WMT_GOVR_TIMING_H_SYNC);
+#ifdef CONFIG_FB_WM8505_VGA
+	writel(h_sync,  fbi->regbase + WMT_VGA_TIMING_H_SYNC);
+#endif
 
 	writel(v_start, fbi->regbase + WMT_GOVR_TIMING_V_START);
 	writel(v_end,   fbi->regbase + WMT_GOVR_TIMING_V_END);
 	writel(v_all,   fbi->regbase + WMT_GOVR_TIMING_V_ALL);
 	writel(v_sync,  fbi->regbase + WMT_GOVR_TIMING_V_SYNC);
+#ifdef CONFIG_FB_WM8505_VGA
+	writel(0x1f80,  fbi->regbase + WMT_VGA_TIMING_V_SYNC);
+#endif
 
 	writel(1, fbi->regbase + WMT_GOVR_TG);
 
@@ -121,6 +142,9 @@
 
 	if (!fbi)
 		return -EINVAL;
+#ifdef CONFIG_FB_WM8505_VGA
+	clk_set_rate(fbi->clk_dvo, PICOS2KHZ(info->var.pixclock)*1000);
+#endif
 
 	if (info->var.bits_per_pixel == 32) {
 		info->var.red.offset = 16;
@@ -320,6 +344,16 @@
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_FB_WM8505_VGA
+	fbi->clk_dvo = of_clk_get(pdev->dev.of_node, 0);
+	if (IS_ERR(fbi->clk_dvo)) {
+		dev_err(&pdev->dev, "Error getting clock\n");
+		return PTR_ERR(fbi->clk_dvo);
+	}
+
+	clk_prepare_enable(fbi->clk_dvo);
+#endif
+
 	fb_videomode_to_var(&fbi->fb.var, &mode);
 
 	fbi->fb.var.nonstd		= 0;
diff -Naur linux-4.5/drivers/video/fbdev/wm8505fb_regs.h wm8505_linux4.5/drivers/video/fbdev/wm8505fb_regs.h
--- linux-4.5/drivers/video/fbdev/wm8505fb_regs.h	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/drivers/video/fbdev/wm8505fb_regs.h	2019-03-28 09:02:06.000000000 -0700
@@ -73,4 +73,7 @@
 #define WMT_GOVR_TIMING_V_SYNC	0x128
 #define WMT_GOVR_TIMING_H_SYNC	0x12c
 
+#define WMT_VGA_TIMING_H_SYNC	0x190
+#define WMT_VGA_TIMING_V_SYNC	0x194
+
 #endif /* _WM8505FB_REGS_H */
diff -Naur linux-4.5/MAINTAINERS wm8505_linux4.5/MAINTAINERS
--- linux-4.5/MAINTAINERS	2016-03-13 21:28:54.000000000 -0700
+++ wm8505_linux4.5/MAINTAINERS	2019-03-28 09:01:27.000000000 -0700
@@ -1753,9 +1753,13 @@
 L:	linux-arm-kernel@lists.infradead.org (moderated for non-subscribers)
 S:	Maintained
 F:	arch/arm/mach-vt8500/
+F:	drivers/clk/clk-vt8500.c
 F:	drivers/clocksource/vt8500_timer.c
 F:	drivers/i2c/busses/i2c-wmt.c
+F:	drivers/gpio/gpio-vt8500.c
+F:	drivers/input/keyboard/wmt_power_keypad.c
 F:	drivers/mmc/host/wmt-sdmmc.c
+F:	drivers/mtd/devices/wmt_sflash.c
 F:	drivers/pwm/pwm-vt8500.c
 F:	drivers/rtc/rtc-vt8500.c
 F:	drivers/tty/serial/vt8500_serial.c
