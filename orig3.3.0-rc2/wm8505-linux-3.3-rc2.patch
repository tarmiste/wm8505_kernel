diff -Naur linux-3.3-rc2/arch/arm/boot/compressed/head-vt8500.S wm8505-3.3rc2/arch/arm/boot/compressed/head-vt8500.S
--- linux-3.3-rc2/arch/arm/boot/compressed/head-vt8500.S	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/boot/compressed/head-vt8500.S	2012-02-06 12:27:43.000000000 -0700
@@ -23,24 +23,52 @@
 	ldreq	r7, .ID_BV07
 	beq	.Lendvt8500
 
+	@ VT8500 override - another version
+	ldr	r4, .VT8500SCCv2
+	cmp	r3, r4
+	ldreq	r7, .ID_BV07
+	beq	.Lendvt8500
+
 	@ WM8505 override
 	ldr	r4, .WM8505SCC
 	cmp	r3, r4
 	ldreq	r7, .ID_8505
 	beq	.Lendvt8500
 
+	@ WM8650 override
+	ldr	r4, .WM8650SCC
+	cmp	r3, r4
+	ldreq	r7, .ID_8650
+	beq	.Lendvt8500
+
+	@ WM8650 override - another version
+	ldr	r4, .WM8650SCCv2
+	cmp	r3, r4
+	ldreq	r7, .ID_8650
+	beq	.Lendvt8500
+
 	@ Otherwise, leave the bootloader's machine id untouched
+	b	.Lendvt8500
 
 .SCCID:
 	.word	0xd8120000
+
 .VT8500SCC:
 	.word	0x34000102
+.VT8500SCCv2:
+	.word	0x34000103
 .WM8505SCC:
 	.word	0x34260103
+.WM8650SCC:
+	.word	0x34650101
+.WM8650SCCv2:
+	.word	0x34650103
 
 .ID_BV07:
 	.word	MACH_TYPE_BV07
 .ID_8505:
 	.word	MACH_TYPE_WM8505_7IN_NETBOOK
+.ID_8650:
+	.word	MACH_TYPE_WM8650REFBOARD
 
 .Lendvt8500:
diff -Naur linux-3.3-rc2/arch/arm/configs/wmt_defconfig wm8505-3.3rc2/arch/arm/configs/wmt_defconfig
--- linux-3.3-rc2/arch/arm/configs/wmt_defconfig	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/configs/wmt_defconfig	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,83 @@
+CONFIG_ARM=y
+CONFIG_AEABI=y
+CONFIG_ARCH_VT8500=y
+CONFIG_MACH_BV07=y
+CONFIG_MACH_WM8505_7IN_NETBOOK=y
+CONFIG_MACH_WM8650REFBOARD=y
+CONFIG_WMT_PANEL_800X480=y
+CONFIG_WMT_PANEL_800X600=y
+CONFIG_WMT_PANEL_1024X576=y
+CONFIG_WMT_PANEL_1024X600=y
+CONFIG_WMT_PANEL_1024X768=y
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_WMT=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_WIRELESS=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_NETDEVICES=y
+CONFIG_NET_ETHERNET=y
+CONFIG_NETDEV_1000=y
+CONFIG_VIA_VELOCITY=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_EXPERIMENTAL=y
+CONFIG_RT2X00=y
+CONFIG_RT2800USB=y
+CONFIG_RT2800USB_RT33XX=y
+CONFIG_RT2800USB_RT35XX=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_VT8500=y
+CONFIG_SERIAL_VT8500_CONSOLE=y
+CONFIG_FB=y
+CONFIG_FB_VT8500=y
+CONFIG_FB_WM8505=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_USB=y
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_UHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_LIBUSUAL=y
+CONFIG_EXT4_FS=y
+CONFIG_BTRFS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4 is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+CONFIG_MMC=y
+CONFIG_MMC_WMT=y
+CONFIG_RTC_DRV_VT8500=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
diff -Naur linux-3.3-rc2/arch/arm/include/asm/tlb.h wm8505-3.3rc2/arch/arm/include/asm/tlb.h
--- linux-3.3-rc2/arch/arm/include/asm/tlb.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/include/asm/tlb.h	2012-02-06 12:27:43.000000000 -0700
@@ -198,7 +198,15 @@
 	unsigned long addr)
 {
 	pgtable_page_dtor(pte);
-	tlb_add_flush(tlb, addr);
+
+	/*
+	 * With the classic ARM MMU, a pte page has two corresponding pmd
+	 * entries, each covering 1MB.
+	 */
+	addr &= PMD_MASK;
+	tlb_add_flush(tlb, addr + SZ_1M - PAGE_SIZE);
+	tlb_add_flush(tlb, addr + SZ_1M);
+
 	tlb_remove_page(tlb, pte);
 }
 
diff -Naur linux-3.3-rc2/arch/arm/kernel/entry-armv.S wm8505-3.3rc2/arch/arm/kernel/entry-armv.S
--- linux-3.3-rc2/arch/arm/kernel/entry-armv.S	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/kernel/entry-armv.S	2012-02-06 12:27:43.000000000 -0700
@@ -790,7 +790,7 @@
 	smp_dmb	arm
 	rsbs	r0, r3, #0			@ set returned val and C flag
 	ldmfd	sp!, {r4, r5, r6, r7}
-	bx	lr
+	usr_ret	lr
 
 #elif !defined(CONFIG_SMP)
 
diff -Naur linux-3.3-rc2/arch/arm/kernel/perf_event_v7.c wm8505-3.3rc2/arch/arm/kernel/perf_event_v7.c
--- linux-3.3-rc2/arch/arm/kernel/perf_event_v7.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/kernel/perf_event_v7.c	2012-02-06 12:27:43.000000000 -0700
@@ -469,6 +469,20 @@
 			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
 		},
 	},
+	[C(NODE)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+	},
 };
 
 /*
@@ -576,6 +590,20 @@
 		},
 		[C(OP_PREFETCH)] = {
 			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+	},
+	[C(NODE)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
 			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
 		},
 	},
diff -Naur linux-3.3-rc2/arch/arm/kernel/ptrace.c wm8505-3.3rc2/arch/arm/kernel/ptrace.c
--- linux-3.3-rc2/arch/arm/kernel/ptrace.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/kernel/ptrace.c	2012-02-06 12:27:43.000000000 -0700
@@ -699,10 +699,13 @@
 {
 	int ret;
 	struct thread_info *thread = task_thread_info(target);
-	struct vfp_hard_struct new_vfp = thread->vfpstate.hard;
+	struct vfp_hard_struct new_vfp;
 	const size_t user_fpregs_offset = offsetof(struct user_vfp, fpregs);
 	const size_t user_fpscr_offset = offsetof(struct user_vfp, fpscr);
 
+	vfp_sync_hwstate(thread);
+	new_vfp = thread->vfpstate.hard;
+
 	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
 				  &new_vfp.fpregs,
 				  user_fpregs_offset,
@@ -723,9 +726,8 @@
 	if (ret)
 		return ret;
 
-	vfp_sync_hwstate(thread);
-	thread->vfpstate.hard = new_vfp;
 	vfp_flush_hwstate(thread);
+	thread->vfpstate.hard = new_vfp;
 
 	return 0;
 }
diff -Naur linux-3.3-rc2/arch/arm/kernel/signal.c wm8505-3.3rc2/arch/arm/kernel/signal.c
--- linux-3.3-rc2/arch/arm/kernel/signal.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/kernel/signal.c	2012-02-06 12:27:43.000000000 -0700
@@ -227,6 +227,8 @@
 	if (magic != VFP_MAGIC || size != VFP_STORAGE_SIZE)
 		return -EINVAL;
 
+	vfp_flush_hwstate(thread);
+
 	/*
 	 * Copy the floating point registers. There can be unused
 	 * registers see asm/hwcap.h for details.
@@ -251,9 +253,6 @@
 	__get_user_error(h->fpinst, &frame->ufp_exc.fpinst, err);
 	__get_user_error(h->fpinst2, &frame->ufp_exc.fpinst2, err);
 
-	if (!err)
-		vfp_flush_hwstate(thread);
-
 	return err ? -EFAULT : 0;
 }
 
diff -Naur linux-3.3-rc2/arch/arm/mach-bcmring/arch.c wm8505-3.3rc2/arch/arm/mach-bcmring/arch.c
--- linux-3.3-rc2/arch/arm/mach-bcmring/arch.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-bcmring/arch.c	2012-02-06 12:27:43.000000000 -0700
@@ -194,6 +194,6 @@
 	.init_early = bcmring_init_early,
 	.init_irq = bcmring_init_irq,
 	.timer = &bcmring_timer,
-	.init_machine = bcmring_init_machine
+	.init_machine = bcmring_init_machine,
 	.restart = bcmring_restart,
 MACHINE_END
diff -Naur linux-3.3-rc2/arch/arm/mach-bcmring/dma.c wm8505-3.3rc2/arch/arm/mach-bcmring/dma.c
--- linux-3.3-rc2/arch/arm/mach-bcmring/dma.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-bcmring/dma.c	2012-02-06 12:27:43.000000000 -0700
@@ -33,17 +33,11 @@
 
 #include <mach/timer.h>
 
-#include <linux/mm.h>
 #include <linux/pfn.h>
 #include <linux/atomic.h>
 #include <linux/sched.h>
 #include <mach/dma.h>
 
-/* I don't quite understand why dc4 fails when this is set to 1 and DMA is enabled */
-/* especially since dc4 doesn't use kmalloc'd memory. */
-
-#define ALLOW_MAP_OF_KMALLOC_MEMORY 0
-
 /* ---- Public Variables ------------------------------------------------- */
 
 /* ---- Private Constants and Types -------------------------------------- */
@@ -53,24 +47,12 @@
 #define CONTROLLER_FROM_HANDLE(handle)    (((handle) >> 4) & 0x0f)
 #define CHANNEL_FROM_HANDLE(handle)       ((handle) & 0x0f)
 
-#define DMA_MAP_DEBUG   0
-
-#if DMA_MAP_DEBUG
-#   define  DMA_MAP_PRINT(fmt, args...)   printk("%s: " fmt, __func__,  ## args)
-#else
-#   define  DMA_MAP_PRINT(fmt, args...)
-#endif
 
 /* ---- Private Variables ------------------------------------------------ */
 
 static DMA_Global_t gDMA;
 static struct proc_dir_entry *gDmaDir;
 
-static atomic_t gDmaStatMemTypeKmalloc = ATOMIC_INIT(0);
-static atomic_t gDmaStatMemTypeVmalloc = ATOMIC_INIT(0);
-static atomic_t gDmaStatMemTypeUser = ATOMIC_INIT(0);
-static atomic_t gDmaStatMemTypeCoherent = ATOMIC_INIT(0);
-
 #include "dma_device.c"
 
 /* ---- Private Function Prototypes -------------------------------------- */
@@ -79,34 +61,6 @@
 
 /****************************************************************************/
 /**
-*   Displays information for /proc/dma/mem-type
-*/
-/****************************************************************************/
-
-static int dma_proc_read_mem_type(char *buf, char **start, off_t offset,
-				  int count, int *eof, void *data)
-{
-	int len = 0;
-
-	len += sprintf(buf + len, "dma_map_mem statistics\n");
-	len +=
-	    sprintf(buf + len, "coherent: %d\n",
-		    atomic_read(&gDmaStatMemTypeCoherent));
-	len +=
-	    sprintf(buf + len, "kmalloc:  %d\n",
-		    atomic_read(&gDmaStatMemTypeKmalloc));
-	len +=
-	    sprintf(buf + len, "vmalloc:  %d\n",
-		    atomic_read(&gDmaStatMemTypeVmalloc));
-	len +=
-	    sprintf(buf + len, "user:     %d\n",
-		    atomic_read(&gDmaStatMemTypeUser));
-
-	return len;
-}
-
-/****************************************************************************/
-/**
 *   Displays information for /proc/dma/channels
 */
 /****************************************************************************/
@@ -846,8 +800,6 @@
 				       dma_proc_read_channels, NULL);
 		create_proc_read_entry("devices", 0, gDmaDir,
 				       dma_proc_read_devices, NULL);
-		create_proc_read_entry("mem-type", 0, gDmaDir,
-				       dma_proc_read_mem_type, NULL);
 	}
 
 out:
@@ -1565,767 +1517,3 @@
 }
 
 EXPORT_SYMBOL(dma_set_device_handler);
-
-/****************************************************************************/
-/**
-*   Initializes a memory mapping structure
-*/
-/****************************************************************************/
-
-int dma_init_mem_map(DMA_MemMap_t *memMap)
-{
-	memset(memMap, 0, sizeof(*memMap));
-
-	sema_init(&memMap->lock, 1);
-
-	return 0;
-}
-
-EXPORT_SYMBOL(dma_init_mem_map);
-
-/****************************************************************************/
-/**
-*   Releases any memory currently being held by a memory mapping structure.
-*/
-/****************************************************************************/
-
-int dma_term_mem_map(DMA_MemMap_t *memMap)
-{
-	down(&memMap->lock);	/* Just being paranoid */
-
-	/* Free up any allocated memory */
-
-	up(&memMap->lock);
-	memset(memMap, 0, sizeof(*memMap));
-
-	return 0;
-}
-
-EXPORT_SYMBOL(dma_term_mem_map);
-
-/****************************************************************************/
-/**
-*   Looks at a memory address and categorizes it.
-*
-*   @return One of the values from the DMA_MemType_t enumeration.
-*/
-/****************************************************************************/
-
-DMA_MemType_t dma_mem_type(void *addr)
-{
-	unsigned long addrVal = (unsigned long)addr;
-
-	if (addrVal >= CONSISTENT_BASE) {
-		/* NOTE: DMA virtual memory space starts at 0xFFxxxxxx */
-
-		/* dma_alloc_xxx pages are physically and virtually contiguous */
-
-		return DMA_MEM_TYPE_DMA;
-	}
-
-	/* Technically, we could add one more classification. Addresses between VMALLOC_END */
-	/* and the beginning of the DMA virtual address could be considered to be I/O space. */
-	/* Right now, nobody cares about this particular classification, so we ignore it. */
-
-	if (is_vmalloc_addr(addr)) {
-		/* Address comes from the vmalloc'd region. Pages are virtually */
-		/* contiguous but NOT physically contiguous */
-
-		return DMA_MEM_TYPE_VMALLOC;
-	}
-
-	if (addrVal >= PAGE_OFFSET) {
-		/* PAGE_OFFSET is typically 0xC0000000 */
-
-		/* kmalloc'd pages are physically contiguous */
-
-		return DMA_MEM_TYPE_KMALLOC;
-	}
-
-	return DMA_MEM_TYPE_USER;
-}
-
-EXPORT_SYMBOL(dma_mem_type);
-
-/****************************************************************************/
-/**
-*   Looks at a memory address and determines if we support DMA'ing to/from
-*   that type of memory.
-*
-*   @return boolean -
-*               return value != 0 means dma supported
-*               return value == 0 means dma not supported
-*/
-/****************************************************************************/
-
-int dma_mem_supports_dma(void *addr)
-{
-	DMA_MemType_t memType = dma_mem_type(addr);
-
-	return (memType == DMA_MEM_TYPE_DMA)
-#if ALLOW_MAP_OF_KMALLOC_MEMORY
-	    || (memType == DMA_MEM_TYPE_KMALLOC)
-#endif
-	    || (memType == DMA_MEM_TYPE_USER);
-}
-
-EXPORT_SYMBOL(dma_mem_supports_dma);
-
-/****************************************************************************/
-/**
-*   Maps in a memory region such that it can be used for performing a DMA.
-*
-*   @return
-*/
-/****************************************************************************/
-
-int dma_map_start(DMA_MemMap_t *memMap,	/* Stores state information about the map */
-		  enum dma_data_direction dir	/* Direction that the mapping will be going */
-    ) {
-	int rc;
-
-	down(&memMap->lock);
-
-	DMA_MAP_PRINT("memMap: %p\n", memMap);
-
-	if (memMap->inUse) {
-		printk(KERN_ERR "%s: memory map %p is already being used\n",
-		       __func__, memMap);
-		rc = -EBUSY;
-		goto out;
-	}
-
-	memMap->inUse = 1;
-	memMap->dir = dir;
-	memMap->numRegionsUsed = 0;
-
-	rc = 0;
-
-out:
-
-	DMA_MAP_PRINT("returning %d", rc);
-
-	up(&memMap->lock);
-
-	return rc;
-}
-
-EXPORT_SYMBOL(dma_map_start);
-
-/****************************************************************************/
-/**
-*   Adds a segment of memory to a memory map. Each segment is both
-*   physically and virtually contiguous.
-*
-*   @return     0 on success, error code otherwise.
-*/
-/****************************************************************************/
-
-static int dma_map_add_segment(DMA_MemMap_t *memMap,	/* Stores state information about the map */
-			       DMA_Region_t *region,	/* Region that the segment belongs to */
-			       void *virtAddr,	/* Virtual address of the segment being added */
-			       dma_addr_t physAddr,	/* Physical address of the segment being added */
-			       size_t numBytes	/* Number of bytes of the segment being added */
-    ) {
-	DMA_Segment_t *segment;
-
-	DMA_MAP_PRINT("memMap:%p va:%p pa:0x%x #:%d\n", memMap, virtAddr,
-		      physAddr, numBytes);
-
-	/* Sanity check */
-
-	if (((unsigned long)virtAddr < (unsigned long)region->virtAddr)
-	    || (((unsigned long)virtAddr + numBytes)) >
-	    ((unsigned long)region->virtAddr + region->numBytes)) {
-		printk(KERN_ERR
-		       "%s: virtAddr %p is outside region @ %p len: %d\n",
-		       __func__, virtAddr, region->virtAddr, region->numBytes);
-		return -EINVAL;
-	}
-
-	if (region->numSegmentsUsed > 0) {
-		/* Check to see if this segment is physically contiguous with the previous one */
-
-		segment = &region->segment[region->numSegmentsUsed - 1];
-
-		if ((segment->physAddr + segment->numBytes) == physAddr) {
-			/* It is - just add on to the end */
-
-			DMA_MAP_PRINT("appending %d bytes to last segment\n",
-				      numBytes);
-
-			segment->numBytes += numBytes;
-
-			return 0;
-		}
-	}
-
-	/* Reallocate to hold more segments, if required. */
-
-	if (region->numSegmentsUsed >= region->numSegmentsAllocated) {
-		DMA_Segment_t *newSegment;
-		size_t oldSize =
-		    region->numSegmentsAllocated * sizeof(*newSegment);
-		int newAlloc = region->numSegmentsAllocated + 4;
-		size_t newSize = newAlloc * sizeof(*newSegment);
-
-		newSegment = kmalloc(newSize, GFP_KERNEL);
-		if (newSegment == NULL) {
-			return -ENOMEM;
-		}
-		memcpy(newSegment, region->segment, oldSize);
-		memset(&((uint8_t *) newSegment)[oldSize], 0,
-		       newSize - oldSize);
-		kfree(region->segment);
-
-		region->numSegmentsAllocated = newAlloc;
-		region->segment = newSegment;
-	}
-
-	segment = &region->segment[region->numSegmentsUsed];
-	region->numSegmentsUsed++;
-
-	segment->virtAddr = virtAddr;
-	segment->physAddr = physAddr;
-	segment->numBytes = numBytes;
-
-	DMA_MAP_PRINT("returning success\n");
-
-	return 0;
-}
-
-/****************************************************************************/
-/**
-*   Adds a region of memory to a memory map. Each region is virtually
-*   contiguous, but not necessarily physically contiguous.
-*
-*   @return     0 on success, error code otherwise.
-*/
-/****************************************************************************/
-
-int dma_map_add_region(DMA_MemMap_t *memMap,	/* Stores state information about the map */
-		       void *mem,	/* Virtual address that we want to get a map of */
-		       size_t numBytes	/* Number of bytes being mapped */
-    ) {
-	unsigned long addr = (unsigned long)mem;
-	unsigned int offset;
-	int rc = 0;
-	DMA_Region_t *region;
-	dma_addr_t physAddr;
-
-	down(&memMap->lock);
-
-	DMA_MAP_PRINT("memMap:%p va:%p #:%d\n", memMap, mem, numBytes);
-
-	if (!memMap->inUse) {
-		printk(KERN_ERR "%s: Make sure you call dma_map_start first\n",
-		       __func__);
-		rc = -EINVAL;
-		goto out;
-	}
-
-	/* Reallocate to hold more regions. */
-
-	if (memMap->numRegionsUsed >= memMap->numRegionsAllocated) {
-		DMA_Region_t *newRegion;
-		size_t oldSize =
-		    memMap->numRegionsAllocated * sizeof(*newRegion);
-		int newAlloc = memMap->numRegionsAllocated + 4;
-		size_t newSize = newAlloc * sizeof(*newRegion);
-
-		newRegion = kmalloc(newSize, GFP_KERNEL);
-		if (newRegion == NULL) {
-			rc = -ENOMEM;
-			goto out;
-		}
-		memcpy(newRegion, memMap->region, oldSize);
-		memset(&((uint8_t *) newRegion)[oldSize], 0, newSize - oldSize);
-
-		kfree(memMap->region);
-
-		memMap->numRegionsAllocated = newAlloc;
-		memMap->region = newRegion;
-	}
-
-	region = &memMap->region[memMap->numRegionsUsed];
-	memMap->numRegionsUsed++;
-
-	offset = addr & ~PAGE_MASK;
-
-	region->memType = dma_mem_type(mem);
-	region->virtAddr = mem;
-	region->numBytes = numBytes;
-	region->numSegmentsUsed = 0;
-	region->numLockedPages = 0;
-	region->lockedPages = NULL;
-
-	switch (region->memType) {
-	case DMA_MEM_TYPE_VMALLOC:
-		{
-			atomic_inc(&gDmaStatMemTypeVmalloc);
-
-			/* printk(KERN_ERR "%s: vmalloc'd pages are not supported\n", __func__); */
-
-			/* vmalloc'd pages are not physically contiguous */
-
-			rc = -EINVAL;
-			break;
-		}
-
-	case DMA_MEM_TYPE_KMALLOC:
-		{
-			atomic_inc(&gDmaStatMemTypeKmalloc);
-
-			/* kmalloc'd pages are physically contiguous, so they'll have exactly */
-			/* one segment */
-
-#if ALLOW_MAP_OF_KMALLOC_MEMORY
-			physAddr =
-			    dma_map_single(NULL, mem, numBytes, memMap->dir);
-			rc = dma_map_add_segment(memMap, region, mem, physAddr,
-						 numBytes);
-#else
-			rc = -EINVAL;
-#endif
-			break;
-		}
-
-	case DMA_MEM_TYPE_DMA:
-		{
-			/* dma_alloc_xxx pages are physically contiguous */
-
-			atomic_inc(&gDmaStatMemTypeCoherent);
-
-			physAddr = (vmalloc_to_pfn(mem) << PAGE_SHIFT) + offset;
-
-			dma_sync_single_for_cpu(NULL, physAddr, numBytes,
-						memMap->dir);
-			rc = dma_map_add_segment(memMap, region, mem, physAddr,
-						 numBytes);
-			break;
-		}
-
-	case DMA_MEM_TYPE_USER:
-		{
-			size_t firstPageOffset;
-			size_t firstPageSize;
-			struct page **pages;
-			struct task_struct *userTask;
-
-			atomic_inc(&gDmaStatMemTypeUser);
-
-#if 1
-			/* If the pages are user pages, then the dma_mem_map_set_user_task function */
-			/* must have been previously called. */
-
-			if (memMap->userTask == NULL) {
-				printk(KERN_ERR
-				       "%s: must call dma_mem_map_set_user_task when using user-mode memory\n",
-				       __func__);
-				return -EINVAL;
-			}
-
-			/* User pages need to be locked. */
-
-			firstPageOffset =
-			    (unsigned long)region->virtAddr & (PAGE_SIZE - 1);
-			firstPageSize = PAGE_SIZE - firstPageOffset;
-
-			region->numLockedPages = (firstPageOffset
-						  + region->numBytes +
-						  PAGE_SIZE - 1) / PAGE_SIZE;
-			pages =
-			    kmalloc(region->numLockedPages *
-				    sizeof(struct page *), GFP_KERNEL);
-
-			if (pages == NULL) {
-				region->numLockedPages = 0;
-				return -ENOMEM;
-			}
-
-			userTask = memMap->userTask;
-
-			down_read(&userTask->mm->mmap_sem);
-			rc = get_user_pages(userTask,	/* task */
-					    userTask->mm,	/* mm */
-					    (unsigned long)region->virtAddr,	/* start */
-					    region->numLockedPages,	/* len */
-					    memMap->dir == DMA_FROM_DEVICE,	/* write */
-					    0,	/* force */
-					    pages,	/* pages (array of pointers to page) */
-					    NULL);	/* vmas */
-			up_read(&userTask->mm->mmap_sem);
-
-			if (rc != region->numLockedPages) {
-				kfree(pages);
-				region->numLockedPages = 0;
-
-				if (rc >= 0) {
-					rc = -EINVAL;
-				}
-			} else {
-				uint8_t *virtAddr = region->virtAddr;
-				size_t bytesRemaining;
-				int pageIdx;
-
-				rc = 0;	/* Since get_user_pages returns +ve number */
-
-				region->lockedPages = pages;
-
-				/* We've locked the user pages. Now we need to walk them and figure */
-				/* out the physical addresses. */
-
-				/* The first page may be partial */
-
-				dma_map_add_segment(memMap,
-						    region,
-						    virtAddr,
-						    PFN_PHYS(page_to_pfn
-							     (pages[0])) +
-						    firstPageOffset,
-						    firstPageSize);
-
-				virtAddr += firstPageSize;
-				bytesRemaining =
-				    region->numBytes - firstPageSize;
-
-				for (pageIdx = 1;
-				     pageIdx < region->numLockedPages;
-				     pageIdx++) {
-					size_t bytesThisPage =
-					    (bytesRemaining >
-					     PAGE_SIZE ? PAGE_SIZE :
-					     bytesRemaining);
-
-					DMA_MAP_PRINT
-					    ("pageIdx:%d pages[pageIdx]=%p pfn=%u phys=%u\n",
-					     pageIdx, pages[pageIdx],
-					     page_to_pfn(pages[pageIdx]),
-					     PFN_PHYS(page_to_pfn
-						      (pages[pageIdx])));
-
-					dma_map_add_segment(memMap,
-							    region,
-							    virtAddr,
-							    PFN_PHYS(page_to_pfn
-								     (pages
-								      [pageIdx])),
-							    bytesThisPage);
-
-					virtAddr += bytesThisPage;
-					bytesRemaining -= bytesThisPage;
-				}
-			}
-#else
-			printk(KERN_ERR
-			       "%s: User mode pages are not yet supported\n",
-			       __func__);
-
-			/* user pages are not physically contiguous */
-
-			rc = -EINVAL;
-#endif
-			break;
-		}
-
-	default:
-		{
-			printk(KERN_ERR "%s: Unsupported memory type: %d\n",
-			       __func__, region->memType);
-
-			rc = -EINVAL;
-			break;
-		}
-	}
-
-	if (rc != 0) {
-		memMap->numRegionsUsed--;
-	}
-
-out:
-
-	DMA_MAP_PRINT("returning %d\n", rc);
-
-	up(&memMap->lock);
-
-	return rc;
-}
-
-EXPORT_SYMBOL(dma_map_add_segment);
-
-/****************************************************************************/
-/**
-*   Maps in a memory region such that it can be used for performing a DMA.
-*
-*   @return     0 on success, error code otherwise.
-*/
-/****************************************************************************/
-
-int dma_map_mem(DMA_MemMap_t *memMap,	/* Stores state information about the map */
-		void *mem,	/* Virtual address that we want to get a map of */
-		size_t numBytes,	/* Number of bytes being mapped */
-		enum dma_data_direction dir	/* Direction that the mapping will be going */
-    ) {
-	int rc;
-
-	rc = dma_map_start(memMap, dir);
-	if (rc == 0) {
-		rc = dma_map_add_region(memMap, mem, numBytes);
-		if (rc < 0) {
-			/* Since the add fails, this function will fail, and the caller won't */
-			/* call unmap, so we need to do it here. */
-
-			dma_unmap(memMap, 0);
-		}
-	}
-
-	return rc;
-}
-
-EXPORT_SYMBOL(dma_map_mem);
-
-/****************************************************************************/
-/**
-*   Setup a descriptor ring for a given memory map.
-*
-*   It is assumed that the descriptor ring has already been initialized, and
-*   this routine will only reallocate a new descriptor ring if the existing
-*   one is too small.
-*
-*   @return     0 on success, error code otherwise.
-*/
-/****************************************************************************/
-
-int dma_map_create_descriptor_ring(DMA_Device_t dev,	/* DMA device (where the ring is stored) */
-				   DMA_MemMap_t *memMap,	/* Memory map that will be used */
-				   dma_addr_t devPhysAddr	/* Physical address of device */
-    ) {
-	int rc;
-	int numDescriptors;
-	DMA_DeviceAttribute_t *devAttr;
-	DMA_Region_t *region;
-	DMA_Segment_t *segment;
-	dma_addr_t srcPhysAddr;
-	dma_addr_t dstPhysAddr;
-	int regionIdx;
-	int segmentIdx;
-
-	devAttr = &DMA_gDeviceAttribute[dev];
-
-	down(&memMap->lock);
-
-	/* Figure out how many descriptors we need */
-
-	numDescriptors = 0;
-	for (regionIdx = 0; regionIdx < memMap->numRegionsUsed; regionIdx++) {
-		region = &memMap->region[regionIdx];
-
-		for (segmentIdx = 0; segmentIdx < region->numSegmentsUsed;
-		     segmentIdx++) {
-			segment = &region->segment[segmentIdx];
-
-			if (memMap->dir == DMA_TO_DEVICE) {
-				srcPhysAddr = segment->physAddr;
-				dstPhysAddr = devPhysAddr;
-			} else {
-				srcPhysAddr = devPhysAddr;
-				dstPhysAddr = segment->physAddr;
-			}
-
-			rc =
-			     dma_calculate_descriptor_count(dev, srcPhysAddr,
-							    dstPhysAddr,
-							    segment->
-							    numBytes);
-			if (rc < 0) {
-				printk(KERN_ERR
-				       "%s: dma_calculate_descriptor_count failed: %d\n",
-				       __func__, rc);
-				goto out;
-			}
-			numDescriptors += rc;
-		}
-	}
-
-	/* Adjust the size of the ring, if it isn't big enough */
-
-	if (numDescriptors > devAttr->ring.descriptorsAllocated) {
-		dma_free_descriptor_ring(&devAttr->ring);
-		rc =
-		     dma_alloc_descriptor_ring(&devAttr->ring,
-					       numDescriptors);
-		if (rc < 0) {
-			printk(KERN_ERR
-			       "%s: dma_alloc_descriptor_ring failed: %d\n",
-			       __func__, rc);
-			goto out;
-		}
-	} else {
-		rc =
-		     dma_init_descriptor_ring(&devAttr->ring,
-					      numDescriptors);
-		if (rc < 0) {
-			printk(KERN_ERR
-			       "%s: dma_init_descriptor_ring failed: %d\n",
-			       __func__, rc);
-			goto out;
-		}
-	}
-
-	/* Populate the descriptors */
-
-	for (regionIdx = 0; regionIdx < memMap->numRegionsUsed; regionIdx++) {
-		region = &memMap->region[regionIdx];
-
-		for (segmentIdx = 0; segmentIdx < region->numSegmentsUsed;
-		     segmentIdx++) {
-			segment = &region->segment[segmentIdx];
-
-			if (memMap->dir == DMA_TO_DEVICE) {
-				srcPhysAddr = segment->physAddr;
-				dstPhysAddr = devPhysAddr;
-			} else {
-				srcPhysAddr = devPhysAddr;
-				dstPhysAddr = segment->physAddr;
-			}
-
-			rc =
-			     dma_add_descriptors(&devAttr->ring, dev,
-						 srcPhysAddr, dstPhysAddr,
-						 segment->numBytes);
-			if (rc < 0) {
-				printk(KERN_ERR
-				       "%s: dma_add_descriptors failed: %d\n",
-				       __func__, rc);
-				goto out;
-			}
-		}
-	}
-
-	rc = 0;
-
-out:
-
-	up(&memMap->lock);
-	return rc;
-}
-
-EXPORT_SYMBOL(dma_map_create_descriptor_ring);
-
-/****************************************************************************/
-/**
-*   Maps in a memory region such that it can be used for performing a DMA.
-*
-*   @return
-*/
-/****************************************************************************/
-
-int dma_unmap(DMA_MemMap_t *memMap,	/* Stores state information about the map */
-	      int dirtied	/* non-zero if any of the pages were modified */
-    ) {
-
-	int rc = 0;
-	int regionIdx;
-	int segmentIdx;
-	DMA_Region_t *region;
-	DMA_Segment_t *segment;
-
-	down(&memMap->lock);
-
-	for (regionIdx = 0; regionIdx < memMap->numRegionsUsed; regionIdx++) {
-		region = &memMap->region[regionIdx];
-
-		for (segmentIdx = 0; segmentIdx < region->numSegmentsUsed;
-		     segmentIdx++) {
-			segment = &region->segment[segmentIdx];
-
-			switch (region->memType) {
-			case DMA_MEM_TYPE_VMALLOC:
-				{
-					printk(KERN_ERR
-					       "%s: vmalloc'd pages are not yet supported\n",
-					       __func__);
-					rc = -EINVAL;
-					goto out;
-				}
-
-			case DMA_MEM_TYPE_KMALLOC:
-				{
-#if ALLOW_MAP_OF_KMALLOC_MEMORY
-					dma_unmap_single(NULL,
-							 segment->physAddr,
-							 segment->numBytes,
-							 memMap->dir);
-#endif
-					break;
-				}
-
-			case DMA_MEM_TYPE_DMA:
-				{
-					dma_sync_single_for_cpu(NULL,
-								segment->
-								physAddr,
-								segment->
-								numBytes,
-								memMap->dir);
-					break;
-				}
-
-			case DMA_MEM_TYPE_USER:
-				{
-					/* Nothing to do here. */
-
-					break;
-				}
-
-			default:
-				{
-					printk(KERN_ERR
-					       "%s: Unsupported memory type: %d\n",
-					       __func__, region->memType);
-					rc = -EINVAL;
-					goto out;
-				}
-			}
-
-			segment->virtAddr = NULL;
-			segment->physAddr = 0;
-			segment->numBytes = 0;
-		}
-
-		if (region->numLockedPages > 0) {
-			int pageIdx;
-
-			/* Some user pages were locked. We need to go and unlock them now. */
-
-			for (pageIdx = 0; pageIdx < region->numLockedPages;
-			     pageIdx++) {
-				struct page *page =
-				    region->lockedPages[pageIdx];
-
-				if (memMap->dir == DMA_FROM_DEVICE) {
-					SetPageDirty(page);
-				}
-				page_cache_release(page);
-			}
-			kfree(region->lockedPages);
-			region->numLockedPages = 0;
-			region->lockedPages = NULL;
-		}
-
-		region->memType = DMA_MEM_TYPE_NONE;
-		region->virtAddr = NULL;
-		region->numBytes = 0;
-		region->numSegmentsUsed = 0;
-	}
-	memMap->userTask = NULL;
-	memMap->numRegionsUsed = 0;
-	memMap->inUse = 0;
-
-out:
-	up(&memMap->lock);
-
-	return rc;
-}
-
-EXPORT_SYMBOL(dma_unmap);
diff -Naur linux-3.3-rc2/arch/arm/mach-bcmring/include/mach/dma.h wm8505-3.3rc2/arch/arm/mach-bcmring/include/mach/dma.h
--- linux-3.3-rc2/arch/arm/mach-bcmring/include/mach/dma.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-bcmring/include/mach/dma.h	2012-02-06 12:27:43.000000000 -0700
@@ -26,15 +26,9 @@
 /* ---- Include Files ---------------------------------------------------- */
 
 #include <linux/kernel.h>
-#include <linux/wait.h>
 #include <linux/semaphore.h>
 #include <csp/dmacHw.h>
 #include <mach/timer.h>
-#include <linux/scatterlist.h>
-#include <linux/dma-mapping.h>
-#include <linux/mm.h>
-#include <linux/vmalloc.h>
-#include <linux/pagemap.h>
 
 /* ---- Constants and Types ---------------------------------------------- */
 
@@ -113,78 +107,6 @@
 
 /****************************************************************************
 *
-*   The DMA_MemType_t and DMA_MemMap_t are helper structures used to setup
-*   DMA chains from a variety of memory sources.
-*
-*****************************************************************************/
-
-#define DMA_MEM_MAP_MIN_SIZE    4096	/* Pages less than this size are better */
-					/* off not being DMA'd. */
-
-typedef enum {
-	DMA_MEM_TYPE_NONE,	/* Not a valid setting */
-	DMA_MEM_TYPE_VMALLOC,	/* Memory came from vmalloc call */
-	DMA_MEM_TYPE_KMALLOC,	/* Memory came from kmalloc call */
-	DMA_MEM_TYPE_DMA,	/* Memory came from dma_alloc_xxx call */
-	DMA_MEM_TYPE_USER,	/* Memory came from user space. */
-
-} DMA_MemType_t;
-
-/* A segment represents a physically and virtually contiguous chunk of memory. */
-/* i.e. each segment can be DMA'd */
-/* A user of the DMA code will add memory regions. Each region may need to be */
-/* represented by one or more segments. */
-
-typedef struct {
-	void *virtAddr;		/* Virtual address used for this segment */
-	dma_addr_t physAddr;	/* Physical address this segment maps to */
-	size_t numBytes;	/* Size of the segment, in bytes */
-
-} DMA_Segment_t;
-
-/* A region represents a virtually contiguous chunk of memory, which may be */
-/* made up of multiple segments. */
-
-typedef struct {
-	DMA_MemType_t memType;
-	void *virtAddr;
-	size_t numBytes;
-
-	/* Each region (virtually contiguous) consists of one or more segments. Each */
-	/* segment is virtually and physically contiguous. */
-
-	int numSegmentsUsed;
-	int numSegmentsAllocated;
-	DMA_Segment_t *segment;
-
-	/* When a region corresponds to user memory, we need to lock all of the pages */
-	/* down before we can figure out the physical addresses. The lockedPage array contains */
-	/* the pages that were locked, and which subsequently need to be unlocked once the */
-	/* memory is unmapped. */
-
-	unsigned numLockedPages;
-	struct page **lockedPages;
-
-} DMA_Region_t;
-
-typedef struct {
-	int inUse;		/* Is this mapping currently being used? */
-	struct semaphore lock;	/* Acquired when using this structure */
-	enum dma_data_direction dir;	/* Direction this transfer is intended for */
-
-	/* In the event that we're mapping user memory, we need to know which task */
-	/* the memory is for, so that we can obtain the correct mm locks. */
-
-	struct task_struct *userTask;
-
-	int numRegionsUsed;
-	int numRegionsAllocated;
-	DMA_Region_t *region;
-
-} DMA_MemMap_t;
-
-/****************************************************************************
-*
 *   The DMA_DeviceAttribute_t contains information which describes a
 *   particular DMA device (or peripheral).
 *
@@ -569,124 +491,6 @@
     );
 
 /****************************************************************************/
-/**
-*   Initializes a DMA_MemMap_t data structure
-*/
-/****************************************************************************/
-
-int dma_init_mem_map(DMA_MemMap_t *memMap	/* Stores state information about the map */
-    );
-
-/****************************************************************************/
-/**
-*   Releases any memory currently being held by a memory mapping structure.
-*/
-/****************************************************************************/
-
-int dma_term_mem_map(DMA_MemMap_t *memMap	/* Stores state information about the map */
-    );
-
-/****************************************************************************/
-/**
-*   Looks at a memory address and categorizes it.
-*
-*   @return One of the values from the DMA_MemType_t enumeration.
-*/
-/****************************************************************************/
-
-DMA_MemType_t dma_mem_type(void *addr);
-
-/****************************************************************************/
-/**
-*   Sets the process (aka userTask) associated with a mem map. This is
-*   required if user-mode segments will be added to the mapping.
-*/
-/****************************************************************************/
-
-static inline void dma_mem_map_set_user_task(DMA_MemMap_t *memMap,
-					     struct task_struct *task)
-{
-	memMap->userTask = task;
-}
-
-/****************************************************************************/
-/**
-*   Looks at a memory address and determines if we support DMA'ing to/from
-*   that type of memory.
-*
-*   @return boolean -
-*               return value != 0 means dma supported
-*               return value == 0 means dma not supported
-*/
-/****************************************************************************/
-
-int dma_mem_supports_dma(void *addr);
-
-/****************************************************************************/
-/**
-*   Initializes a memory map for use. Since this function acquires a
-*   sempaphore within the memory map, it is VERY important that dma_unmap
-*   be called when you're finished using the map.
-*/
-/****************************************************************************/
-
-int dma_map_start(DMA_MemMap_t *memMap,	/* Stores state information about the map */
-		  enum dma_data_direction dir	/* Direction that the mapping will be going */
-    );
-
-/****************************************************************************/
-/**
-*   Adds a segment of memory to a memory map.
-*
-*   @return     0 on success, error code otherwise.
-*/
-/****************************************************************************/
-
-int dma_map_add_region(DMA_MemMap_t *memMap,	/* Stores state information about the map */
-		       void *mem,	/* Virtual address that we want to get a map of */
-		       size_t numBytes	/* Number of bytes being mapped */
-    );
-
-/****************************************************************************/
-/**
-*   Creates a descriptor ring from a memory mapping.
-*
-*   @return 0 on success, error code otherwise.
-*/
-/****************************************************************************/
-
-int dma_map_create_descriptor_ring(DMA_Device_t dev,	/* DMA device (where the ring is stored) */
-				   DMA_MemMap_t *memMap,	/* Memory map that will be used */
-				   dma_addr_t devPhysAddr	/* Physical address of device */
-    );
-
-/****************************************************************************/
-/**
-*   Maps in a memory region such that it can be used for performing a DMA.
-*
-*   @return
-*/
-/****************************************************************************/
-
-int dma_map_mem(DMA_MemMap_t *memMap,	/* Stores state information about the map */
-		void *addr,	/* Virtual address that we want to get a map of */
-		size_t count,	/* Number of bytes being mapped */
-		enum dma_data_direction dir	/* Direction that the mapping will be going */
-    );
-
-/****************************************************************************/
-/**
-*   Maps in a memory region such that it can be used for performing a DMA.
-*
-*   @return
-*/
-/****************************************************************************/
-
-int dma_unmap(DMA_MemMap_t *memMap,	/* Stores state information about the map */
-	      int dirtied	/* non-zero if any of the pages were modified */
-    );
-
-/****************************************************************************/
 /**
 *   Initiates a transfer when the descriptors have already been setup.
 *
diff -Naur linux-3.3-rc2/arch/arm/mach-davinci/board-da850-evm.c wm8505-3.3rc2/arch/arm/mach-davinci/board-da850-evm.c
--- linux-3.3-rc2/arch/arm/mach-davinci/board-da850-evm.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-davinci/board-da850-evm.c	2012-02-06 12:27:43.000000000 -0700
@@ -44,7 +44,7 @@
 #include <mach/aemif.h>
 #include <mach/spi.h>
 
-#define DA850_EVM_PHY_ID		"0:00"
+#define DA850_EVM_PHY_ID		"davinci_mdio-0:00"
 #define DA850_LCD_PWR_PIN		GPIO_TO_PIN(2, 8)
 #define DA850_LCD_BL_PIN		GPIO_TO_PIN(2, 15)
 
diff -Naur linux-3.3-rc2/arch/arm/mach-davinci/board-dm365-evm.c wm8505-3.3rc2/arch/arm/mach-davinci/board-dm365-evm.c
--- linux-3.3-rc2/arch/arm/mach-davinci/board-dm365-evm.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-davinci/board-dm365-evm.c	2012-02-06 12:27:43.000000000 -0700
@@ -54,7 +54,7 @@
 	return 0;
 }
 
-#define DM365_EVM_PHY_ID		"0:01"
+#define DM365_EVM_PHY_ID		"davinci_mdio-0:01"
 /*
  * A MAX-II CPLD is used for various board control functions.
  */
diff -Naur linux-3.3-rc2/arch/arm/mach-davinci/board-dm644x-evm.c wm8505-3.3rc2/arch/arm/mach-davinci/board-dm644x-evm.c
--- linux-3.3-rc2/arch/arm/mach-davinci/board-dm644x-evm.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-davinci/board-dm644x-evm.c	2012-02-06 12:27:43.000000000 -0700
@@ -40,7 +40,7 @@
 #include <mach/usb.h>
 #include <mach/aemif.h>
 
-#define DM644X_EVM_PHY_ID		"0:01"
+#define DM644X_EVM_PHY_ID		"davinci_mdio-0:01"
 #define LXT971_PHY_ID	(0x001378e2)
 #define LXT971_PHY_MASK	(0xfffffff0)
 
diff -Naur linux-3.3-rc2/arch/arm/mach-davinci/board-dm646x-evm.c wm8505-3.3rc2/arch/arm/mach-davinci/board-dm646x-evm.c
--- linux-3.3-rc2/arch/arm/mach-davinci/board-dm646x-evm.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-davinci/board-dm646x-evm.c	2012-02-06 12:27:43.000000000 -0700
@@ -736,7 +736,7 @@
 	.enabled_uarts = (1 << 0),
 };
 
-#define DM646X_EVM_PHY_ID		"0:01"
+#define DM646X_EVM_PHY_ID		"davinci_mdio-0:01"
 /*
  * The following EDMA channels/slots are not being used by drivers (for
  * example: Timer, GPIO, UART events etc) on dm646x, hence they are being
diff -Naur linux-3.3-rc2/arch/arm/mach-davinci/board-neuros-osd2.c wm8505-3.3rc2/arch/arm/mach-davinci/board-neuros-osd2.c
--- linux-3.3-rc2/arch/arm/mach-davinci/board-neuros-osd2.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-davinci/board-neuros-osd2.c	2012-02-06 12:27:43.000000000 -0700
@@ -39,7 +39,7 @@
 #include <mach/mmc.h>
 #include <mach/usb.h>
 
-#define NEUROS_OSD2_PHY_ID		"0:01"
+#define NEUROS_OSD2_PHY_ID		"davinci_mdio-0:01"
 #define LXT971_PHY_ID			0x001378e2
 #define LXT971_PHY_MASK			0xfffffff0
 
diff -Naur linux-3.3-rc2/arch/arm/mach-davinci/board-omapl138-hawk.c wm8505-3.3rc2/arch/arm/mach-davinci/board-omapl138-hawk.c
--- linux-3.3-rc2/arch/arm/mach-davinci/board-omapl138-hawk.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-davinci/board-omapl138-hawk.c	2012-02-06 12:27:43.000000000 -0700
@@ -21,7 +21,7 @@
 #include <mach/da8xx.h>
 #include <mach/mux.h>
 
-#define HAWKBOARD_PHY_ID		"0:07"
+#define HAWKBOARD_PHY_ID		"davinci_mdio-0:07"
 #define DA850_HAWK_MMCSD_CD_PIN		GPIO_TO_PIN(3, 12)
 #define DA850_HAWK_MMCSD_WP_PIN		GPIO_TO_PIN(3, 13)
 
diff -Naur linux-3.3-rc2/arch/arm/mach-davinci/board-sffsdr.c wm8505-3.3rc2/arch/arm/mach-davinci/board-sffsdr.c
--- linux-3.3-rc2/arch/arm/mach-davinci/board-sffsdr.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-davinci/board-sffsdr.c	2012-02-06 12:27:43.000000000 -0700
@@ -42,7 +42,7 @@
 #include <mach/mux.h>
 #include <mach/usb.h>
 
-#define SFFSDR_PHY_ID		"0:01"
+#define SFFSDR_PHY_ID		"davinci_mdio-0:01"
 static struct mtd_partition davinci_sffsdr_nandflash_partition[] = {
 	/* U-Boot Environment: Block 0
 	 * UBL:                Block 1
diff -Naur linux-3.3-rc2/arch/arm/mach-davinci/da850.c wm8505-3.3rc2/arch/arm/mach-davinci/da850.c
--- linux-3.3-rc2/arch/arm/mach-davinci/da850.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-davinci/da850.c	2012-02-06 12:27:43.000000000 -0700
@@ -153,34 +153,6 @@
 	.div_reg	= PLLDIV3,
 };
 
-static struct clk pll1_sysclk4 = {
-	.name		= "pll1_sysclk4",
-	.parent		= &pll1_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV4,
-};
-
-static struct clk pll1_sysclk5 = {
-	.name		= "pll1_sysclk5",
-	.parent		= &pll1_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV5,
-};
-
-static struct clk pll1_sysclk6 = {
-	.name		= "pll0_sysclk6",
-	.parent		= &pll0_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV6,
-};
-
-static struct clk pll1_sysclk7 = {
-	.name		= "pll1_sysclk7",
-	.parent		= &pll1_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV7,
-};
-
 static struct clk i2c0_clk = {
 	.name		= "i2c0",
 	.parent		= &pll0_aux_clk,
@@ -397,10 +369,6 @@
 	CLK(NULL,		"pll1_aux",	&pll1_aux_clk),
 	CLK(NULL,		"pll1_sysclk2",	&pll1_sysclk2),
 	CLK(NULL,		"pll1_sysclk3",	&pll1_sysclk3),
-	CLK(NULL,		"pll1_sysclk4",	&pll1_sysclk4),
-	CLK(NULL,		"pll1_sysclk5",	&pll1_sysclk5),
-	CLK(NULL,		"pll1_sysclk6",	&pll1_sysclk6),
-	CLK(NULL,		"pll1_sysclk7",	&pll1_sysclk7),
 	CLK("i2c_davinci.1",	NULL,		&i2c0_clk),
 	CLK(NULL,		"timer0",	&timerp64_0_clk),
 	CLK("watchdog",		NULL,		&timerp64_1_clk),
diff -Naur linux-3.3-rc2/arch/arm/mach-omap2/devices.c wm8505-3.3rc2/arch/arm/mach-omap2/devices.c
--- linux-3.3-rc2/arch/arm/mach-omap2/devices.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-omap2/devices.c	2012-02-06 12:27:43.000000000 -0700
@@ -405,6 +405,7 @@
 			break;
 	default:
 			pr_err("Invalid McSPI Revision value\n");
+			kfree(pdata);
 			return -EINVAL;
 	}
 
diff -Naur linux-3.3-rc2/arch/arm/mach-omap2/gpmc.c wm8505-3.3rc2/arch/arm/mach-omap2/gpmc.c
--- linux-3.3-rc2/arch/arm/mach-omap2/gpmc.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-omap2/gpmc.c	2012-02-06 12:27:43.000000000 -0700
@@ -528,7 +528,13 @@
 
 	case GPMC_CONFIG_DEV_SIZE:
 		regval  = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
+
+		/* clear 2 target bits */
+		regval &= ~GPMC_CONFIG1_DEVICESIZE(3);
+
+		/* set the proper value */
 		regval |= GPMC_CONFIG1_DEVICESIZE(wval);
+
 		gpmc_cs_write_reg(cs, GPMC_CS_CONFIG1, regval);
 		break;
 
diff -Naur linux-3.3-rc2/arch/arm/mach-omap2/hsmmc.c wm8505-3.3rc2/arch/arm/mach-omap2/hsmmc.c
--- linux-3.3-rc2/arch/arm/mach-omap2/hsmmc.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-omap2/hsmmc.c	2012-02-06 12:27:43.000000000 -0700
@@ -175,14 +175,15 @@
 {
 	u32 reg;
 
-	if (mmc->slots[0].internal_clock) {
-		reg = omap_ctrl_readl(control_devconf1_offset);
+	reg = omap_ctrl_readl(control_devconf1_offset);
+	if (mmc->slots[0].internal_clock)
 		reg |= OMAP2_MMCSDIO2ADPCLKISEL;
-		omap_ctrl_writel(reg, control_devconf1_offset);
-	}
+	else
+		reg &= ~OMAP2_MMCSDIO2ADPCLKISEL;
+	omap_ctrl_writel(reg, control_devconf1_offset);
 }
 
-static void hsmmc23_before_set_reg(struct device *dev, int slot,
+static void hsmmc2_before_set_reg(struct device *dev, int slot,
 				   int power_on, int vdd)
 {
 	struct omap_mmc_platform_data *mmc = dev->platform_data;
@@ -407,14 +408,13 @@
 			c->caps &= ~MMC_CAP_8_BIT_DATA;
 			c->caps |= MMC_CAP_4_BIT_DATA;
 		}
-		/* FALLTHROUGH */
-	case 3:
 		if (mmc->slots[0].features & HSMMC_HAS_PBIAS) {
 			/* off-chip level shifting, or none */
-			mmc->slots[0].before_set_reg = hsmmc23_before_set_reg;
+			mmc->slots[0].before_set_reg = hsmmc2_before_set_reg;
 			mmc->slots[0].after_set_reg = NULL;
 		}
 		break;
+	case 3:
 	case 4:
 	case 5:
 		mmc->slots[0].before_set_reg = NULL;
diff -Naur linux-3.3-rc2/arch/arm/mach-omap2/io.c wm8505-3.3rc2/arch/arm/mach-omap2/io.c
--- linux-3.3-rc2/arch/arm/mach-omap2/io.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-omap2/io.c	2012-02-06 12:27:43.000000000 -0700
@@ -388,7 +388,7 @@
 	omap_pm_if_early_init();
 }
 
-#ifdef CONFIG_ARCH_OMAP2
+#ifdef CONFIG_SOC_OMAP2420
 void __init omap2420_init_early(void)
 {
 	omap2_set_globals_242x();
@@ -400,7 +400,9 @@
 	omap_hwmod_init_postsetup();
 	omap2420_clk_init();
 }
+#endif
 
+#ifdef CONFIG_SOC_OMAP2430
 void __init omap2430_init_early(void)
 {
 	omap2_set_globals_243x();
diff -Naur linux-3.3-rc2/arch/arm/mach-omap2/Kconfig wm8505-3.3rc2/arch/arm/mach-omap2/Kconfig
--- linux-3.3-rc2/arch/arm/mach-omap2/Kconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-omap2/Kconfig	2012-02-06 12:27:43.000000000 -0700
@@ -213,13 +213,12 @@
 	depends on ARCH_OMAP3
 	default y
 	select OMAP_PACKAGE_CBB
-	select REGULATOR_FIXED_VOLTAGE
+	select REGULATOR_FIXED_VOLTAGE if REGULATOR
 
 config MACH_OMAP3_TOUCHBOOK
 	bool "OMAP3 Touch Book"
 	depends on ARCH_OMAP3
 	default y
-	select BACKLIGHT_CLASS_DEVICE
 
 config MACH_OMAP_3430SDP
 	bool "OMAP 3430 SDP board"
@@ -265,7 +264,7 @@
 	select SERIAL_8250
 	select SERIAL_CORE_CONSOLE
 	select SERIAL_8250_CONSOLE
-	select REGULATOR_FIXED_VOLTAGE
+	select REGULATOR_FIXED_VOLTAGE if REGULATOR
 
 config MACH_OMAP_ZOOM3
 	bool "OMAP3630 Zoom3 board"
@@ -275,7 +274,7 @@
 	select SERIAL_8250
 	select SERIAL_CORE_CONSOLE
 	select SERIAL_8250_CONSOLE
-	select REGULATOR_FIXED_VOLTAGE
+	select REGULATOR_FIXED_VOLTAGE if REGULATOR
 
 config MACH_CM_T35
 	bool "CompuLab CM-T35/CM-T3730 modules"
@@ -334,7 +333,7 @@
 	depends on ARCH_OMAP4
 	select OMAP_PACKAGE_CBL
 	select OMAP_PACKAGE_CBS
-	select REGULATOR_FIXED_VOLTAGE
+	select REGULATOR_FIXED_VOLTAGE if REGULATOR
 
 config MACH_OMAP4_PANDA
 	bool "OMAP4 Panda Board"
@@ -342,7 +341,7 @@
 	depends on ARCH_OMAP4
 	select OMAP_PACKAGE_CBL
 	select OMAP_PACKAGE_CBS
-	select REGULATOR_FIXED_VOLTAGE
+	select REGULATOR_FIXED_VOLTAGE if REGULATOR
 
 config OMAP3_EMU
 	bool "OMAP3 debugging peripherals"
diff -Naur linux-3.3-rc2/arch/arm/mach-omap2/omap_hwmod_2xxx_3xxx_ipblock_data.c wm8505-3.3rc2/arch/arm/mach-omap2/omap_hwmod_2xxx_3xxx_ipblock_data.c
--- linux-3.3-rc2/arch/arm/mach-omap2/omap_hwmod_2xxx_3xxx_ipblock_data.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-omap2/omap_hwmod_2xxx_3xxx_ipblock_data.c	2012-02-06 12:27:43.000000000 -0700
@@ -56,27 +56,6 @@
 };
 
 /*
- * 'dispc' class
- * display controller
- */
-
-static struct omap_hwmod_class_sysconfig omap2_dispc_sysc = {
-	.rev_offs	= 0x0000,
-	.sysc_offs	= 0x0010,
-	.syss_offs	= 0x0014,
-	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_MIDLEMODE |
-			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
-	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
-			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
-	.sysc_fields	= &omap_hwmod_sysc_type1,
-};
-
-struct omap_hwmod_class omap2_dispc_hwmod_class = {
-	.name	= "dispc",
-	.sysc	= &omap2_dispc_sysc,
-};
-
-/*
  * 'rfbi' class
  * remote frame buffer interface
  */
diff -Naur linux-3.3-rc2/arch/arm/mach-omap2/omap_hwmod_2xxx_ipblock_data.c wm8505-3.3rc2/arch/arm/mach-omap2/omap_hwmod_2xxx_ipblock_data.c
--- linux-3.3-rc2/arch/arm/mach-omap2/omap_hwmod_2xxx_ipblock_data.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-omap2/omap_hwmod_2xxx_ipblock_data.c	2012-02-06 12:27:43.000000000 -0700
@@ -28,6 +28,28 @@
 	{ .name = "dispc", .dma_req = 5 },
 	{ .dma_req = -1 }
 };
+
+/*
+ * 'dispc' class
+ * display controller
+ */
+
+static struct omap_hwmod_class_sysconfig omap2_dispc_sysc = {
+	.rev_offs	= 0x0000,
+	.sysc_offs	= 0x0010,
+	.syss_offs	= 0x0014,
+	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_MIDLEMODE |
+			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
+	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
+	.sysc_fields	= &omap_hwmod_sysc_type1,
+};
+
+struct omap_hwmod_class omap2_dispc_hwmod_class = {
+	.name	= "dispc",
+	.sysc	= &omap2_dispc_sysc,
+};
+
 /* OMAP2xxx Timer Common */
 static struct omap_hwmod_class_sysconfig omap2xxx_timer_sysc = {
 	.rev_offs	= 0x0000,
diff -Naur linux-3.3-rc2/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c wm8505-3.3rc2/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c
--- linux-3.3-rc2/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c	2012-02-06 12:27:43.000000000 -0700
@@ -1480,6 +1480,28 @@
 	.masters_cnt	= ARRAY_SIZE(omap3xxx_dss_masters),
 };
 
+/*
+ * 'dispc' class
+ * display controller
+ */
+
+static struct omap_hwmod_class_sysconfig omap3_dispc_sysc = {
+	.rev_offs	= 0x0000,
+	.sysc_offs	= 0x0010,
+	.syss_offs	= 0x0014,
+	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_MIDLEMODE |
+			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE |
+			   SYSC_HAS_ENAWAKEUP),
+	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
+	.sysc_fields	= &omap_hwmod_sysc_type1,
+};
+
+static struct omap_hwmod_class omap3_dispc_hwmod_class = {
+	.name	= "dispc",
+	.sysc	= &omap3_dispc_sysc,
+};
+
 /* l4_core -> dss_dispc */
 static struct omap_hwmod_ocp_if omap3xxx_l4_core__dss_dispc = {
 	.master		= &omap3xxx_l4_core_hwmod,
@@ -1503,7 +1525,7 @@
 
 static struct omap_hwmod omap3xxx_dss_dispc_hwmod = {
 	.name		= "dss_dispc",
-	.class		= &omap2_dispc_hwmod_class,
+	.class		= &omap3_dispc_hwmod_class,
 	.mpu_irqs	= omap2_dispc_irqs,
 	.main_clk	= "dss1_alwon_fck",
 	.prcm		= {
@@ -3523,12 +3545,6 @@
 	&omap3xxx_uart2_hwmod,
 	&omap3xxx_uart3_hwmod,
 
-	/* dss class */
-	&omap3xxx_dss_dispc_hwmod,
-	&omap3xxx_dss_dsi1_hwmod,
-	&omap3xxx_dss_rfbi_hwmod,
-	&omap3xxx_dss_venc_hwmod,
-
 	/* i2c class */
 	&omap3xxx_i2c1_hwmod,
 	&omap3xxx_i2c2_hwmod,
@@ -3635,6 +3651,15 @@
 	NULL
 };
 
+static __initdata struct omap_hwmod *omap3xxx_dss_hwmods[] = {
+	/* dss class */
+	&omap3xxx_dss_dispc_hwmod,
+	&omap3xxx_dss_dsi1_hwmod,
+	&omap3xxx_dss_rfbi_hwmod,
+	&omap3xxx_dss_venc_hwmod,
+	NULL
+};
+
 int __init omap3xxx_hwmod_init(void)
 {
 	int r;
@@ -3708,6 +3733,21 @@
 
 	if (h)
 		r = omap_hwmod_register(h);
+	if (r < 0)
+		return r;
+
+	/*
+	 * DSS code presumes that dss_core hwmod is handled first,
+	 * _before_ any other DSS related hwmods so register common
+	 * DSS hwmods last to ensure that dss_core is already registered.
+	 * Otherwise some change things may happen, for ex. if dispc
+	 * is handled before dss_core and DSS is enabled in bootloader
+	 * DIPSC will be reset with outputs enabled which sometimes leads
+	 * to unrecoverable L3 error.
+	 * XXX The long-term fix to this is to ensure modules are set up
+	 * in dependency order in the hwmod core code.
+	 */
+	r = omap_hwmod_register(omap3xxx_dss_hwmods);
 
 	return r;
 }
diff -Naur linux-3.3-rc2/arch/arm/mach-omap2/omap_hwmod_44xx_data.c wm8505-3.3rc2/arch/arm/mach-omap2/omap_hwmod_44xx_data.c
--- linux-3.3-rc2/arch/arm/mach-omap2/omap_hwmod_44xx_data.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-omap2/omap_hwmod_44xx_data.c	2012-02-06 12:27:43.000000000 -0700
@@ -1031,6 +1031,7 @@
 
 static struct omap_hwmod_addr_space omap44xx_dmic_addrs[] = {
 	{
+		.name		= "mpu",
 		.pa_start	= 0x4012e000,
 		.pa_end		= 0x4012e07f,
 		.flags		= ADDR_TYPE_RT
@@ -1049,6 +1050,7 @@
 
 static struct omap_hwmod_addr_space omap44xx_dmic_dma_addrs[] = {
 	{
+		.name		= "dma",
 		.pa_start	= 0x4902e000,
 		.pa_end		= 0x4902e07f,
 		.flags		= ADDR_TYPE_RT
diff -Naur linux-3.3-rc2/arch/arm/mach-omap2/prm2xxx_3xxx.c wm8505-3.3rc2/arch/arm/mach-omap2/prm2xxx_3xxx.c
--- linux-3.3-rc2/arch/arm/mach-omap2/prm2xxx_3xxx.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-omap2/prm2xxx_3xxx.c	2012-02-06 12:27:43.000000000 -0700
@@ -19,6 +19,7 @@
 #include "common.h"
 #include <plat/cpu.h>
 #include <plat/prcm.h>
+#include <plat/irqs.h>
 
 #include "vp.h"
 
diff -Naur linux-3.3-rc2/arch/arm/mach-omap2/smartreflex.c wm8505-3.3rc2/arch/arm/mach-omap2/smartreflex.c
--- linux-3.3-rc2/arch/arm/mach-omap2/smartreflex.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-omap2/smartreflex.c	2012-02-06 12:27:43.000000000 -0700
@@ -897,7 +897,7 @@
 		ret = sr_late_init(sr_info);
 		if (ret) {
 			pr_warning("%s: Error in SR late init\n", __func__);
-			return ret;
+			goto err_iounmap;
 		}
 	}
 
diff -Naur linux-3.3-rc2/arch/arm/mach-omap2/timer.c wm8505-3.3rc2/arch/arm/mach-omap2/timer.c
--- linux-3.3-rc2/arch/arm/mach-omap2/timer.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-omap2/timer.c	2012-02-06 12:27:43.000000000 -0700
@@ -270,7 +270,7 @@
 static u32 notrace dmtimer_read_sched_clock(void)
 {
 	if (clksrc.reserved)
-		return __omap_dm_timer_read_counter(clksrc.io_base, 1);
+		return __omap_dm_timer_read_counter(&clksrc, 1);
 
 	return 0;
 }
diff -Naur linux-3.3-rc2/arch/arm/mach-shmobile/setup-sh7372.c wm8505-3.3rc2/arch/arm/mach-shmobile/setup-sh7372.c
--- linux-3.3-rc2/arch/arm/mach-shmobile/setup-sh7372.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-shmobile/setup-sh7372.c	2012-02-06 12:27:43.000000000 -0700
@@ -662,6 +662,7 @@
 	.dmaor_is_32bit	= 1,
 	.needs_tend_set	= 1,
 	.no_dmars	= 1,
+	.slave_only	= 1,
 };
 
 static struct resource sh7372_usb_dmae0_resources[] = {
@@ -723,6 +724,7 @@
 	.dmaor_is_32bit	= 1,
 	.needs_tend_set	= 1,
 	.no_dmars	= 1,
+	.slave_only	= 1,
 };
 
 static struct resource sh7372_usb_dmae1_resources[] = {
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/bv07.c wm8505-3.3rc2/arch/arm/mach-vt8500/bv07.c
--- linux-3.3-rc2/arch/arm/mach-vt8500/bv07.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/bv07.c	2012-02-06 12:27:43.000000000 -0700
@@ -32,10 +32,13 @@
 	&vt8500_device_uart0,
 	&vt8500_device_lcdc,
 	&vt8500_device_ehci,
+	&vt8500_device_rhine0,
 	&vt8500_device_ge_rops,
 	&vt8500_device_pwm,
 	&vt8500_device_pwmbl,
 	&vt8500_device_rtc,
+	&vt8500_device_sdmmc,
+	&vt8500_device_nand,
 };
 
 static void vt8500_power_off(void)
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/devices.c wm8505-3.3rc2/arch/arm/mach-vt8500/devices.c
--- linux-3.3-rc2/arch/arm/mach-vt8500/devices.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/devices.c	2012-02-06 12:27:43.000000000 -0700
@@ -134,6 +134,24 @@
 	},
 },
 #endif
+#ifdef CONFIG_WMT_PANEL_1024X768
+{
+	.xres_virtual	= 1024,
+	.yres_virtual	= 768 * 2,
+	.mode		= {
+		.name		= "1024x768",
+		.xres		= 1024,
+		.yres		= 768,
+		.left_margin	= 74,
+		.right_margin	= 255,
+		.upper_margin	= 7,
+		.lower_margin	= 33,
+		.hsync_len	= 34,
+		.vsync_len	= 6,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+},
+#endif
 };
 
 static int current_panel_idx __initdata = ARRAY_SIZE(panels) - 1;
@@ -204,6 +222,17 @@
 	},
 };
 
+static u64 uhci_dma_mask = DMA_BIT_MASK(32);
+
+struct platform_device vt8500_device_uhci = {
+	.name		= "vt8500-uhci",
+	.id		= 0,
+	.dev		= {
+		.dma_mask	= &uhci_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
 struct platform_device vt8500_device_ge_rops = {
 	.name		= "wmt_ge_rops",
 	.id		= -1,
@@ -234,6 +263,61 @@
 	.id		= 0,
 };
 
+static u64 sdmmc_dma_mask = DMA_BIT_MASK(32);
+
+struct platform_device vt8500_device_sdmmc = {
+	.name		= "wmt-sdmmc",
+	.id		= 0,
+	.dev		= {
+		.dma_mask	= &sdmmc_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
+static u64 velocity_dma_mask = DMA_BIT_MASK(32);
+
+struct platform_device vt8500_device_velocity = {
+	.name		= "velocity",
+	.id		= 0,
+	.dev		= {
+		.dma_mask	= &velocity_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
+static u64 rhine0_dma_mask = DMA_BIT_MASK(32);
+
+struct platform_device vt8500_device_rhine0 = {
+	.name		= "via-rhine",
+	.id		= 0,
+	.dev		= {
+		.dma_mask	= &rhine0_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
+static u64 rhine1_dma_mask = DMA_BIT_MASK(32);
+
+struct platform_device vt8500_device_rhine1 = {
+	.name		= "via-rhine",
+	.id		= 1,
+	.dev		= {
+		.dma_mask	= &rhine1_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
+static u64 nand_dma_mask = DMA_BIT_MASK(32);
+
+struct platform_device vt8500_device_nand = {
+	.name		= "vt8500-nand",
+	.id		= 0,
+	.dev		= {
+		.dma_mask	= &nand_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	}
+};
+
 struct map_desc wmt_io_desc[] __initdata = {
 	/* SoC MMIO registers */
 	[0] = {
@@ -267,4 +351,13 @@
 	preallocate_fb(&panels[current_panel_idx], 32);
 	vt8500_device_wm8505_fb.dev.platform_data = &panels[current_panel_idx];
 #endif
+}
+
+void __init wm8650_reserve_mem(void)
+{
+#if defined CONFIG_FB_WM8505
+	panels[current_panel_idx].bpp = 16; /* Always use RGB565 */
+	preallocate_fb(&panels[current_panel_idx], 32);
+	vt8500_device_wm8505_fb.dev.platform_data = &panels[current_panel_idx];
+#endif
 }
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/devices.h wm8505-3.3rc2/arch/arm/mach-vt8500/devices.h
--- linux-3.3-rc2/arch/arm/mach-vt8500/devices.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/devices.h	2012-02-06 12:27:43.000000000 -0700
@@ -23,11 +23,16 @@
 void __init wm8505_init_irq(void);
 void __init vt8500_map_io(void);
 void __init wm8505_map_io(void);
+void __init wm8650_map_io(void);
 void __init vt8500_reserve_mem(void);
 void __init wm8505_reserve_mem(void);
+void __init wm8650_reserve_mem(void);
 void __init vt8500_gpio_init(void);
+void __init wm8505_gpio_init(void);
+void __init wm8650_gpio_init(void);
 void __init vt8500_set_resources(void);
 void __init wm8505_set_resources(void);
+void __init wm8650_set_resources(void);
 
 extern unsigned long wmt_ic_base __initdata;
 extern unsigned long wmt_sic_base __initdata;
@@ -81,8 +86,15 @@
 extern struct platform_device vt8500_device_lcdc;
 extern struct platform_device vt8500_device_wm8505_fb;
 extern struct platform_device vt8500_device_ehci;
+extern struct platform_device vt8500_device_uhci;
+extern struct platform_device vt8500_device_velocity;
+extern struct platform_device vt8500_device_rhine0;
+extern struct platform_device vt8500_device_rhine1;
 extern struct platform_device vt8500_device_ge_rops;
 extern struct platform_device vt8500_device_pwm;
 extern struct platform_device vt8500_device_pwmbl;
 extern struct platform_device vt8500_device_rtc;
+extern struct platform_device vt8500_device_sdmmc;
+extern struct platform_device vt8500_device_nand;
+
 #endif
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/devices-vt8500.c wm8505-3.3rc2/arch/arm/mach-vt8500/devices-vt8500.c
--- linux-3.3-rc2/arch/arm/mach-vt8500/devices-vt8500.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/devices-vt8500.c	2012-02-06 12:27:43.000000000 -0700
@@ -58,6 +58,20 @@
 	tmp[1] = wmt_irq_res(IRQ_RTC);
 	tmp[2] = wmt_irq_res(IRQ_RTCSM);
 	wmt_res_add(&vt8500_device_rtc, tmp, 3);
+
+	tmp[0] = wmt_mmio_res(VT8500_SDMMC_BASE, SZ_1K);
+	tmp[1] = wmt_irq_res(IRQ_SDMMC);
+	tmp[2] = wmt_irq_res(IRQ_SDMMC_DMA);
+	wmt_res_add(&vt8500_device_sdmmc, tmp, 3);
+
+	tmp[0] = wmt_mmio_res(VT8500_ETHER_BASE, SZ_1K);
+	tmp[1] = wmt_irq_res(IRQ_ETHER);
+	wmt_res_add(&vt8500_device_rhine0, tmp, 2);
+
+	tmp[0] = wmt_mmio_res(VT8500_NAND_BASE, 0x400);
+	tmp[1] = wmt_irq_res(IRQ_NAND);
+	tmp[2] = wmt_irq_res(IRQ_NAND_DMA);
+	wmt_res_add(&vt8500_device_nand, tmp, 3);
 }
 
 static void __init vt8500_set_externs(void)
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/devices-wm8505.c wm8505-3.3rc2/arch/arm/mach-vt8500/devices-wm8505.c
--- linux-3.3-rc2/arch/arm/mach-vt8500/devices-wm8505.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/devices-wm8505.c	2012-02-06 12:27:43.000000000 -0700
@@ -65,6 +65,20 @@
 	tmp[1] = wmt_irq_res(IRQ_RTC);
 	tmp[2] = wmt_irq_res(IRQ_RTCSM);
 	wmt_res_add(&vt8500_device_rtc, tmp, 3);
+
+	tmp[0] = wmt_mmio_res(WM8505_SDMMC_BASE, SZ_1K);
+	tmp[1] = wmt_irq_res(IRQ_SDMMC);
+	tmp[2] = wmt_irq_res(IRQ_SDMMC_DMA);
+	wmt_res_add(&vt8500_device_sdmmc, tmp, 3);
+
+	tmp[0] = wmt_mmio_res(WM8505_ETHER_BASE, SZ_1K);
+	tmp[1] = wmt_irq_res(IRQ_ETHER);
+	wmt_res_add(&vt8500_device_velocity, tmp, 2);
+
+	tmp[0] = wmt_mmio_res(WM8505_NAND_BASE, 0x400);
+	tmp[1] = wmt_irq_res(IRQ_NAND);
+	tmp[2] = wmt_irq_res(IRQ_NAND_DMA);
+	wmt_res_add(&vt8500_device_nand, tmp, 3);
 }
 
 static void __init wm8505_set_externs(void)
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/devices-wm8650.c wm8505-3.3rc2/arch/arm/mach-vt8500/devices-wm8650.c
--- linux-3.3-rc2/arch/arm/mach-vt8500/devices-wm8650.c	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/devices-wm8650.c	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,118 @@
+/* linux/arch/arm/mach-vt8500/devices-wm8650.c
+ *
+ * Copyright (C) 2011 Alexey Charkov <alchark@gmail.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/platform_device.h>
+
+#include <mach/wm8650_regs.h>
+#include <mach/wm8650_irqs.h>
+#include <mach/i8042.h>
+#include "devices.h"
+
+void __init wm8650_set_resources(void)
+{
+	struct resource tmp[3];
+
+	tmp[0] = wmt_mmio_res(WM8650_GOVR_BASE, SZ_512);
+	wmt_res_add(&vt8500_device_wm8505_fb, tmp, 1);
+
+	tmp[0] = wmt_mmio_res(WM8650_UART0_BASE, 0x1040);
+	tmp[1] = wmt_irq_res(IRQ_UART0);
+	wmt_res_add(&vt8500_device_uart0, tmp, 2);
+
+	tmp[0] = wmt_mmio_res(WM8650_UART1_BASE, 0x1040);
+	tmp[1] = wmt_irq_res(IRQ_UART1);
+	wmt_res_add(&vt8500_device_uart1, tmp, 2);
+
+	tmp[0] = wmt_mmio_res(WM8650_UART2_BASE, 0x1040);
+	tmp[1] = wmt_irq_res(-1);
+	wmt_res_add(&vt8500_device_uart2, tmp, 2);
+
+	tmp[0] = wmt_mmio_res(WM8650_UART3_BASE, 0x1040);
+	tmp[1] = wmt_irq_res(-1);
+	wmt_res_add(&vt8500_device_uart3, tmp, 2);
+
+	tmp[0] = wmt_mmio_res(WM8650_UART4_BASE, 0x1040);
+	tmp[1] = wmt_irq_res(-1);
+	wmt_res_add(&vt8500_device_uart4, tmp, 2);
+
+	tmp[0] = wmt_mmio_res(WM8650_UART5_BASE, 0x1040);
+	tmp[1] = wmt_irq_res(-1);
+	wmt_res_add(&vt8500_device_uart5, tmp, 2);
+
+	tmp[0] = wmt_mmio_res(WM8650_EHCI_BASE, SZ_512);
+	tmp[1] = wmt_irq_res(IRQ_EHCI);
+	wmt_res_add(&vt8500_device_ehci, tmp, 2);
+
+	tmp[0] = wmt_mmio_res(WM8650_UHCI_BASE, SZ_512);
+	tmp[1] = wmt_irq_res(IRQ_UHCI);
+	wmt_res_add(&vt8500_device_uhci, tmp, 2);
+
+	tmp[0] = wmt_mmio_res(WM8650_GEGEA_BASE, SZ_256);
+	wmt_res_add(&vt8500_device_ge_rops, tmp, 1);
+
+	tmp[0] = wmt_mmio_res(WM8650_PWM_BASE, 0x44);
+	wmt_res_add(&vt8500_device_pwm, tmp, 1);
+
+	tmp[0] = wmt_mmio_res(WM8650_RTC_BASE, 0x2c);
+	tmp[1] = wmt_irq_res(IRQ_RTC);
+	tmp[2] = wmt_irq_res(IRQ_RTCSM);
+	wmt_res_add(&vt8500_device_rtc, tmp, 3);
+
+	tmp[0] = wmt_mmio_res(WM8650_SDMMC_BASE, SZ_1K);
+	tmp[1] = wmt_irq_res(IRQ_SDMMC);
+	tmp[2] = wmt_irq_res(IRQ_SDMMC_DMA);
+	wmt_res_add(&vt8500_device_sdmmc, tmp, 3);
+
+	tmp[0] = wmt_mmio_res(WM8650_ETHER_BASE, SZ_1K);
+	tmp[1] = wmt_irq_res(IRQ_ETHER);
+	wmt_res_add(&vt8500_device_rhine0, tmp, 2);
+
+	tmp[0] = wmt_mmio_res(WM8650_ETHER1_BASE, SZ_1K);
+	tmp[1] = wmt_irq_res(IRQ_ETHER1);
+	wmt_res_add(&vt8500_device_rhine1, tmp, 2);
+
+	tmp[0] = wmt_mmio_res(WM8650_NAND_BASE, 0x400);
+	tmp[1] = wmt_irq_res(IRQ_NAND);
+	tmp[2] = wmt_irq_res(IRQ_NAND_DMA);
+	wmt_res_add(&vt8500_device_nand, tmp, 3);
+}
+
+static void __init wm8650_set_externs(void)
+{
+	/* Non-resource-aware stuff */
+	wmt_ic_base = WM8650_IC_BASE;
+	wmt_sic_base = WM8650_SIC_BASE;
+	wmt_gpio_base = WM8650_GPIO_BASE;
+	wmt_pmc_base = WM8650_PMC_BASE;
+
+	wmt_nr_irqs = WM8650_NR_IRQS;
+	wmt_timer_irq = IRQ_PMCOS0;
+	wmt_gpio_ext_irq[0] = IRQ_GPIO;
+	wmt_gpio_ext_irq[1] = IRQ_GPIO;
+	wmt_gpio_ext_irq[2] = IRQ_GPIO;
+	wmt_gpio_ext_irq[3] = IRQ_GPIO;
+	wmt_gpio_ext_irq[4] = IRQ_GPIO;
+	wmt_gpio_ext_irq[5] = IRQ_GPIO;
+	wmt_gpio_ext_irq[6] = IRQ_GPIO;
+	wmt_gpio_ext_irq[7] = IRQ_GPIO;
+}
+
+void __init wm8650_map_io(void)
+{
+	iotable_init(wmt_io_desc, ARRAY_SIZE(wmt_io_desc));
+
+	/* Should be done before interrupts and timers are initialized */
+	wm8650_set_externs();
+}
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/gpio.c wm8505-3.3rc2/arch/arm/mach-vt8500/gpio.c
--- linux-3.3-rc2/arch/arm/mach-vt8500/gpio.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/gpio.c	1969-12-31 17:00:00.000000000 -0700
@@ -1,240 +0,0 @@
-/* linux/arch/arm/mach-vt8500/gpio.c
- *
- * Copyright (C) 2010 Alexey Charkov <alchark@gmail.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/gpio.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/io.h>
-
-#include "devices.h"
-
-#define to_vt8500(__chip) container_of(__chip, struct vt8500_gpio_chip, chip)
-
-#define ENABLE_REGS	0x0
-#define DIRECTION_REGS	0x20
-#define OUTVALUE_REGS	0x40
-#define INVALUE_REGS	0x60
-
-#define EXT_REGOFF	0x1c
-
-static void __iomem *regbase;
-
-struct vt8500_gpio_chip {
-	struct gpio_chip	chip;
-	unsigned int		shift;
-	unsigned int		regoff;
-};
-
-static int gpio_to_irq_map[8];
-
-static int vt8500_muxed_gpio_request(struct gpio_chip *chip,
-				     unsigned offset)
-{
-	struct vt8500_gpio_chip *vt8500_chip = to_vt8500(chip);
-	unsigned val = readl(regbase + ENABLE_REGS + vt8500_chip->regoff);
-
-	val |= (1 << vt8500_chip->shift << offset);
-	writel(val, regbase + ENABLE_REGS + vt8500_chip->regoff);
-
-	return 0;
-}
-
-static void vt8500_muxed_gpio_free(struct gpio_chip *chip,
-				   unsigned offset)
-{
-	struct vt8500_gpio_chip *vt8500_chip = to_vt8500(chip);
-	unsigned val = readl(regbase + ENABLE_REGS + vt8500_chip->regoff);
-
-	val &= ~(1 << vt8500_chip->shift << offset);
-	writel(val, regbase + ENABLE_REGS + vt8500_chip->regoff);
-}
-
-static int vt8500_muxed_gpio_direction_input(struct gpio_chip *chip,
-				       unsigned offset)
-{
-	struct vt8500_gpio_chip *vt8500_chip = to_vt8500(chip);
-	unsigned val = readl(regbase + DIRECTION_REGS + vt8500_chip->regoff);
-
-	val &= ~(1 << vt8500_chip->shift << offset);
-	writel(val, regbase + DIRECTION_REGS + vt8500_chip->regoff);
-
-	return 0;
-}
-
-static int vt8500_muxed_gpio_direction_output(struct gpio_chip *chip,
-					unsigned offset, int value)
-{
-	struct vt8500_gpio_chip *vt8500_chip = to_vt8500(chip);
-	unsigned val = readl(regbase + DIRECTION_REGS + vt8500_chip->regoff);
-
-	val |= (1 << vt8500_chip->shift << offset);
-	writel(val, regbase + DIRECTION_REGS + vt8500_chip->regoff);
-
-	if (value) {
-		val = readl(regbase + OUTVALUE_REGS + vt8500_chip->regoff);
-		val |= (1 << vt8500_chip->shift << offset);
-		writel(val, regbase + OUTVALUE_REGS + vt8500_chip->regoff);
-	}
-	return 0;
-}
-
-static int vt8500_muxed_gpio_get_value(struct gpio_chip *chip,
-				       unsigned offset)
-{
-	struct vt8500_gpio_chip *vt8500_chip = to_vt8500(chip);
-
-	return (readl(regbase + INVALUE_REGS + vt8500_chip->regoff)
-		>> vt8500_chip->shift >> offset) & 1;
-}
-
-static void vt8500_muxed_gpio_set_value(struct gpio_chip *chip,
-					unsigned offset, int value)
-{
-	struct vt8500_gpio_chip *vt8500_chip = to_vt8500(chip);
-	unsigned val = readl(regbase + INVALUE_REGS + vt8500_chip->regoff);
-
-	if (value)
-		val |= (1 << vt8500_chip->shift << offset);
-	else
-		val &= ~(1 << vt8500_chip->shift << offset);
-
-	writel(val, regbase + INVALUE_REGS + vt8500_chip->regoff);
-}
-
-#define VT8500_GPIO_BANK(__name, __shift, __off, __base, __num)		\
-{									\
-	.chip = {							\
-		.label			= __name,			\
-		.request		= vt8500_muxed_gpio_request,	\
-		.free			= vt8500_muxed_gpio_free,	\
-		.direction_input  = vt8500_muxed_gpio_direction_input,	\
-		.direction_output = vt8500_muxed_gpio_direction_output,	\
-		.get			= vt8500_muxed_gpio_get_value,	\
-		.set			= vt8500_muxed_gpio_set_value,	\
-		.can_sleep		= 0,				\
-		.base			= __base,			\
-		.ngpio			= __num,			\
-	},								\
-	.shift		= __shift,					\
-	.regoff		= __off,					\
-}
-
-static struct vt8500_gpio_chip vt8500_muxed_gpios[] = {
-	VT8500_GPIO_BANK("uart0",	0,	0x0,	8,	4),
-	VT8500_GPIO_BANK("uart1",	4,	0x0,	12,	4),
-	VT8500_GPIO_BANK("spi0",	8,	0x0,	16,	4),
-	VT8500_GPIO_BANK("spi1",	12,	0x0,	20,	4),
-	VT8500_GPIO_BANK("spi2",	16,	0x0,	24,	4),
-	VT8500_GPIO_BANK("pwmout",	24,	0x0,	28,	2),
-
-	VT8500_GPIO_BANK("sdmmc",	0,	0x4,	30,	11),
-	VT8500_GPIO_BANK("ms",		16,	0x4,	41,	7),
-	VT8500_GPIO_BANK("i2c0",	24,	0x4,	48,	2),
-	VT8500_GPIO_BANK("i2c1",	26,	0x4,	50,	2),
-
-	VT8500_GPIO_BANK("mii",		0,	0x8,	52,	20),
-	VT8500_GPIO_BANK("see",		20,	0x8,	72,	4),
-	VT8500_GPIO_BANK("ide",		24,	0x8,	76,	7),
-
-	VT8500_GPIO_BANK("ccir",	0,	0xc,	83,	19),
-
-	VT8500_GPIO_BANK("ts",		8,	0x10,	102,	11),
-
-	VT8500_GPIO_BANK("lcd",		0,	0x14,	113,	23),
-};
-
-static int vt8500_gpio_direction_input(struct gpio_chip *chip,
-				       unsigned offset)
-{
-	unsigned val = readl(regbase + DIRECTION_REGS + EXT_REGOFF);
-
-	val &= ~(1 << offset);
-	writel(val, regbase + DIRECTION_REGS + EXT_REGOFF);
-	return 0;
-}
-
-static int vt8500_gpio_direction_output(struct gpio_chip *chip,
-					unsigned offset, int value)
-{
-	unsigned val = readl(regbase + DIRECTION_REGS + EXT_REGOFF);
-
-	val |= (1 << offset);
-	writel(val, regbase + DIRECTION_REGS + EXT_REGOFF);
-
-	if (value) {
-		val = readl(regbase + OUTVALUE_REGS + EXT_REGOFF);
-		val |= (1 << offset);
-		writel(val, regbase + OUTVALUE_REGS + EXT_REGOFF);
-	}
-	return 0;
-}
-
-static int vt8500_gpio_get_value(struct gpio_chip *chip,
-				       unsigned offset)
-{
-	return (readl(regbase + INVALUE_REGS + EXT_REGOFF) >> offset) & 1;
-}
-
-static void vt8500_gpio_set_value(struct gpio_chip *chip,
-					unsigned offset, int value)
-{
-	unsigned val = readl(regbase + OUTVALUE_REGS + EXT_REGOFF);
-
-	if (value)
-		val |= (1 << offset);
-	else
-		val &= ~(1 << offset);
-
-	writel(val, regbase + OUTVALUE_REGS + EXT_REGOFF);
-}
-
-static int vt8500_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
-{
-	if (offset > 7)
-		return -EINVAL;
-
-	return gpio_to_irq_map[offset];
-}
-
-static struct gpio_chip vt8500_external_gpios = {
-	.label			= "extgpio",
-	.direction_input	= vt8500_gpio_direction_input,
-	.direction_output	= vt8500_gpio_direction_output,
-	.get			= vt8500_gpio_get_value,
-	.set			= vt8500_gpio_set_value,
-	.to_irq			= vt8500_gpio_to_irq,
-	.can_sleep		= 0,
-	.base			= 0,
-	.ngpio			= 8,
-};
-
-void __init vt8500_gpio_init(void)
-{
-	int i;
-
-	for (i = 0; i < 8; i++)
-		gpio_to_irq_map[i] = wmt_gpio_ext_irq[i];
-
-	regbase = ioremap(wmt_gpio_base, SZ_64K);
-	if (!regbase) {
-		printk(KERN_ERR "Failed to map MMIO registers for GPIO\n");
-		return;
-	}
-
-	gpiochip_add(&vt8500_external_gpios);
-
-	for (i = 0; i < ARRAY_SIZE(vt8500_muxed_gpios); i++)
-		gpiochip_add(&vt8500_muxed_gpios[i].chip);
-}
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/gpio-vt8500.c wm8505-3.3rc2/arch/arm/mach-vt8500/gpio-vt8500.c
--- linux-3.3-rc2/arch/arm/mach-vt8500/gpio-vt8500.c	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/gpio-vt8500.c	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,247 @@
+/* linux/arch/arm/mach-vt8500/gpio-vt8500.c
+ *
+ * Copyright (C) 2010 Alexey Charkov <alchark@gmail.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+
+#include "devices.h"
+
+#define to_vt8500(__chip) container_of(__chip, struct vt8500_gpio_chip, chip)
+
+#define ENABLE_REGS	0x0
+#define DIRECTION_REGS	0x20
+#define OUTVALUE_REGS	0x40
+#define INVALUE_REGS	0x60
+
+#define EXT_REGOFF	0x1c
+
+static void __iomem *regbase;
+
+struct vt8500_gpio_chip {
+	struct gpio_chip	chip;
+	unsigned int		shift;
+	unsigned int		regoff;
+};
+
+static int gpio_to_irq_map[8];
+
+static int vt8500_muxed_gpio_request(struct gpio_chip *chip,
+				     unsigned offset)
+{
+	struct vt8500_gpio_chip *vt8500_chip = to_vt8500(chip);
+	unsigned val = readl(regbase + ENABLE_REGS + vt8500_chip->regoff);
+
+	val |= (1 << vt8500_chip->shift << offset);
+	writel(val, regbase + ENABLE_REGS + vt8500_chip->regoff);
+
+	return 0;
+}
+
+static void vt8500_muxed_gpio_free(struct gpio_chip *chip,
+				   unsigned offset)
+{
+	struct vt8500_gpio_chip *vt8500_chip = to_vt8500(chip);
+	unsigned val = readl(regbase + ENABLE_REGS + vt8500_chip->regoff);
+
+	val &= ~(1 << vt8500_chip->shift << offset);
+	writel(val, regbase + ENABLE_REGS + vt8500_chip->regoff);
+}
+
+static int vt8500_muxed_gpio_direction_input(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	struct vt8500_gpio_chip *vt8500_chip = to_vt8500(chip);
+	unsigned val = readl(regbase + DIRECTION_REGS + vt8500_chip->regoff);
+
+	val &= ~(1 << vt8500_chip->shift << offset);
+	writel(val, regbase + DIRECTION_REGS + vt8500_chip->regoff);
+
+	return 0;
+}
+
+static int vt8500_muxed_gpio_direction_output(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	struct vt8500_gpio_chip *vt8500_chip = to_vt8500(chip);
+	unsigned val = readl(regbase + DIRECTION_REGS + vt8500_chip->regoff);
+
+	val |= (1 << vt8500_chip->shift << offset);
+	writel(val, regbase + DIRECTION_REGS + vt8500_chip->regoff);
+
+	if (value) {
+		val = readl(regbase + OUTVALUE_REGS + vt8500_chip->regoff);
+		val |= (1 << vt8500_chip->shift << offset);
+		writel(val, regbase + OUTVALUE_REGS + vt8500_chip->regoff);
+	}
+	return 0;
+}
+
+static int vt8500_muxed_gpio_get_value(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	struct vt8500_gpio_chip *vt8500_chip = to_vt8500(chip);
+
+	return (readl(regbase + INVALUE_REGS + vt8500_chip->regoff)
+		>> vt8500_chip->shift >> offset) & 1;
+}
+
+static void vt8500_muxed_gpio_set_value(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	struct vt8500_gpio_chip *vt8500_chip = to_vt8500(chip);
+	unsigned val = readl(regbase + OUTVALUE_REGS + vt8500_chip->regoff);
+
+	if (value)
+		val |= (1 << vt8500_chip->shift << offset);
+	else
+		val &= ~(1 << vt8500_chip->shift << offset);
+
+	writel(val, regbase + OUTVALUE_REGS + vt8500_chip->regoff);
+}
+
+#define VT8500_GPIO_BANK(__name, __shift, __off, __base, __num)		\
+{									\
+	.chip = {							\
+		.label			= __name,			\
+		.request		= vt8500_muxed_gpio_request,	\
+		.free			= vt8500_muxed_gpio_free,	\
+		.direction_input  = vt8500_muxed_gpio_direction_input,	\
+		.direction_output = vt8500_muxed_gpio_direction_output,	\
+		.get			= vt8500_muxed_gpio_get_value,	\
+		.set			= vt8500_muxed_gpio_set_value,	\
+		.can_sleep		= 0,				\
+		.base			= __base,			\
+		.ngpio			= __num,			\
+	},								\
+	.shift		= __shift,					\
+	.regoff		= __off,					\
+}
+
+static struct vt8500_gpio_chip vt8500_muxed_gpios[] = {
+	VT8500_GPIO_BANK("uart0",	0,	0x0,	8,	4),
+	VT8500_GPIO_BANK("uart1",	4,	0x0,	12,	4),
+	VT8500_GPIO_BANK("spi0",	8,	0x0,	16,	4),
+	VT8500_GPIO_BANK("spi1",	12,	0x0,	20,	4),
+	VT8500_GPIO_BANK("spi2",	16,	0x0,	24,	4),
+	VT8500_GPIO_BANK("pwmout",	24,	0x0,	28,	2),
+
+	VT8500_GPIO_BANK("sdmmc",	0,	0x4,	30,	11),
+	VT8500_GPIO_BANK("ms",		16,	0x4,	41,	7),
+	VT8500_GPIO_BANK("i2c0",	24,	0x4,	48,	2),
+	VT8500_GPIO_BANK("i2c1",	26,	0x4,	50,	2),
+
+	VT8500_GPIO_BANK("mii",		0,	0x8,	52,	20),
+	VT8500_GPIO_BANK("see",		20,	0x8,	72,	4),
+	VT8500_GPIO_BANK("ide",		24,	0x8,	76,	7),
+
+	VT8500_GPIO_BANK("ccir",	0,	0xc,	83,	19),
+
+	VT8500_GPIO_BANK("ts",		8,	0x10,	102,	11),
+
+	VT8500_GPIO_BANK("lcd",		0,	0x14,	113,	23),
+};
+
+static int vt8500_gpio_direction_input(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	unsigned val = readl(regbase + DIRECTION_REGS + EXT_REGOFF);
+
+	val &= ~(1 << offset);
+	writel(val, regbase + DIRECTION_REGS + EXT_REGOFF);
+	return 0;
+}
+
+static int vt8500_gpio_direction_output(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	unsigned val = readl(regbase + DIRECTION_REGS + EXT_REGOFF);
+
+	val |= (1 << offset);
+	writel(val, regbase + DIRECTION_REGS + EXT_REGOFF);
+
+	if (value) {
+		val = readl(regbase + OUTVALUE_REGS + EXT_REGOFF);
+		val |= (1 << offset);
+		writel(val, regbase + OUTVALUE_REGS + EXT_REGOFF);
+	}
+	return 0;
+}
+
+static int vt8500_gpio_get_value(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	return (readl(regbase + INVALUE_REGS + EXT_REGOFF) >> offset) & 1;
+}
+
+static void vt8500_gpio_set_value(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	unsigned val = readl(regbase + OUTVALUE_REGS + EXT_REGOFF);
+
+	if (value)
+		val |= (1 << offset);
+	else
+		val &= ~(1 << offset);
+
+	writel(val, regbase + OUTVALUE_REGS + EXT_REGOFF);
+}
+
+static int vt8500_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	if (offset > 7)
+		return -EINVAL;
+
+	return gpio_to_irq_map[offset];
+}
+
+static struct gpio_chip vt8500_external_gpios = {
+	.label			= "extgpio",
+	.direction_input	= vt8500_gpio_direction_input,
+	.direction_output	= vt8500_gpio_direction_output,
+	.get			= vt8500_gpio_get_value,
+	.set			= vt8500_gpio_set_value,
+	.to_irq			= vt8500_gpio_to_irq,
+	.can_sleep		= 0,
+	.base			= 0,
+	.ngpio			= 8,
+};
+
+void __init vt8500_gpio_init(void)
+{
+	int i;
+
+	for (i = 0; i < 8; i++)
+		gpio_to_irq_map[i] = wmt_gpio_ext_irq[i];
+
+	regbase = ioremap(wmt_gpio_base, SZ_64K);
+	if (!regbase) {
+		printk(KERN_ERR "Failed to map MMIO registers for GPIO\n");
+		return;
+	}
+	/*
+	 * Ensure that all muxed pins are initialized in non-gpio state until
+	 * requested otherwise
+	 */
+	for (i = 0; i <= 0x14; i += 4)
+		writel(0, regbase + ENABLE_REGS + i);
+
+
+	gpiochip_add(&vt8500_external_gpios);
+
+	for (i = 0; i < ARRAY_SIZE(vt8500_muxed_gpios); i++)
+		gpiochip_add(&vt8500_muxed_gpios[i].chip);
+}
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/gpio-wm8505.c wm8505-3.3rc2/arch/arm/mach-vt8500/gpio-wm8505.c
--- linux-3.3-rc2/arch/arm/mach-vt8500/gpio-wm8505.c	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/gpio-wm8505.c	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,356 @@
+/* linux/arch/arm/mach-wm8505/gpio-wm8505.c
+ *
+ * Copyright (C) 2010 Alexey Charkov <alchark@gmail.com>
+ * Copyright (C) 2011 Tony Prisk <linux@prisktech.co.nz>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+
+#include "devices.h"
+
+#define to_wm8505(__chip) container_of(__chip, struct wm8505_gpio_chip, chip)
+
+#define ENABLE_REGS	0x40
+#define DIRECTION_REGS	0x68
+#define OUTVALUE_REGS	0x90
+#define INVALUE_REGS	0xB8
+
+#define ENABLE2_REGS	0x00
+#define DIRECTION2_REGS	0x04
+#define OUTVALUE2_REGS	0x08
+#define INVALUE2_REGS	0x0C
+
+#define EXT_REGOFF	0x24
+
+static void __iomem *regbase;
+
+struct wm8505_gpio_chip {
+	struct gpio_chip	chip;
+	unsigned int		shift;
+	unsigned int		regoff;
+};
+
+static int gpio_to_irq_map[8];
+
+static int wm8505_muxed2_gpio_request(struct gpio_chip *chip,
+				     unsigned offset)
+{
+	struct wm8505_gpio_chip *wm8505_chip = to_wm8505(chip);
+	unsigned val = readl(regbase + ENABLE2_REGS + wm8505_chip->regoff);
+
+	val |= (1 << wm8505_chip->shift << offset);
+	writel(val, regbase + ENABLE2_REGS + wm8505_chip->regoff);
+
+	return 0;
+}
+
+static void wm8505_muxed2_gpio_free(struct gpio_chip *chip,
+				   unsigned offset)
+{
+	struct wm8505_gpio_chip *wm8505_chip = to_wm8505(chip);
+	unsigned val = readl(regbase + ENABLE2_REGS + wm8505_chip->regoff);
+
+	val &= ~(1 << wm8505_chip->shift << offset);
+	writel(val, regbase + ENABLE2_REGS + wm8505_chip->regoff);
+}
+
+static int wm8505_muxed2_gpio_direction_input(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	struct wm8505_gpio_chip *wm8505_chip = to_wm8505(chip);
+	unsigned val = readl(regbase + DIRECTION2_REGS + wm8505_chip->regoff);
+
+	val &= ~(1 << wm8505_chip->shift << offset);
+	writel(val, regbase + DIRECTION2_REGS + wm8505_chip->regoff);
+
+	return 0;
+}
+
+static int wm8505_muxed2_gpio_direction_output(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	struct wm8505_gpio_chip *wm8505_chip = to_wm8505(chip);
+	unsigned val = readl(regbase + DIRECTION2_REGS + wm8505_chip->regoff);
+
+	val |= (1 << wm8505_chip->shift << offset);
+	writel(val, regbase + DIRECTION2_REGS + wm8505_chip->regoff);
+
+	if (value) {
+		val = readl(regbase + OUTVALUE2_REGS + wm8505_chip->regoff);
+		val |= (1 << wm8505_chip->shift << offset);
+		writel(val, regbase + OUTVALUE2_REGS + wm8505_chip->regoff);
+	}
+	return 0;
+}
+
+static int wm8505_muxed2_gpio_get_value(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	struct wm8505_gpio_chip *wm8505_chip = to_wm8505(chip);
+
+	return (readl(regbase + INVALUE2_REGS + wm8505_chip->regoff)
+		>> wm8505_chip->shift >> offset) & 1;
+}
+
+static void wm8505_muxed2_gpio_set_value(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	struct wm8505_gpio_chip *wm8505_chip = to_wm8505(chip);
+	unsigned val = readl(regbase + OUTVALUE2_REGS + wm8505_chip->regoff);
+
+	if (value)
+		val |= (1 << wm8505_chip->shift << offset);
+	else
+		val &= ~(1 << wm8505_chip->shift << offset);
+
+	writel(val, regbase + OUTVALUE2_REGS + wm8505_chip->regoff);
+}
+
+#define WM8505_GPIO_BANK2(__name, __shift, __off, __base, __num)		\
+{										\
+	.chip = {								\
+		.label			= __name,				\
+		.request		= wm8505_muxed2_gpio_request,		\
+		.free			= wm8505_muxed2_gpio_free,		\
+		.direction_input  	= wm8505_muxed2_gpio_direction_input,	\
+		.direction_output 	= wm8505_muxed2_gpio_direction_output,	\
+		.get			= wm8505_muxed2_gpio_get_value,		\
+		.set			= wm8505_muxed2_gpio_set_value,		\
+		.can_sleep		= 0,					\
+		.base			= __base,				\
+		.ngpio			= __num,				\
+	},									\
+	.shift		= __shift,						\
+	.regoff		= __off,						\
+}
+
+static int wm8505_muxed_gpio_request(struct gpio_chip *chip,
+				     unsigned offset)
+{
+	struct wm8505_gpio_chip *wm8505_chip = to_wm8505(chip);
+	unsigned val = readl(regbase + ENABLE_REGS + wm8505_chip->regoff);
+
+	val |= (1 << wm8505_chip->shift << offset);
+	writel(val, regbase + ENABLE_REGS + wm8505_chip->regoff);
+
+	return 0;
+}
+
+static void wm8505_muxed_gpio_free(struct gpio_chip *chip,
+				   unsigned offset)
+{
+	struct wm8505_gpio_chip *wm8505_chip = to_wm8505(chip);
+	unsigned val = readl(regbase + ENABLE_REGS + wm8505_chip->regoff);
+
+	val &= ~(1 << wm8505_chip->shift << offset);
+	writel(val, regbase + ENABLE_REGS + wm8505_chip->regoff);
+}
+
+static int wm8505_muxed_gpio_direction_input(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	struct wm8505_gpio_chip *wm8505_chip = to_wm8505(chip);
+	unsigned val = readl(regbase + DIRECTION_REGS + wm8505_chip->regoff);
+
+	val &= ~(1 << wm8505_chip->shift << offset);
+	writel(val, regbase + DIRECTION_REGS + wm8505_chip->regoff);
+
+	return 0;
+}
+
+static int wm8505_muxed_gpio_direction_output(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	struct wm8505_gpio_chip *wm8505_chip = to_wm8505(chip);
+	unsigned val = readl(regbase + DIRECTION_REGS + wm8505_chip->regoff);
+
+	val |= (1 << wm8505_chip->shift << offset);
+	writel(val, regbase + DIRECTION_REGS + wm8505_chip->regoff);
+
+	if (value) {
+		val = readl(regbase + OUTVALUE_REGS + wm8505_chip->regoff);
+		val |= (1 << wm8505_chip->shift << offset);
+		writel(val, regbase + OUTVALUE_REGS + wm8505_chip->regoff);
+	}
+	return 0;
+}
+
+static int wm8505_muxed_gpio_get_value(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	struct wm8505_gpio_chip *wm8505_chip = to_wm8505(chip);
+
+	return (readl(regbase + INVALUE_REGS + wm8505_chip->regoff)
+		>> wm8505_chip->shift >> offset) & 1;
+}
+
+static void wm8505_muxed_gpio_set_value(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	struct wm8505_gpio_chip *wm8505_chip = to_wm8505(chip);
+	unsigned val = readl(regbase + OUTVALUE_REGS + wm8505_chip->regoff);
+
+	if (value)
+		val |= (1 << wm8505_chip->shift << offset);
+	else
+		val &= ~(1 << wm8505_chip->shift << offset);
+
+	writel(val, regbase + OUTVALUE_REGS + wm8505_chip->regoff);
+}
+
+#define WM8505_GPIO_BANK(__name, __shift, __off, __base, __num)		\
+{									\
+	.chip = {							\
+		.label			= __name,			\
+		.request		= wm8505_muxed_gpio_request,	\
+		.free			= wm8505_muxed_gpio_free,	\
+		.direction_input  = wm8505_muxed_gpio_direction_input,	\
+		.direction_output = wm8505_muxed_gpio_direction_output,	\
+		.get			= wm8505_muxed_gpio_get_value,	\
+		.set			= wm8505_muxed_gpio_set_value,	\
+		.can_sleep		= 0,				\
+		.base			= __base,			\
+		.ngpio			= __num,			\
+	},								\
+	.shift		= __shift,					\
+	.regoff		= __off,					\
+}
+
+static struct wm8505_gpio_chip wm8505_muxed_gpios[] = {
+	WM8505_GPIO_BANK("sdmmc",	0,	0x0,	8,	8),
+
+	WM8505_GPIO_BANK("vdout",	8,	0x04,	16,	24),
+	WM8505_GPIO_BANK("vdin",	0,	0x04,	40,	8),
+
+	WM8505_GPIO_BANK("sync",	0,	0x08,	48,	6),
+
+	WM8505_GPIO_BANK("nord",	0,	0x0C,	54,	16),
+
+	WM8505_GPIO_BANK("nora",	0,	0x10,	70,	5),
+
+	WM8505_GPIO_BANK("ac97",	0,	0x14,	75,	5),
+
+	WM8505_GPIO_BANK("spiflash",	0,	0x18,	80,	5),
+
+	WM8505_GPIO_BANK("spi0",	0,	0x1C,	85,	4),
+	WM8505_GPIO_BANK("spi1",	4,	0x1C,	89,	4),
+	WM8505_GPIO_BANK("spi2",	8,	0x1C,	93,	4),
+
+	WM8505_GPIO_BANK("uart0",	0,	0x20,	97,	4),
+	WM8505_GPIO_BANK("uart1",	4,	0x20,	101,	4),
+	WM8505_GPIO_BANK("uart2",	8,	0x20,	105,	4),
+	WM8505_GPIO_BANK("uart3",	12,	0x20,	109,	4),
+
+	WM8505_GPIO_BANK("wakeup",	16,	0x24,	113,	4),
+	WM8505_GPIO_BANK("usbsus",	21,	0x24,	117,	1),
+
+	WM8505_GPIO_BANK2("pwmout",	4,	0x500,	118,	2),
+	WM8505_GPIO_BANK2("i2c0",	2,	0x500,	120,	2),
+	WM8505_GPIO_BANK2("i2c1",	2,	0x500,	122,	2),
+};
+
+static int wm8505_gpio_direction_input(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	unsigned val = readl(regbase + DIRECTION_REGS + EXT_REGOFF);
+
+	val &= ~(1 << offset);
+	writel(val, regbase + DIRECTION_REGS + EXT_REGOFF);
+	return 0;
+}
+
+static int wm8505_gpio_direction_output(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	unsigned val = readl(regbase + DIRECTION_REGS + EXT_REGOFF);
+
+	val |= (1 << offset);
+	writel(val, regbase + DIRECTION_REGS + EXT_REGOFF);
+
+	if (value) {
+		val = readl(regbase + OUTVALUE_REGS + EXT_REGOFF);
+		val |= (1 << offset);
+		writel(val, regbase + OUTVALUE_REGS + EXT_REGOFF);
+	}
+	return 0;
+}
+
+static int wm8505_gpio_get_value(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	u32 reg_tmp;
+	reg_tmp = readl(regbase + INVALUE_REGS + EXT_REGOFF);
+	return (reg_tmp >> offset) & 1;
+}
+
+static void wm8505_gpio_set_value(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	unsigned val = readl(regbase + OUTVALUE_REGS + EXT_REGOFF);
+
+	if (value)
+		val |= (1 << offset);
+	else
+		val &= ~(1 << offset);
+
+	writel(val, regbase + OUTVALUE_REGS + EXT_REGOFF);
+}
+
+static int wm8505_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	if (offset > 7)
+		return -EINVAL;
+
+	return gpio_to_irq_map[offset];
+}
+
+static struct gpio_chip wm8505_external_gpios = {
+	.label			= "extgpio",
+	.direction_input	= wm8505_gpio_direction_input,
+	.direction_output	= wm8505_gpio_direction_output,
+	.get				= wm8505_gpio_get_value,
+	.set				= wm8505_gpio_set_value,
+	.to_irq			= wm8505_gpio_to_irq,
+	.can_sleep		= 0,
+	.base			= 0,
+	.ngpio			= 8,
+};
+
+void __init wm8505_gpio_init(void)
+{
+	int i;
+
+	for (i = 0; i < 8; i++)
+		gpio_to_irq_map[i] = wmt_gpio_ext_irq[i];
+
+	regbase = ioremap(wmt_gpio_base, SZ_64K);
+	if (!regbase) {
+		printk(KERN_ERR "Failed to map MMIO registers for GPIO\n");
+		return;
+	}
+	/*
+	 * Ensure that all muxed pins are initialized in non-gpio state until
+	 * requested otherwise
+	 */
+	writel(0, regbase + 0x500);
+	for (i = 0; i <= 0x24; i += 4)
+		writel(0, regbase + ENABLE_REGS + i);
+
+	gpiochip_add(&wm8505_external_gpios);
+
+	for (i = 0; i < ARRAY_SIZE(wm8505_muxed_gpios); i++)
+		gpiochip_add(&wm8505_muxed_gpios[i].chip);
+}
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/gpio-wm8650.c wm8505-3.3rc2/arch/arm/mach-vt8500/gpio-wm8650.c
--- linux-3.3-rc2/arch/arm/mach-vt8500/gpio-wm8650.c	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/gpio-wm8650.c	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,197 @@
+/* linux/arch/arm/mach-vt8500/gpio-wm8650.c
+ *
+ * Copyright (C) 2010 Alexey Charkov <alchark@gmail.com>
+ * Copyright (C) 2011 Tony Prisk <linux@prisktech.co.nz>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+
+#include "devices.h"
+
+#define to_wm8650(__chip) container_of(__chip, struct wm8650_gpio_chip, chip)
+
+#define ENABLE_REGS	0x40
+#define DIRECTION_REGS	0x80
+#define OUTVALUE_REGS	0xC0
+#define INVALUE_REGS	0x00
+
+#define EXT_REGOFF	0x24
+
+static void __iomem *regbase;
+
+struct wm8650_gpio_chip {
+	struct gpio_chip	chip;
+	unsigned int		shift;
+	unsigned int		regoff;
+};
+
+static int gpio_to_irq_map[8];
+
+static int wm8650_muxed_gpio_request(struct gpio_chip *chip,
+				     unsigned offset)
+{
+	struct wm8650_gpio_chip *wm8650_chip = to_wm8650(chip);
+	unsigned val = readl(regbase + ENABLE_REGS + wm8650_chip->regoff);
+
+	val |= (1 << wm8650_chip->shift << offset);
+	writel(val, regbase + ENABLE_REGS + wm8650_chip->regoff);
+
+	return 0;
+}
+
+static void wm8650_muxed_gpio_free(struct gpio_chip *chip,
+				   unsigned offset)
+{
+	struct wm8650_gpio_chip *wm8650_chip = to_wm8650(chip);
+	unsigned val = readl(regbase + ENABLE_REGS + wm8650_chip->regoff);
+
+	val &= ~(1 << wm8650_chip->shift << offset);
+	writel(val, regbase + ENABLE_REGS + wm8650_chip->regoff);
+}
+
+static int wm8650_muxed_gpio_direction_input(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	struct wm8650_gpio_chip *wm8650_chip = to_wm8650(chip);
+	unsigned val = readl(regbase + DIRECTION_REGS + wm8650_chip->regoff);
+
+	val &= ~(1 << wm8650_chip->shift << offset);
+	writel(val, regbase + DIRECTION_REGS + wm8650_chip->regoff);
+
+	return 0;
+}
+
+static int wm8650_muxed_gpio_direction_output(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	struct wm8650_gpio_chip *wm8650_chip = to_wm8650(chip);
+	unsigned val = readl(regbase + DIRECTION_REGS + wm8650_chip->regoff);
+
+	val |= (1 << wm8650_chip->shift << offset);
+	writel(val, regbase + DIRECTION_REGS + wm8650_chip->regoff);
+
+	if (value) {
+		val = readl(regbase + OUTVALUE_REGS + wm8650_chip->regoff);
+		val |= (1 << wm8650_chip->shift << offset);
+		writel(val, regbase + OUTVALUE_REGS + wm8650_chip->regoff);
+	}
+	return 0;
+}
+
+static int wm8650_muxed_gpio_get_value(struct gpio_chip *chip,
+				       unsigned offset)
+{
+	struct wm8650_gpio_chip *wm8650_chip = to_wm8650(chip);
+
+	return (readl(regbase + INVALUE_REGS + wm8650_chip->regoff)
+		>> wm8650_chip->shift >> offset) & 1;
+}
+
+static void wm8650_muxed_gpio_set_value(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	struct wm8650_gpio_chip *wm8650_chip = to_wm8650(chip);
+	unsigned val = readl(regbase + OUTVALUE_REGS + wm8650_chip->regoff);
+
+	if (value)
+		val |= (1 << wm8650_chip->shift << offset);
+	else
+		val &= ~(1 << wm8650_chip->shift << offset);
+
+	writel(val, regbase + OUTVALUE_REGS + wm8650_chip->regoff);
+}
+
+#define WM8650_GPIO_BANK(__name, __shift, __off, __base, __num)		\
+{									\
+	.chip = {							\
+		.label			= __name,			\
+		.request		= wm8650_muxed_gpio_request,	\
+		.free			= wm8650_muxed_gpio_free,	\
+		.direction_input  = wm8650_muxed_gpio_direction_input,	\
+		.direction_output = wm8650_muxed_gpio_direction_output,	\
+		.get			= wm8650_muxed_gpio_get_value,	\
+		.set			= wm8650_muxed_gpio_set_value,	\
+		.can_sleep		= 0,				\
+		.base			= __base,			\
+		.ngpio			= __num,			\
+	},								\
+	.shift		= __shift,					\
+	.regoff		= __off,					\
+}
+
+static struct wm8650_gpio_chip wm8650_muxed_gpios[] = {
+	WM8650_GPIO_BANK("vdout",	0,	0x04,	8,	24),
+	WM8650_GPIO_BANK("vdin",	0,	0x08,	32,	8),
+	WM8650_GPIO_BANK("uart0",	0,	0x16,	40,	4),
+	WM8650_GPIO_BANK("uart1",	4,	0x16,	44,	4),
+	WM8650_GPIO_BANK("uart2",	8,	0x16,	48,	4),
+	WM8650_GPIO_BANK("uart3",	12,	0x16,	52,	4),
+	WM8650_GPIO_BANK("sdmmc",	16,	0x0C,	56,	7),
+	WM8650_GPIO_BANK("nand0",	24,	0x0C,	63,	8),
+	WM8650_GPIO_BANK("nand1",	0,	0x10,	71,	8),
+	WM8650_GPIO_BANK("spiflash",	16,	0x1C,	79,	5),
+};
+
+
+static int wm8650_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	if (offset > 7)
+		return -EINVAL;
+
+	return gpio_to_irq_map[offset];
+}
+
+static struct wm8650_gpio_chip wm8650_external_gpios = {
+	.chip = {
+		.label			= "extgpio",
+		.direction_input	= wm8650_muxed_gpio_direction_input,
+		.direction_output	= wm8650_muxed_gpio_direction_output,
+		.get			= wm8650_muxed_gpio_get_value,
+		.set			= wm8650_muxed_gpio_set_value,
+		.to_irq			= wm8650_gpio_to_irq,
+		.can_sleep		= 0,
+		.base			= 0,
+		.ngpio			= 8,
+	},
+	.shift		= 0,
+	.regoff		= 0,
+};
+
+void __init wm8650_gpio_init(void)
+{
+	int i;
+
+	for (i = 0; i < 8; i++)
+		gpio_to_irq_map[i] = wmt_gpio_ext_irq[i];
+
+	regbase = ioremap(wmt_gpio_base, SZ_64K);
+	if (!regbase) {
+		printk(KERN_ERR "Failed to map MMIO registers for GPIO\n");
+		return;
+	}
+	/*
+	 * Ensure that all muxed pins are initialized in non-gpio state until
+	 * requested otherwise. We enable all extgpio pins.
+	 */
+	writel(0x000000FF, regbase + ENABLE_REGS); // extgpio are 1, rest 0
+	for (i = 4; i <= 0x1c; i += 4)
+		writel(0, regbase + ENABLE_REGS + i);
+
+	gpiochip_add(&wm8650_external_gpios.chip);
+
+	for (i = 0; i < ARRAY_SIZE(wm8650_muxed_gpios); i++)
+		gpiochip_add(&wm8650_muxed_gpios[i].chip);
+}
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/include/mach/wm8650_irqs.h wm8505-3.3rc2/arch/arm/mach-vt8500/include/mach/wm8650_irqs.h
--- linux-3.3-rc2/arch/arm/mach-vt8500/include/mach/wm8650_irqs.h	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/include/mach/wm8650_irqs.h	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,120 @@
+/*
+ *  Copyright (C) 2011 Alexey Charkov <alchark@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* WM8650 Interrupt Sources */
+
+/* Interrupt Controller 0 */
+#define IRQ_SDMMC1	0
+#define IRQ_SDMMC1_DMA	1
+#define IRQ_APBB	2
+#define IRQ_ATA		3
+#define IRQ_SMC		4
+#define IRQ_DSP		5
+#define IRQ_GPIO	6
+#define IRQ_XD		7
+#define IRQ_XD_DMA	8
+#define IRQ_LCD		9
+#define IRQ_ETHER	10
+#define IRQ_DMA0	11
+#define IRQ_DMA1	12
+#define IRQ_DMA2	13
+#define IRQ_DMA3	14
+#define IRQ_DMA4	15
+#define IRQ_DMA5	16
+#define IRQ_DMA6	17
+#define IRQ_ETHER1	17	/* from vendor's fake PCI bus config space */
+#define IRQ_DMA7	18
+#define IRQ_I2C0	19
+#define IRQ_SDMMC	20
+#define IRQ_SDMMC_DMA	21
+#define IRQ_PMC_WU	22
+#define IRQ_KEYPAD	23
+#define IRQ_SPI0	24
+#define IRQ_ROT		25
+#define IRQ_SUS_GPIO0	26
+#define IRQ_SUS_GPIO1	27
+#define IRQ_NAND	28
+#define IRQ_NAND_DMA	29
+#define IRQ_MSC		30
+#define IRQ_MSC_DMA	31
+#define IRQ_UART0	32
+#define IRQ_UART1	33
+#define IRQ_I2C1	34      /* I2S controller                   */
+/* Reserved		35 */
+#define IRQ_PMCOS0	36      /* OS Timer match 0                 */
+#define IRQ_PMCOS1	37      /* OS Timer match 1                 */
+#define IRQ_PMCOS2	38      /* OS Timer match 2                 */
+#define IRQ_PMCOS3	39      /* OS Timer match 3                 */
+/* Reserved		40  */
+/* Reserved		41  */
+/* Reserved		42  */
+#define IRQ_EHCI	43
+#define IRQ_UHCI	43
+#define IRQ_DMA8	44
+#define IRQ_DMA9	45
+#define IRQ_DMA10	46
+#define IRQ_DMA11	47
+#define IRQ_RTC		48
+#define IRQ_RTCSM	49
+#define IRQ_DMA12	50
+#define IRQ_DMA13	51
+#define IRQ_DMA14	52
+#define IRQ_DMA15	53
+/* Reserved		54  */
+#define IRQ_CIR		55
+#define IRQ_SIC0	56
+#define IRQ_SIC1	57
+#define IRQ_SIC2	58
+#define IRQ_SIC3	59
+#define IRQ_SIC4	60
+#define IRQ_SIC5	61
+#define IRQ_SIC6	62
+#define IRQ_SIC7	63
+
+/* Interrupt Controller 1 */
+#define IRQ_VPP0	64
+#define IRQ_VPP1	65
+#define IRQ_VPP2	66
+#define IRQ_VPP3	67
+#define IRQ_VPP4	68
+#define IRQ_VPP5	69
+#define IRQ_VPP6	70
+#define IRQ_VPP7	71
+#define IRQ_VPP8	72
+#define IRQ_VPP9	73
+#define IRQ_VPP10	74
+#define IRQ_VPP11	75
+#define IRQ_VPP12	76
+#define IRQ_VPP13	77
+#define IRQ_VPP14	78
+#define IRQ_VPP15	79
+#define IRQ_VPP16	80 	/* NA12								*/
+#define IRQ_VPP17	81 	/* NA12								*/
+#define IRQ_VPP18	82 	/* NA12								*/
+#define IRQ_DZ_0	83		/*AUDPRF*/
+#define IRQ_DZ_1	84
+#define IRQ_DZ_2	85
+#define IRQ_DZ_3	86
+#define IRQ_DZ_4	87
+#define IRQ_DZ_5	88
+#define IRQ_DZ_6	89
+#define IRQ_DZ_7	90
+#define IRQ_DZ_8	91
+/* Reserved		92 ~ 127 */
+
+#define WM8650_NR_IRQS	91
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/include/mach/wm8650_regs.h wm8505-3.3rc2/arch/arm/mach-vt8500/include/mach/wm8650_regs.h
--- linux-3.3-rc2/arch/arm/mach-vt8500/include/mach/wm8650_regs.h	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/include/mach/wm8650_regs.h	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,121 @@
+/*
+ *  Copyright (C) 2010 Alexey Charkov <alchark@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_WM8650_REGS_H
+#define __ASM_ARM_ARCH_WM8650_REGS_H
+
+/* WM8650 Registers Map */
+
+#define WM8650_REGS_START_PHYS	0xd8000000	/* Start of MMIO registers */
+#define WM8650_REGS_START_VIRT	0xf8000000	/* Virtual mapping start */
+
+/* AHB Slaves */
+
+#define WM8650_DDR_BASE		0xd8000400	/* 1k	DDR/DDR2 Memory
+							Controller */
+#define WM8650_DMA_BASE		0xd8001800	/* 1k	DMA Controller */
+#define WM8650_VDMA_BASE	0xd8001c00	/* 1k	VDMA ("Pictor"?) */
+#define WM8650_SFLASH_BASE	0xd8002000	/* 1k	Serial Flash Memory
+							Controller */
+#define WM8650_SPIMEM_BASE	0xd8003000	/* 1k	SPI/LPC Memory */
+#define WM8650_ETHER_BASE	0xd8004000	/* 1k	Ethernet MAC 0 */
+#define WM8650_ETHER1_BASE	0xd8005000	/* 1k	Ethernet MAC 1 */
+#define WM8650_CIPHER_BASE	0xd8006000	/* 4k	Cipher
+							(Security Engine) */
+# define WM8650_CIPHER_EXT_BASE	0xd8006400	/* 3k	Security Engine
+							Extended regs */
+#define WM8650_USB_HOST_BASE	0xd8007000	/* 2k	USB 2.0 Host */
+#define WM8650_USB_HDC_BASE	0xd8007800	/* 2k	USB Host/Device */
+# define WM8650_EHCI_BASE	0xd8007900	/*	EHCI */
+# define WM8650_UHCI_BASE	0xd8007b00	/*	UHCI */
+#define WM8650_PATA_BASE	0xd8008000	/* 2k	PATA Controller */
+#define WM8650_PS2_BASE		0xd8008800	/* 1k	PS/2 */
+#define WM8650_USB_HOST2_BASE	0xd8008c00	/* 1k	USB 2.0 Extra Host */
+# define WM8650_UHCI2_BASE	0xd8008d00	/*	Extra UHCI */
+#define WM8650_NAND_BASE	0xd8009000	/* 1k	NAND Controller */
+#define WM8650_NOR_BASE		0xd8009400	/* 1k	NOR Controller */
+#define WM8650_USB_DEV_BASE	0xd8009800	/* 2k	USB slave (device) */
+#define WM8650_SDMMC_BASE	0xd800a000	/* 1k	SD/MMC Controller */
+#define WM8650_SDMMC1_BASE	0xd800a400	/* 1k	SD/MMC Controller 1 */
+#define WM8650_VPU_BASE		0xd8050100	/* 512	VPU */
+#define WM8650_GOV_BASE		0xd8050300	/* 256	GOV */
+#define WM8650_GEGEA_BASE	0xd8050400	/* 768	GE/GE Alpha Mixing */
+#define WM8650_DISP_BASE	0xd8050700	/* 256	Display? */
+#define WM8650_GOVR_BASE	0xd8050800	/* 512	GOVR (frambuffer) */
+#define WM8650_VID_BASE		0xd8050a00	/* 256	VID */
+#define WM8650_HDTV_BASE	0xd8050b00	/* 256	HDTV */
+#define WM8650_GOVW_BASE	0xd8050c00	/* 256	GOVW */
+#define WM8650_SCL_BASE		0xd8050d00	/* 512	SCL */
+#define WM8650_VPP_BASE		0xd8050f00	/* 256	VPP */
+#define WM8650_HDMITX_BASE	0xd8060000	/* 64k	HDMI Transmitter */
+#define WM8650_HDCP_BASE	0xd8070000	/* 64k	HDCP Controller */
+#define WM8650_USB_OTG_BASE	0xd80e4000	/* 16k	USB On-the-Go */
+#define WM8650_I2S_BASE		0xd80ed800	/* 2k	I2S */
+#define WM8650_DSSMBOX_BASE	0xd80ee000	/* 1k	DSS MBOX */
+#define WM8650_DSSPERM_BASE	0xd80ee400	/* 1k	DSS PERM */
+#define WM8650_VDU_BASE		0xd80d0000	/* 1k	VDU */
+#define WM8650_SCRCNT_BASE	0xd80d0400	/* 256	SCRCNT */
+#define WM8650_VLDBUF_BASE	0xd80d1000	/* 1k	VLDBUF */
+#define WM8650_IQ_BASE		0xd80f1400	/* 1k	IQ */
+#define WM8650_IDCT_BASE	0xd80f1800	/* 1k	IDCT */
+#define WM8650_STREAMIN_BASE	0xd80f2000	/* 1k	STREAMIN */
+#define WM8650_CSS_FIFO_BASE	0xd80f3000	/* 1k	CSS FIFO */
+#define WM8650_AVBO_FIFO_BASE	0xd80f3400	/* 1k	AVBO FIFO */
+#define WM8650_SPU_FIFO_BASE	0xd80f3800	/* 1k	SPU FIFO */
+#define WM8650_TSIN0_BASE	0xd80f4000	/* 4k	TS IN 0 */
+#define WM8650_TSIN1_BASE	0xd80f5000	/* 4k	TS IN 1 */
+#define WM8650_TSIN2_BASE	0xd80f6000	/* 4k	TS IN 2 */
+#define WM8650_TSOUT_BASE	0xd80f7000	/* 4k	TS OUT */
+#define WM8650_H264DEC_BASE	0xd80f8000	/* 16k	H264 Decoder */
+#define WM8650_JPEGDEC_BASE	0xd80fe000	/* 4k	JPEG Decoder */
+#define WM8650_JPEGENC_BASE	0xd80ff000	/* 4k	JPEG Encoder */
+
+/* APB Slaves */
+
+#define WM8650_RTC_BASE		0xd8100000	/* 64k	RTC */
+#define WM8650_GPIO_BASE	0xd8110000	/* 64k	GPIO Configuration */
+#define WM8650_SCC_BASE		0xd8120000	/* 64k	System Configuration*/
+#define WM8650_PMC_BASE		0xd8130000	/* 64k	PMC Configuration */
+#define WM8650_IC_BASE		0xd8140000	/* 64k	Interrupt Controller*/
+#define WM8650_SIC_BASE		0xd8150000	/* 64k	Secondary IC */
+#define WM8650_AUDIOCODEC_BASE	0xd81f0000	/* 64k	Audio Codec */
+#define WM8650_UART0_BASE	0xd8200000	/* 64k	UART 0 */
+#define WM8650_UART2_BASE	0xd8210000	/* 64k	UART 2 */
+#define WM8650_PWM_BASE		0xd8220000	/* 64k	PWM Configuration */
+#define WM8650_SPI0_BASE	0xd8240000	/* 64k	SPI 0 */
+#define WM8650_SPI1_BASE	0xd8250000	/* 64k	SPI 1 */
+#define WM8650_KEYPAD_BASE	0xd8260000	/* 64k	Keypad control */
+#define WM8650_CIR_BASE		0xd8270000	/* 64k	CIR */
+#define WM8650_I2C0_BASE	0xd8280000	/* 64k	I2C 0 */
+#define WM8650_AC97_BASE	0xd8290000	/* 64k	AC97 */
+#define WM8650_SPI2_BASE	0xd82a0000	/* 64k	SPI 2 */
+#define WM8650_UART1_BASE	0xd82b0000	/* 64k	UART 1 */
+#define WM8650_UART3_BASE	0xd82c0000	/* 64k	UART 3 */
+#define WM8650_PCM_BASE		0xd82d0000	/* 64k	PCM */
+#define WM8650_I2C1_BASE	0xd8320000	/* 64k	I2C 1 */
+#define WM8650_ADC_BASE		0xd8340000	/* 64k	ADC */
+#define WM8650_ROTARY_BASE	0xd8350000	/* 64k	Rotary detector */
+#define WM8650_SCIF_BASE	0xd8360000	/* 64k	Smart Card IF */
+#define WM8650_UART4_BASE	0xd8370000	/* 64k	UART 4 */
+#define WM8650_UART5_BASE	0xd8380000	/* 64k	UART 5 */
+#define WM8650_POWER_MOS_BASE	0xd8390000	/* 64k	Power MOS */
+
+#define WM8650_REGS_END_PHYS	0xd839ffff	/* End of MMIO registers */
+#define WM8650_REGS_LENGTH	(WM8650_REGS_END_PHYS \
+				- WM8650_REGS_START_PHYS + 1)
+
+#endif
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/Kconfig wm8505-3.3rc2/arch/arm/mach-vt8500/Kconfig
--- linux-3.3-rc2/arch/arm/mach-vt8500/Kconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/Kconfig	2012-02-06 12:27:43.000000000 -0700
@@ -6,6 +6,9 @@
 config VTWM_VERSION_WM8505
 	bool
 
+config VTWM_VERSION_WM8650
+	bool
+
 config MACH_BV07
 	bool "Benign BV07-8500 Mini Netbook"
 	depends on ARCH_VT8500
@@ -26,6 +29,15 @@
 	  many hardware implementations in identical exterior, make sure
 	  that yours is indeed based on a WonderMedia WM8505 chip.
 
+config MACH_WM8650REFBOARD
+	bool "WM8650 reference board"
+	depends on ARCH_VT8500
+	select VTWM_VERSION_WM8650
+	help
+	  Add support for netbooks, tablets and other devices based on
+	  the reference board design as produced by WonderMedia, using
+	  WM8650 System-on-Chip.
+
 comment "LCD panel size"
 
 config WMT_PANEL_800X480
@@ -70,4 +82,14 @@
 	  'panel=1024x600' to your kernel command line. Otherwise, the
 	  largest one available will be used.
 
+config WMT_PANEL_1024X768
+	bool "VGA output at 1024x768 resolution"
+	depends on (FB_VT8500)
+	help
+	  These are found in Kaser YF-700 thin clients and possibly elsewhere.
+
+	  To select this panel at runtime, say y here and append
+	  'panel=1024x768' to your kernel command line. Otherwise, the
+	  largest one available will be used.
+
 endif
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/Makefile wm8505-3.3rc2/arch/arm/mach-vt8500/Makefile
--- linux-3.3-rc2/arch/arm/mach-vt8500/Makefile	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/Makefile	2012-02-06 12:27:43.000000000 -0700
@@ -1,9 +1,11 @@
-obj-y += devices.o gpio.o irq.o timer.o
+obj-y += devices.o irq.o timer.o
 
-obj-$(CONFIG_VTWM_VERSION_VT8500) += devices-vt8500.o
-obj-$(CONFIG_VTWM_VERSION_WM8505) += devices-wm8505.o
+obj-$(CONFIG_VTWM_VERSION_VT8500) += devices-vt8500.o gpio-vt8500.o
+obj-$(CONFIG_VTWM_VERSION_WM8505) += devices-wm8505.o gpio-wm8505.o
+obj-$(CONFIG_VTWM_VERSION_WM8650) += devices-wm8650.o gpio-wm8650.o
 
 obj-$(CONFIG_MACH_BV07) += bv07.o
 obj-$(CONFIG_MACH_WM8505_7IN_NETBOOK) += wm8505_7in.o
+obj-$(CONFIG_MACH_WM8650REFBOARD) += wm8650ref.o
 
 obj-$(CONFIG_HAVE_PWM) += pwm.o
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/wm8505_7in.c wm8505-3.3rc2/arch/arm/mach-vt8500/wm8505_7in.c
--- linux-3.3-rc2/arch/arm/mach-vt8500/wm8505_7in.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/wm8505_7in.c	2012-02-06 12:27:43.000000000 -0700
@@ -31,11 +31,14 @@
 static struct platform_device *devices[] __initdata = {
 	&vt8500_device_uart0,
 	&vt8500_device_ehci,
+	&vt8500_device_velocity,
 	&vt8500_device_wm8505_fb,
 	&vt8500_device_ge_rops,
 	&vt8500_device_pwm,
 	&vt8500_device_pwmbl,
 	&vt8500_device_rtc,
+	&vt8500_device_sdmmc,
+	&vt8500_device_nand,
 };
 
 static void vt8500_power_off(void)
@@ -64,7 +67,7 @@
 
 	wm8505_set_resources();
 	platform_add_devices(devices, ARRAY_SIZE(devices));
-	vt8500_gpio_init();
+	wm8505_gpio_init();
 }
 
 MACHINE_START(WM8505_7IN_NETBOOK, "WM8505 7-inch generic netbook")
diff -Naur linux-3.3-rc2/arch/arm/mach-vt8500/wm8650ref.c wm8505-3.3rc2/arch/arm/mach-vt8500/wm8650ref.c
--- linux-3.3-rc2/arch/arm/mach-vt8500/wm8650ref.c	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mach-vt8500/wm8650ref.c	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,82 @@
+/*
+ *  arch/arm/mach-vt8500/wm8650ref.c
+ *
+ *  Copyright (C) 2011 Alexey Charkov <alchark@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/io.h>
+#include <linux/pm.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+#include "devices.h"
+
+static void __iomem *pmc_hiber;
+
+static struct platform_device *devices[] __initdata = {
+	&vt8500_device_uart0,
+	&vt8500_device_ehci,
+	&vt8500_device_uhci,
+	&vt8500_device_rhine0,
+	&vt8500_device_rhine1,
+	&vt8500_device_wm8505_fb,
+	&vt8500_device_ge_rops,
+	&vt8500_device_pwm,
+	&vt8500_device_pwmbl,
+	&vt8500_device_rtc,
+	&vt8500_device_sdmmc,
+	&vt8500_device_nand,
+};
+
+static void vt8500_power_off(void)
+{
+	local_irq_disable();
+	writew(5, pmc_hiber);
+	asm("mcr%? p15, 0, %0, c7, c0, 4" : : "r" (0));
+}
+
+void __init wm8650ref_init(void)
+{
+#ifdef CONFIG_FB_WM8505
+	void __iomem *gpio_mux_reg = ioremap(wmt_gpio_base + 0x200, 4);
+	if (gpio_mux_reg) {
+		writel(readl(gpio_mux_reg) | 0x80000000, gpio_mux_reg);
+		iounmap(gpio_mux_reg);
+	} else {
+		printk(KERN_ERR "Could not remap the GPIO mux register, display may not work properly!\n");
+	}
+#endif
+	pmc_hiber = ioremap(wmt_pmc_base + 0x12, 2);
+	if (pmc_hiber)
+		pm_power_off = &vt8500_power_off;
+	else
+		printk(KERN_ERR "PMC Hibernation register could not be remapped, not enabling power off!\n");
+
+	wm8650_set_resources();
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+	wm8650_gpio_init();
+}
+
+MACHINE_START(WM8650REFBOARD, "WM8650 reference board")
+	.atag_offset	= 0x100,
+	.reserve	= wm8650_reserve_mem,
+	.map_io		= wm8650_map_io,
+	.init_irq	= wm8505_init_irq,
+	.timer		= &vt8500_timer,
+	.init_machine	= wm8650ref_init,
+MACHINE_END
diff -Naur linux-3.3-rc2/arch/arm/mm/ioremap.c wm8505-3.3rc2/arch/arm/mm/ioremap.c
--- linux-3.3-rc2/arch/arm/mm/ioremap.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/arm/mm/ioremap.c	2012-02-06 12:27:43.000000000 -0700
@@ -225,8 +225,7 @@
 		if ((area->flags & VM_ARM_MTYPE_MASK) != VM_ARM_MTYPE(mtype))
 			continue;
 		if (__phys_to_pfn(area->phys_addr) > pfn ||
-		    __pfn_to_phys(pfn) + offset + size-1 >
-		    area->phys_addr + area->size-1)
+		    __pfn_to_phys(pfn) + size-1 > area->phys_addr + area->size-1)
 			continue;
 		/* we can drop the lock here as we know *area is static */
 		read_unlock(&vmlist_lock);
diff -Naur linux-3.3-rc2/arch/avr32/Kconfig wm8505-3.3rc2/arch/avr32/Kconfig
--- linux-3.3-rc2/arch/avr32/Kconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/avr32/Kconfig	2012-02-06 12:27:43.000000000 -0700
@@ -8,6 +8,7 @@
 	select HAVE_KPROBES
 	select HAVE_GENERIC_HARDIRQS
 	select GENERIC_IRQ_PROBE
+	select GENERIC_ATOMIC64
 	select HARDIRQS_SW_RESEND
 	select GENERIC_IRQ_SHOW
 	select ARCH_HAVE_NMI_SAFE_CMPXCHG
diff -Naur linux-3.3-rc2/arch/microblaze/kernel/setup.c wm8505-3.3rc2/arch/microblaze/kernel/setup.c
--- linux-3.3-rc2/arch/microblaze/kernel/setup.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/microblaze/kernel/setup.c	2012-02-06 12:27:43.000000000 -0700
@@ -26,7 +26,6 @@
 #include <linux/cache.h>
 #include <linux/of_platform.h>
 #include <linux/dma-mapping.h>
-#include <linux/cpu.h>
 #include <asm/cacheflush.h>
 #include <asm/entry.h>
 #include <asm/cpuinfo.h>
@@ -227,23 +226,5 @@
 
 	return 0;
 }
-arch_initcall(setup_bus_notifier);
-
-static DEFINE_PER_CPU(struct cpu, cpu_devices);
-
-static int __init topology_init(void)
-{
-	int i, ret;
-
-	for_each_present_cpu(i) {
-		struct cpu *c = &per_cpu(cpu_devices, i);
 
-		ret = register_cpu(c, i);
-		if (ret)
-			printk(KERN_WARNING "topology_init: register_cpu %d "
-						"failed (%d)\n", i, ret);
-	}
-
-	return 0;
-}
-subsys_initcall(topology_init);
+arch_initcall(setup_bus_notifier);
diff -Naur linux-3.3-rc2/arch/mips/alchemy/common/time.c wm8505-3.3rc2/arch/mips/alchemy/common/time.c
--- linux-3.3-rc2/arch/mips/alchemy/common/time.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/mips/alchemy/common/time.c	2012-02-06 12:27:43.000000000 -0700
@@ -146,7 +146,7 @@
 	cd->shift = 32;
 	cd->mult = div_sc(32768, NSEC_PER_SEC, cd->shift);
 	cd->max_delta_ns = clockevent_delta2ns(0xffffffff, cd);
-	cd->min_delta_ns = clockevent_delta2ns(9, cd);	/* ~0.28ms */
+	cd->min_delta_ns = clockevent_delta2ns(8, cd);	/* ~0.25ms */
 	clockevents_register_device(cd);
 	setup_irq(m2int, &au1x_rtcmatch2_irqaction);
 
diff -Naur linux-3.3-rc2/arch/mips/ath79/dev-wmac.c wm8505-3.3rc2/arch/mips/ath79/dev-wmac.c
--- linux-3.3-rc2/arch/mips/ath79/dev-wmac.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/mips/ath79/dev-wmac.c	2012-02-06 12:27:43.000000000 -0700
@@ -96,7 +96,7 @@
 {
 	if (soc_is_ar913x())
 		ar913x_wmac_setup();
-	else if (soc_is_ar933x())
+	if (soc_is_ar933x())
 		ar933x_wmac_setup();
 	else
 		BUG();
diff -Naur linux-3.3-rc2/arch/mips/configs/nlm_xlp_defconfig wm8505-3.3rc2/arch/mips/configs/nlm_xlp_defconfig
--- linux-3.3-rc2/arch/mips/configs/nlm_xlp_defconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/mips/configs/nlm_xlp_defconfig	2012-02-06 12:27:43.000000000 -0700
@@ -8,7 +8,7 @@
 # CONFIG_SECCOMP is not set
 CONFIG_USE_OF=y
 CONFIG_EXPERIMENTAL=y
-CONFIG_CROSS_COMPILE=""
+CONFIG_CROSS_COMPILE="mips-linux-gnu-"
 # CONFIG_LOCALVERSION_AUTO is not set
 CONFIG_SYSVIPC=y
 CONFIG_POSIX_MQUEUE=y
@@ -22,7 +22,7 @@
 CONFIG_CGROUPS=y
 CONFIG_NAMESPACES=y
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
+CONFIG_INITRAMFS_SOURCE="usr/dev_file_list usr/rootfs.xlp"
 CONFIG_RD_BZIP2=y
 CONFIG_RD_LZMA=y
 CONFIG_INITRAMFS_COMPRESSION_LZMA=y
diff -Naur linux-3.3-rc2/arch/mips/configs/nlm_xlr_defconfig wm8505-3.3rc2/arch/mips/configs/nlm_xlr_defconfig
--- linux-3.3-rc2/arch/mips/configs/nlm_xlr_defconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/mips/configs/nlm_xlr_defconfig	2012-02-06 12:27:43.000000000 -0700
@@ -8,7 +8,7 @@
 CONFIG_PREEMPT_VOLUNTARY=y
 CONFIG_KEXEC=y
 CONFIG_EXPERIMENTAL=y
-CONFIG_CROSS_COMPILE=""
+CONFIG_CROSS_COMPILE="mips-linux-gnu-"
 # CONFIG_LOCALVERSION_AUTO is not set
 CONFIG_SYSVIPC=y
 CONFIG_POSIX_MQUEUE=y
@@ -22,7 +22,7 @@
 CONFIG_NAMESPACES=y
 CONFIG_SCHED_AUTOGROUP=y
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
+CONFIG_INITRAMFS_SOURCE="usr/dev_file_list usr/rootfs.xlr"
 CONFIG_RD_BZIP2=y
 CONFIG_RD_LZMA=y
 CONFIG_INITRAMFS_COMPRESSION_GZIP=y
diff -Naur linux-3.3-rc2/arch/mips/configs/powertv_defconfig wm8505-3.3rc2/arch/mips/configs/powertv_defconfig
--- linux-3.3-rc2/arch/mips/configs/powertv_defconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/mips/configs/powertv_defconfig	2012-02-06 12:27:43.000000000 -0700
@@ -6,7 +6,7 @@
 CONFIG_PREEMPT=y
 # CONFIG_SECCOMP is not set
 CONFIG_EXPERIMENTAL=y
-CONFIG_CROSS_COMPILE=""
+CONFIG_CROSS_COMPILE="mips-linux-"
 # CONFIG_SWAP is not set
 CONFIG_SYSVIPC=y
 CONFIG_LOG_BUF_SHIFT=16
diff -Naur linux-3.3-rc2/arch/mips/include/asm/mach-au1x00/gpio-au1300.h wm8505-3.3rc2/arch/mips/include/asm/mach-au1x00/gpio-au1300.h
--- linux-3.3-rc2/arch/mips/include/asm/mach-au1x00/gpio-au1300.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/mips/include/asm/mach-au1x00/gpio-au1300.h	2012-02-06 12:27:43.000000000 -0700
@@ -11,9 +11,6 @@
 #include <asm/io.h>
 #include <asm/mach-au1x00/au1000.h>
 
-struct gpio;
-struct gpio_chip;
-
 /* with the current GPIC design, up to 128 GPIOs are possible.
  * The only implementation so far is in the Au1300, which has 75 externally
  * available GPIOs.
@@ -206,22 +203,7 @@
 	return 0;
 }
 
-static inline int gpio_request_one(unsigned gpio,
-					unsigned long flags, const char *label)
-{
-	return 0;
-}
-
-static inline int gpio_request_array(struct gpio *array, size_t num)
-{
-	return 0;
-}
-
-static inline void gpio_free(unsigned gpio)
-{
-}
-
-static inline void gpio_free_array(struct gpio *array, size_t num)
+static inline void gpio_free(unsigned int gpio)
 {
 }
 
diff -Naur linux-3.3-rc2/arch/mips/include/asm/page.h wm8505-3.3rc2/arch/mips/include/asm/page.h
--- linux-3.3-rc2/arch/mips/include/asm/page.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/mips/include/asm/page.h	2012-02-06 12:27:43.000000000 -0700
@@ -39,6 +39,9 @@
 #define HPAGE_MASK	(~(HPAGE_SIZE - 1))
 #define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
 #else /* !CONFIG_HUGETLB_PAGE */
+# ifndef BUILD_BUG
+#  define BUILD_BUG() do { extern void __build_bug(void); __build_bug(); } while (0)
+# endif
 #define HPAGE_SHIFT	({BUILD_BUG(); 0; })
 #define HPAGE_SIZE	({BUILD_BUG(); 0; })
 #define HPAGE_MASK	({BUILD_BUG(); 0; })
diff -Naur linux-3.3-rc2/arch/mips/kernel/vmlinux.lds.S wm8505-3.3rc2/arch/mips/kernel/vmlinux.lds.S
--- linux-3.3-rc2/arch/mips/kernel/vmlinux.lds.S	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/mips/kernel/vmlinux.lds.S	2012-02-06 12:27:43.000000000 -0700
@@ -69,6 +69,7 @@
 	RODATA
 
 	/* writeable */
+	_sdata = .;				/* Start of data section */
 	.data : {	/* Data */
 		. = . + DATAOFFSET;		/* for CONFIG_MAPPED_KERNEL */
 
diff -Naur linux-3.3-rc2/arch/mips/mm/fault.c wm8505-3.3rc2/arch/mips/mm/fault.c
--- linux-3.3-rc2/arch/mips/mm/fault.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/mips/mm/fault.c	2012-02-06 12:27:43.000000000 -0700
@@ -42,8 +42,6 @@
 	const int field = sizeof(unsigned long) * 2;
 	siginfo_t info;
 	int fault;
-	unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE |
-						 (write ? FAULT_FLAG_WRITE : 0);
 
 #if 0
 	printk("Cpu%d[%s:%d:%0*lx:%ld:%0*lx]\n", raw_smp_processor_id(),
@@ -93,7 +91,6 @@
 	if (in_atomic() || !mm)
 		goto bad_area_nosemaphore;
 
-retry:
 	down_read(&mm->mmap_sem);
 	vma = find_vma(mm, address);
 	if (!vma)
@@ -147,11 +144,7 @@
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.
 	 */
-	fault = handle_mm_fault(mm, vma, address, flags);
-
-	if ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))
-		return;
-
+	fault = handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0);
 	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
@@ -160,27 +153,12 @@
 			goto do_sigbus;
 		BUG();
 	}
-	if (flags & FAULT_FLAG_ALLOW_RETRY) {
-		if (fault & VM_FAULT_MAJOR) {
-			perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,
-						  regs, address);
-			tsk->maj_flt++;
-		} else {
-			perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,
-						  regs, address);
-			tsk->min_flt++;
-		}
-		if (fault & VM_FAULT_RETRY) {
-			flags &= ~FAULT_FLAG_ALLOW_RETRY;
-
-			/*
-			 * No need to up_read(&mm->mmap_sem) as we would
-			 * have already released it in __lock_page_or_retry
-			 * in mm/filemap.c.
-			 */
-
-			goto retry;
-		}
+	if (fault & VM_FAULT_MAJOR) {
+		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);
+		tsk->maj_flt++;
+	} else {
+		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);
+		tsk->min_flt++;
 	}
 
 	up_read(&mm->mmap_sem);
diff -Naur linux-3.3-rc2/arch/mips/pci/pci.c wm8505-3.3rc2/arch/mips/pci/pci.c
--- linux-3.3-rc2/arch/mips/pci/pci.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/mips/pci/pci.c	2012-02-06 12:27:43.000000000 -0700
@@ -279,6 +279,7 @@
 {
 	/* Propagate hose info into the subordinate devices.  */
 
+	struct list_head *ln;
 	struct pci_dev *dev = bus->self;
 
 	if (pci_probe_only && dev &&
@@ -287,7 +288,9 @@
 		pcibios_fixup_device_resources(dev, bus);
 	}
 
-	list_for_each_entry(dev, &bus->devices, bus_list) {
+	for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
+		dev = pci_dev_b(ln);
+
 		if ((dev->class >> 8) != PCI_CLASS_BRIDGE_PCI)
 			pcibios_fixup_device_resources(dev, bus);
 	}
diff -Naur linux-3.3-rc2/arch/mips/pmc-sierra/yosemite/ht-irq.c wm8505-3.3rc2/arch/mips/pmc-sierra/yosemite/ht-irq.c
--- linux-3.3-rc2/arch/mips/pmc-sierra/yosemite/ht-irq.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/mips/pmc-sierra/yosemite/ht-irq.c	2012-02-06 12:27:43.000000000 -0700
@@ -35,6 +35,16 @@
  */
 void __init titan_ht_pcibios_fixup_bus(struct pci_bus *bus)
 {
+	struct pci_bus *current_bus = bus;
+	struct pci_dev *devices;
+	struct list_head *devices_link;
+
+	list_for_each(devices_link, &(current_bus->devices)) {
+		devices = pci_dev_b(devices_link);
+		if (devices == NULL)
+			continue;
+	}
+
 	/*
 	 * PLX and SPKT related changes go here
 	 */
diff -Naur linux-3.3-rc2/arch/mips/txx9/generic/7segled.c wm8505-3.3rc2/arch/mips/txx9/generic/7segled.c
--- linux-3.3-rc2/arch/mips/txx9/generic/7segled.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/mips/txx9/generic/7segled.c	2012-02-06 12:27:43.000000000 -0700
@@ -102,7 +102,7 @@
 			break;
 		}
 		dev->id = i;
-		dev->bus = &tx_7segled_subsys;
+		dev->dev = &tx_7segled_subsys;
 		error = device_register(dev);
 		if (!error) {
 			device_create_file(dev, &dev_attr_ascii);
diff -Naur linux-3.3-rc2/arch/sparc/Kconfig wm8505-3.3rc2/arch/sparc/Kconfig
--- linux-3.3-rc2/arch/sparc/Kconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/sparc/Kconfig	2012-02-06 12:27:43.000000000 -0700
@@ -33,6 +33,7 @@
 config SPARC32
 	def_bool !64BIT
 	select GENERIC_ATOMIC64
+	select CLZ_TAB
 
 config SPARC64
 	def_bool 64BIT
diff -Naur linux-3.3-rc2/arch/sparc/lib/divdi3.S wm8505-3.3rc2/arch/sparc/lib/divdi3.S
--- linux-3.3-rc2/arch/sparc/lib/divdi3.S	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/sparc/lib/divdi3.S	2012-02-06 12:27:43.000000000 -0700
@@ -17,23 +17,9 @@
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
-	.data
-	.align 8
-	.globl	__clz_tab
-__clz_tab:
-	.byte	0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
-	.byte	6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6
-	.byte	7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
-	.byte	7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
-	.byte	8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
-	.byte	8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
-	.byte	8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
-	.byte	8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
-	.size	 __clz_tab,256
-	.global .udiv
-
 	.text
 	.align 4
+	.global .udiv
 	.globl __divdi3
 __divdi3:
 	save %sp,-104,%sp
diff -Naur linux-3.3-rc2/arch/x86/include/asm/cmpxchg.h wm8505-3.3rc2/arch/x86/include/asm/cmpxchg.h
--- linux-3.3-rc2/arch/x86/include/asm/cmpxchg.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/x86/include/asm/cmpxchg.h	2012-02-06 12:27:43.000000000 -0700
@@ -145,13 +145,13 @@
 
 #ifdef __HAVE_ARCH_CMPXCHG
 #define cmpxchg(ptr, old, new)						\
-	__cmpxchg((ptr), (old), (new), sizeof(*ptr))
+	__cmpxchg(ptr, old, new, sizeof(*(ptr)))
 
 #define sync_cmpxchg(ptr, old, new)					\
-	__sync_cmpxchg((ptr), (old), (new), sizeof(*ptr))
+	__sync_cmpxchg(ptr, old, new, sizeof(*(ptr)))
 
 #define cmpxchg_local(ptr, old, new)					\
-	__cmpxchg_local((ptr), (old), (new), sizeof(*ptr))
+	__cmpxchg_local(ptr, old, new, sizeof(*(ptr)))
 #endif
 
 /*
diff -Naur linux-3.3-rc2/arch/x86/kernel/dumpstack_64.c wm8505-3.3rc2/arch/x86/kernel/dumpstack_64.c
--- linux-3.3-rc2/arch/x86/kernel/dumpstack_64.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/x86/kernel/dumpstack_64.c	2012-02-06 12:27:43.000000000 -0700
@@ -129,7 +129,7 @@
 	if (!stack) {
 		if (regs)
 			stack = (unsigned long *)regs->sp;
-		else if (task && task != current)
+		else if (task != current)
 			stack = (unsigned long *)task->thread.sp;
 		else
 			stack = &dummy;
@@ -269,11 +269,11 @@
 		unsigned char c;
 		u8 *ip;
 
-		printk(KERN_EMERG "Stack:\n");
+		printk(KERN_DEFAULT "Stack:\n");
 		show_stack_log_lvl(NULL, regs, (unsigned long *)sp,
-				   0, KERN_EMERG);
+				   0, KERN_DEFAULT);
 
-		printk(KERN_EMERG "Code: ");
+		printk(KERN_DEFAULT "Code: ");
 
 		ip = (u8 *)regs->ip - code_prologue;
 		if (ip < (u8 *)PAGE_OFFSET || probe_kernel_address(ip, c)) {
diff -Naur linux-3.3-rc2/arch/x86/kernel/dumpstack.c wm8505-3.3rc2/arch/x86/kernel/dumpstack.c
--- linux-3.3-rc2/arch/x86/kernel/dumpstack.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/x86/kernel/dumpstack.c	2012-02-06 12:27:43.000000000 -0700
@@ -252,7 +252,8 @@
 	unsigned short ss;
 	unsigned long sp;
 #endif
-	printk(KERN_EMERG "%s: %04lx [#%d] ", str, err & 0xffff, ++die_counter);
+	printk(KERN_DEFAULT
+	       "%s: %04lx [#%d] ", str, err & 0xffff, ++die_counter);
 #ifdef CONFIG_PREEMPT
 	printk("PREEMPT ");
 #endif
diff -Naur linux-3.3-rc2/arch/x86/kernel/reboot.c wm8505-3.3rc2/arch/x86/kernel/reboot.c
--- linux-3.3-rc2/arch/x86/kernel/reboot.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/x86/kernel/reboot.c	2012-02-06 12:27:43.000000000 -0700
@@ -39,6 +39,14 @@
 enum reboot_type reboot_type = BOOT_ACPI;
 int reboot_force;
 
+/* This variable is used privately to keep track of whether or not
+ * reboot_type is still set to its default value (i.e., reboot= hasn't
+ * been set on the command line).  This is needed so that we can
+ * suppress DMI scanning for reboot quirks.  Without it, it's
+ * impossible to override a faulty reboot quirk without recompiling.
+ */
+static int reboot_default = 1;
+
 #if defined(CONFIG_X86_32) && defined(CONFIG_SMP)
 static int reboot_cpu = -1;
 #endif
@@ -67,6 +75,12 @@
 static int __init reboot_setup(char *str)
 {
 	for (;;) {
+		/* Having anything passed on the command line via
+		 * reboot= will cause us to disable DMI checking
+		 * below.
+		 */
+		reboot_default = 0;
+
 		switch (*str) {
 		case 'w':
 			reboot_mode = 0x1234;
@@ -295,14 +309,6 @@
 			DMI_MATCH(DMI_BOARD_NAME, "P4S800"),
 		},
 	},
-	{	/* Handle problems with rebooting on VersaLogic Menlow boards */
-		.callback = set_bios_reboot,
-		.ident = "VersaLogic Menlow based board",
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "VersaLogic Corporation"),
-			DMI_MATCH(DMI_BOARD_NAME, "VersaLogic Menlow board"),
-		},
-	},
 	{ /* Handle reboot issue on Acer Aspire one */
 		.callback = set_kbd_reboot,
 		.ident = "Acer Aspire One A110",
@@ -316,7 +322,12 @@
 
 static int __init reboot_init(void)
 {
-	dmi_check_system(reboot_dmi_table);
+	/* Only do the DMI check if reboot_type hasn't been overridden
+	 * on the command line
+	 */
+	if (reboot_default) {
+		dmi_check_system(reboot_dmi_table);
+	}
 	return 0;
 }
 core_initcall(reboot_init);
@@ -465,7 +476,12 @@
 
 static int __init pci_reboot_init(void)
 {
-	dmi_check_system(pci_reboot_dmi_table);
+	/* Only do the DMI check if reboot_type hasn't been overridden
+	 * on the command line
+	 */
+	if (reboot_default) {
+		dmi_check_system(pci_reboot_dmi_table);
+	}
 	return 0;
 }
 core_initcall(pci_reboot_init);
diff -Naur linux-3.3-rc2/arch/x86/mm/fault.c wm8505-3.3rc2/arch/x86/mm/fault.c
--- linux-3.3-rc2/arch/x86/mm/fault.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/x86/mm/fault.c	2012-02-06 12:27:43.000000000 -0700
@@ -673,7 +673,7 @@
 
 	stackend = end_of_stack(tsk);
 	if (tsk != &init_task && *stackend != STACK_END_MAGIC)
-		printk(KERN_ALERT "Thread overran stack, or stack corrupted\n");
+		printk(KERN_EMERG "Thread overran stack, or stack corrupted\n");
 
 	tsk->thread.cr2		= address;
 	tsk->thread.trap_no	= 14;
@@ -684,7 +684,7 @@
 		sig = 0;
 
 	/* Executive summary in case the body of the oops scrolled away */
-	printk(KERN_EMERG "CR2: %016lx\n", address);
+	printk(KERN_DEFAULT "CR2: %016lx\n", address);
 
 	oops_end(flags, regs, sig);
 }
diff -Naur linux-3.3-rc2/arch/xtensa/include/asm/string.h wm8505-3.3rc2/arch/xtensa/include/asm/string.h
--- linux-3.3-rc2/arch/xtensa/include/asm/string.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/arch/xtensa/include/asm/string.h	2012-02-06 12:27:43.000000000 -0700
@@ -118,7 +118,4 @@
 /* Don't build bcopy at all ...  */
 #define __HAVE_ARCH_BCOPY
 
-#define __HAVE_ARCH_MEMSCAN
-#define memscan memchr
-
 #endif	/* _XTENSA_STRING_H */
diff -Naur linux-3.3-rc2/config wm8505-3.3rc2/config
--- linux-3.3-rc2/config	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/config	2012-08-07 15:15:14.000000000 -0700
@@ -0,0 +1,1706 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.3.0-rc2 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+CONFIG_ARCH_VT8500=y
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+
+#
+# System MMU
+#
+CONFIG_VTWM_VERSION_VT8500=y
+CONFIG_VTWM_VERSION_WM8505=y
+CONFIG_VTWM_VERSION_WM8650=y
+CONFIG_MACH_BV07=y
+CONFIG_MACH_WM8505_7IN_NETBOOK=y
+CONFIG_MACH_WM8650REFBOARD=y
+
+#
+# LCD panel size
+#
+CONFIG_WMT_PANEL_800X480=y
+# CONFIG_WMT_PANEL_800X600 is not set
+# CONFIG_WMT_PANEL_1024X576 is not set
+# CONFIG_WMT_PANEL_1024X600 is not set
+# CONFIG_WMT_PANEL_1024X768 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_NR_BANKS=8
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_BQL=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_HAS_RC=y
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+# CONFIG_MTD_CHAR is not set
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_WMT=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_MISC_DEVICES is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=y
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_FARADAY=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTGMAC100 is not set
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_MARVELL=y
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8851_MLL is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_AX88796 is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_VENDOR_SEEQ=y
+# CONFIG_SEEQ8005 is not set
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_SMC91X is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_RHINE is not set
+CONFIG_VIA_VELOCITY=y
+# CONFIG_PHYLIB is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_ATH_COMMON is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_BRCMFMAC is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_P54_COMMON is not set
+CONFIG_RT2X00=y
+# CONFIG_RT2500USB is not set
+# CONFIG_RT73USB is not set
+CONFIG_RT2800USB=y
+CONFIG_RT2800USB_RT33XX=y
+CONFIG_RT2800USB_RT35XX=y
+# CONFIG_RT2800USB_RT53XX is not set
+# CONFIG_RT2800USB_UNKNOWN is not set
+CONFIG_RT2800_LIB=y
+CONFIG_RT2X00_LIB_USB=y
+CONFIG_RT2X00_LIB=y
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2X00_LIB_CRYPTO=y
+# CONFIG_RT2X00_DEBUG is not set
+# CONFIG_RTL8192CU is not set
+# CONFIG_WL1251 is not set
+# CONFIG_WL12XX_MENU is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_MWIFIEX is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_VT8500=y
+CONFIG_SERIAL_VT8500_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+
+#
+# I2C GPIO expanders:
+#
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_WMT_GE_ROPS=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_VT8500=y
+CONFIG_FB_WM8505=y
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_PLATFORM is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_PWM=y
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EHCI_MV is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_UHCI_HCD=y
+CONFIG_USB_UHCI_SUPPORT_NON_PCI_HC=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+CONFIG_MMC_WMT=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_VT8500=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_IOMMU_SUPPORT=y
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_PM_DEVFREQ is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+CONFIG_BTRFS_FS=y
+# CONFIG_BTRFS_FS_POSIX_ACL is not set
+# CONFIG_BTRFS_FS_CHECK_INTEGRITY is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_UBIFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_LL_UART_NONE=y
+# CONFIG_DEBUG_ICEDCC is not set
+CONFIG_EARLY_PRINTK=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
diff -Naur linux-3.3-rc2/Documentation/DocBook/device-drivers.tmpl wm8505-3.3rc2/Documentation/DocBook/device-drivers.tmpl
--- linux-3.3-rc2/Documentation/DocBook/device-drivers.tmpl	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/Documentation/DocBook/device-drivers.tmpl	2012-02-06 12:27:43.000000000 -0700
@@ -102,9 +102,12 @@
 !Iinclude/linux/device.h
      </sect1>
      <sect1><title>Device Drivers Base</title>
+!Idrivers/base/init.c
 !Edrivers/base/driver.c
 !Edrivers/base/core.c
+!Edrivers/base/syscore.c
 !Edrivers/base/class.c
+!Idrivers/base/node.c
 !Edrivers/base/firmware_class.c
 !Edrivers/base/transport_class.c
 <!-- Cannot be included, because
@@ -113,7 +116,7 @@
      exceed allowed 44 characters maximum
 X!Edrivers/base/attribute_container.c
 -->
-!Edrivers/base/sys.c
+!Edrivers/base/dd.c
 <!--
 X!Edrivers/base/interface.c
 -->
@@ -121,6 +124,11 @@
 !Edrivers/base/platform.c
 !Edrivers/base/bus.c
      </sect1>
+     <sect1><title>Device Drivers DMA Management</title>
+!Edrivers/base/dma-buf.c
+!Edrivers/base/dma-coherent.c
+!Edrivers/base/dma-mapping.c
+     </sect1>
      <sect1><title>Device Drivers Power Management</title>
 !Edrivers/base/power/main.c
      </sect1>
@@ -219,7 +227,7 @@
   <chapter id="uart16x50">
      <title>16x50 UART Driver</title>
 !Edrivers/tty/serial/serial_core.c
-!Edrivers/tty/serial/8250.c
+!Edrivers/tty/serial/8250/8250.c
   </chapter>
 
   <chapter id="fbdev">
diff -Naur linux-3.3-rc2/Documentation/input/event-codes.txt wm8505-3.3rc2/Documentation/input/event-codes.txt
--- linux-3.3-rc2/Documentation/input/event-codes.txt	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/Documentation/input/event-codes.txt	2012-02-06 12:27:43.000000000 -0700
@@ -17,11 +17,11 @@
 class/input/event*/device/capabilities/, and the properties of a device are
 provided in class/input/event*/device/properties.
 
-Types:
-==========
-Types are groupings of codes under a logical input construct. Each type has a
-set of applicable codes to be used in generating events. See the Codes section
-for details on valid codes for each type.
+Event types:
+===========
+Event types are groupings of codes under a logical input construct. Each
+type has a set of applicable codes to be used in generating events. See the
+Codes section for details on valid codes for each type.
 
 * EV_SYN:
   - Used as markers to separate events. Events may be separated in time or in
@@ -63,9 +63,9 @@
 * EV_FF_STATUS:
   - Used to receive force feedback device status.
 
-Codes:
-==========
-Codes define the precise type of event.
+Event codes:
+===========
+Event codes define the precise type of event.
 
 EV_SYN:
 ----------
@@ -220,6 +220,56 @@
 EV_PWR events are a special type of event used specifically for power
 mangement. Its usage is not well defined. To be addressed later.
 
+Device properties:
+=================
+Normally, userspace sets up an input device based on the data it emits,
+i.e., the event types. In the case of two devices emitting the same event
+types, additional information can be provided in the form of device
+properties.
+
+INPUT_PROP_DIRECT + INPUT_PROP_POINTER:
+--------------------------------------
+The INPUT_PROP_DIRECT property indicates that device coordinates should be
+directly mapped to screen coordinates (not taking into account trivial
+transformations, such as scaling, flipping and rotating). Non-direct input
+devices require non-trivial transformation, such as absolute to relative
+transformation for touchpads. Typical direct input devices: touchscreens,
+drawing tablets; non-direct devices: touchpads, mice.
+
+The INPUT_PROP_POINTER property indicates that the device is not transposed
+on the screen and thus requires use of an on-screen pointer to trace user's
+movements.  Typical pointer devices: touchpads, tablets, mice; non-pointer
+device: touchscreen.
+
+If neither INPUT_PROP_DIRECT or INPUT_PROP_POINTER are set, the property is
+considered undefined and the device type should be deduced in the
+traditional way, using emitted event types.
+
+INPUT_PROP_BUTTONPAD:
+--------------------
+For touchpads where the button is placed beneath the surface, such that
+pressing down on the pad causes a button click, this property should be
+set. Common in clickpad notebooks and macbooks from 2009 and onwards.
+
+Originally, the buttonpad property was coded into the bcm5974 driver
+version field under the name integrated button. For backwards
+compatibility, both methods need to be checked in userspace.
+
+INPUT_PROP_SEMI_MT:
+------------------
+Some touchpads, most common between 2008 and 2011, can detect the presence
+of multiple contacts without resolving the individual positions; only the
+number of contacts and a rectangular shape is known. For such
+touchpads, the semi-mt property should be set.
+
+Depending on the device, the rectangle may enclose all touches, like a
+bounding box, or just some of them, for instance the two most recent
+touches. The diversity makes the rectangle of limited use, but some
+gestures can normally be extracted from it.
+
+If INPUT_PROP_SEMI_MT is not set, the device is assumed to be a true MT
+device.
+
 Guidelines:
 ==========
 The guidelines below ensure proper single-touch and multi-finger functionality.
@@ -240,6 +290,8 @@
 BTN_{MOUSE,LEFT,MIDDLE,RIGHT} must not be reported as the result of touch
 contact. BTN_TOOL_<name> events should be reported where possible.
 
+For new hardware, INPUT_PROP_DIRECT should be set.
+
 Trackpads:
 ----------
 Legacy trackpads that only provide relative position information must report
@@ -250,6 +302,8 @@
 on the trackpad. Where multi-finger support is available, BTN_TOOL_<name> should
 be used to report the number of touches active on the trackpad.
 
+For new hardware, INPUT_PROP_POINTER should be set.
+
 Tablets:
 ----------
 BTN_TOOL_<name> events must be reported when a stylus or other tool is active on
@@ -260,3 +314,5 @@
 BTN_{0,1,2,etc} are good generic codes for unlabeled buttons. Do not use
 meaningful buttons, like BTN_FORWARD, unless the button is labeled for that
 purpose on the device.
+
+For new hardware, both INPUT_PROP_DIRECT and INPUT_PROP_POINTER should be set.
diff -Naur linux-3.3-rc2/drivers/block/rbd.c wm8505-3.3rc2/drivers/block/rbd.c
--- linux-3.3-rc2/drivers/block/rbd.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/block/rbd.c	2012-02-06 12:27:43.000000000 -0700
@@ -380,6 +380,7 @@
 	rbdc = __rbd_client_find(opt);
 	if (rbdc) {
 		ceph_destroy_options(opt);
+		kfree(rbd_opts);
 
 		/* using an existing client */
 		kref_get(&rbdc->kref);
@@ -406,15 +407,15 @@
 
 /*
  * Destroy ceph client
+ *
+ * Caller must hold node_lock.
  */
 static void rbd_client_release(struct kref *kref)
 {
 	struct rbd_client *rbdc = container_of(kref, struct rbd_client, kref);
 
 	dout("rbd_release_client %p\n", rbdc);
-	spin_lock(&node_lock);
 	list_del(&rbdc->node);
-	spin_unlock(&node_lock);
 
 	ceph_destroy_client(rbdc->client);
 	kfree(rbdc->rbd_opts);
@@ -427,7 +428,9 @@
  */
 static void rbd_put_client(struct rbd_device *rbd_dev)
 {
+	spin_lock(&node_lock);
 	kref_put(&rbd_dev->rbd_client->kref, rbd_client_release);
+	spin_unlock(&node_lock);
 	rbd_dev->rbd_client = NULL;
 	rbd_dev->client = NULL;
 }
diff -Naur linux-3.3-rc2/drivers/dma/at_hdmac.c wm8505-3.3rc2/drivers/dma/at_hdmac.c
--- linux-3.3-rc2/drivers/dma/at_hdmac.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/dma/at_hdmac.c	2012-02-06 12:27:43.000000000 -0700
@@ -1343,7 +1343,7 @@
 
 		tasklet_init(&atchan->tasklet, atc_tasklet,
 				(unsigned long)atchan);
-		atc_enable_irq(atchan);
+		atc_enable_chan_irq(atdma, i);
 	}
 
 	/* set base routines */
@@ -1410,7 +1410,7 @@
 		struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 
 		/* Disable interrupts */
-		atc_disable_irq(atchan);
+		atc_disable_chan_irq(atdma, chan->chan_id);
 		tasklet_disable(&atchan->tasklet);
 
 		tasklet_kill(&atchan->tasklet);
diff -Naur linux-3.3-rc2/drivers/dma/at_hdmac_regs.h wm8505-3.3rc2/drivers/dma/at_hdmac_regs.h
--- linux-3.3-rc2/drivers/dma/at_hdmac_regs.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/dma/at_hdmac_regs.h	2012-02-06 12:27:43.000000000 -0700
@@ -327,28 +327,27 @@
 }
 
 
-static void atc_setup_irq(struct at_dma_chan *atchan, int on)
+static void atc_setup_irq(struct at_dma *atdma, int chan_id, int on)
 {
-	struct at_dma	*atdma = to_at_dma(atchan->chan_common.device);
-	u32		ebci;
+	u32 ebci;
 
 	/* enable interrupts on buffer transfer completion & error */
-	ebci =    AT_DMA_BTC(atchan->chan_common.chan_id)
-		| AT_DMA_ERR(atchan->chan_common.chan_id);
+	ebci =    AT_DMA_BTC(chan_id)
+		| AT_DMA_ERR(chan_id);
 	if (on)
 		dma_writel(atdma, EBCIER, ebci);
 	else
 		dma_writel(atdma, EBCIDR, ebci);
 }
 
-static inline void atc_enable_irq(struct at_dma_chan *atchan)
+static void atc_enable_chan_irq(struct at_dma *atdma, int chan_id)
 {
-	atc_setup_irq(atchan, 1);
+	atc_setup_irq(atdma, chan_id, 1);
 }
 
-static inline void atc_disable_irq(struct at_dma_chan *atchan)
+static void atc_disable_chan_irq(struct at_dma *atdma, int chan_id)
 {
-	atc_setup_irq(atchan, 0);
+	atc_setup_irq(atdma, chan_id, 0);
 }
 
 
diff -Naur linux-3.3-rc2/drivers/dma/dmatest.c wm8505-3.3rc2/drivers/dma/dmatest.c
--- linux-3.3-rc2/drivers/dma/dmatest.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/dma/dmatest.c	2012-02-06 12:27:43.000000000 -0700
@@ -599,7 +599,7 @@
 	}
 	if (dma_has_cap(DMA_PQ, dma_dev->cap_mask)) {
 		cnt = dmatest_add_threads(dtc, DMA_PQ);
-		thread_count += cnt > 0 ?: 0;
+		thread_count += cnt > 0 ? cnt : 0;
 	}
 
 	pr_info("dmatest: Started %u threads using %s\n",
diff -Naur linux-3.3-rc2/drivers/dma/imx-sdma.c wm8505-3.3rc2/drivers/dma/imx-sdma.c
--- linux-3.3-rc2/drivers/dma/imx-sdma.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/dma/imx-sdma.c	2012-02-06 12:27:43.000000000 -0700
@@ -1102,11 +1102,13 @@
 	case DMA_SLAVE_CONFIG:
 		if (dmaengine_cfg->direction == DMA_DEV_TO_MEM) {
 			sdmac->per_address = dmaengine_cfg->src_addr;
-			sdmac->watermark_level = dmaengine_cfg->src_maxburst;
+			sdmac->watermark_level = dmaengine_cfg->src_maxburst *
+						dmaengine_cfg->src_addr_width;
 			sdmac->word_size = dmaengine_cfg->src_addr_width;
 		} else {
 			sdmac->per_address = dmaengine_cfg->dst_addr;
-			sdmac->watermark_level = dmaengine_cfg->dst_maxburst;
+			sdmac->watermark_level = dmaengine_cfg->dst_maxburst *
+						dmaengine_cfg->dst_addr_width;
 			sdmac->word_size = dmaengine_cfg->dst_addr_width;
 		}
 		sdmac->direction = dmaengine_cfg->direction;
diff -Naur linux-3.3-rc2/drivers/dma/shdma.c wm8505-3.3rc2/drivers/dma/shdma.c
--- linux-3.3-rc2/drivers/dma/shdma.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/dma/shdma.c	2012-02-06 12:27:43.000000000 -0700
@@ -1262,7 +1262,8 @@
 
 	INIT_LIST_HEAD(&shdev->common.channels);
 
-	dma_cap_set(DMA_MEMCPY, shdev->common.cap_mask);
+	if (!pdata->slave_only)
+		dma_cap_set(DMA_MEMCPY, shdev->common.cap_mask);
 	if (pdata->slave && pdata->slave_num)
 		dma_cap_set(DMA_SLAVE, shdev->common.cap_mask);
 
diff -Naur linux-3.3-rc2/drivers/firewire/ohci.c wm8505-3.3rc2/drivers/firewire/ohci.c
--- linux-3.3-rc2/drivers/firewire/ohci.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/firewire/ohci.c	2012-02-06 12:27:43.000000000 -0700
@@ -263,6 +263,7 @@
 static char ohci_driver_name[] = KBUILD_MODNAME;
 
 #define PCI_DEVICE_ID_AGERE_FW643	0x5901
+#define PCI_DEVICE_ID_CREATIVE_SB1394	0x4001
 #define PCI_DEVICE_ID_JMICRON_JMB38X_FW	0x2380
 #define PCI_DEVICE_ID_TI_TSB12LV22	0x8009
 #define PCI_DEVICE_ID_TI_TSB12LV26	0x8020
@@ -289,6 +290,9 @@
 	{PCI_VENDOR_ID_ATT, PCI_DEVICE_ID_AGERE_FW643, 6,
 		QUIRK_NO_MSI},
 
+	{PCI_VENDOR_ID_CREATIVE, PCI_DEVICE_ID_CREATIVE_SB1394, PCI_ANY_ID,
+		QUIRK_RESET_PACKET},
+
 	{PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB38X_FW, PCI_ANY_ID,
 		QUIRK_NO_MSI},
 
@@ -299,7 +303,7 @@
 		QUIRK_NO_MSI},
 
 	{PCI_VENDOR_ID_RICOH, PCI_ANY_ID, PCI_ANY_ID,
-		QUIRK_CYCLE_TIMER},
+		QUIRK_CYCLE_TIMER | QUIRK_NO_MSI},
 
 	{PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_TSB12LV22, PCI_ANY_ID,
 		QUIRK_CYCLE_TIMER | QUIRK_RESET_PACKET | QUIRK_NO_1394A},
diff -Naur linux-3.3-rc2/drivers/gpu/drm/nouveau/nouveau_bios.h wm8505-3.3rc2/drivers/gpu/drm/nouveau/nouveau_bios.h
--- linux-3.3-rc2/drivers/gpu/drm/nouveau/nouveau_bios.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/gpu/drm/nouveau/nouveau_bios.h	2012-02-06 12:27:43.000000000 -0700
@@ -54,9 +54,10 @@
 int bit_table(struct drm_device *, u8 id, struct bit_entry *);
 
 enum dcb_gpio_tag {
-	DCB_GPIO_TVDAC0 = 0xc,
+	DCB_GPIO_PANEL_POWER = 0x01,
+	DCB_GPIO_TVDAC0 = 0x0c,
 	DCB_GPIO_TVDAC1 = 0x2d,
-	DCB_GPIO_PWM_FAN = 0x9,
+	DCB_GPIO_PWM_FAN = 0x09,
 	DCB_GPIO_FAN_SENSE = 0x3d,
 	DCB_GPIO_UNUSED = 0xff
 };
diff -Naur linux-3.3-rc2/drivers/gpu/drm/nouveau/nouveau_display.c wm8505-3.3rc2/drivers/gpu/drm/nouveau/nouveau_display.c
--- linux-3.3-rc2/drivers/gpu/drm/nouveau/nouveau_display.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/gpu/drm/nouveau/nouveau_display.c	2012-02-06 12:27:43.000000000 -0700
@@ -219,6 +219,16 @@
 	if (ret)
 		return ret;
 
+	/* power on internal panel if it's not already.  the init tables of
+	 * some vbios default this to off for some reason, causing the
+	 * panel to not work after resume
+	 */
+	if (nouveau_gpio_func_get(dev, DCB_GPIO_PANEL_POWER) == 0) {
+		nouveau_gpio_func_set(dev, DCB_GPIO_PANEL_POWER, true);
+		msleep(300);
+	}
+
+	/* enable polling for external displays */
 	drm_kms_helper_poll_enable(dev);
 
 	/* enable hotplug interrupts */
diff -Naur linux-3.3-rc2/drivers/gpu/drm/nouveau/nouveau_drv.c wm8505-3.3rc2/drivers/gpu/drm/nouveau/nouveau_drv.c
--- linux-3.3-rc2/drivers/gpu/drm/nouveau/nouveau_drv.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/gpu/drm/nouveau/nouveau_drv.c	2012-02-06 12:27:43.000000000 -0700
@@ -124,7 +124,7 @@
 int nouveau_ctxfw;
 module_param_named(ctxfw, nouveau_ctxfw, int, 0400);
 
-MODULE_PARM_DESC(ctxfw, "Santise DCB table according to MXM-SIS\n");
+MODULE_PARM_DESC(mxmdcb, "Santise DCB table according to MXM-SIS\n");
 int nouveau_mxmdcb = 1;
 module_param_named(mxmdcb, nouveau_mxmdcb, int, 0400);
 
diff -Naur linux-3.3-rc2/drivers/gpu/drm/nouveau/nouveau_gem.c wm8505-3.3rc2/drivers/gpu/drm/nouveau/nouveau_gem.c
--- linux-3.3-rc2/drivers/gpu/drm/nouveau/nouveau_gem.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/gpu/drm/nouveau/nouveau_gem.c	2012-02-06 12:27:43.000000000 -0700
@@ -380,6 +380,25 @@
 }
 
 static int
+validate_sync(struct nouveau_channel *chan, struct nouveau_bo *nvbo)
+{
+	struct nouveau_fence *fence = NULL;
+	int ret = 0;
+
+	spin_lock(&nvbo->bo.bdev->fence_lock);
+	if (nvbo->bo.sync_obj)
+		fence = nouveau_fence_ref(nvbo->bo.sync_obj);
+	spin_unlock(&nvbo->bo.bdev->fence_lock);
+
+	if (fence) {
+		ret = nouveau_fence_sync(fence, chan);
+		nouveau_fence_unref(&fence);
+	}
+
+	return ret;
+}
+
+static int
 validate_list(struct nouveau_channel *chan, struct list_head *list,
 	      struct drm_nouveau_gem_pushbuf_bo *pbbo, uint64_t user_pbbo_ptr)
 {
@@ -393,7 +412,7 @@
 	list_for_each_entry(nvbo, list, entry) {
 		struct drm_nouveau_gem_pushbuf_bo *b = &pbbo[nvbo->pbbo_index];
 
-		ret = nouveau_fence_sync(nvbo->bo.sync_obj, chan);
+		ret = validate_sync(chan, nvbo);
 		if (unlikely(ret)) {
 			NV_ERROR(dev, "fail pre-validate sync\n");
 			return ret;
@@ -416,7 +435,7 @@
 			return ret;
 		}
 
-		ret = nouveau_fence_sync(nvbo->bo.sync_obj, chan);
+		ret = validate_sync(chan, nvbo);
 		if (unlikely(ret)) {
 			NV_ERROR(dev, "fail post-validate sync\n");
 			return ret;
diff -Naur linux-3.3-rc2/drivers/gpu/drm/nouveau/nouveau_mxm.c wm8505-3.3rc2/drivers/gpu/drm/nouveau/nouveau_mxm.c
--- linux-3.3-rc2/drivers/gpu/drm/nouveau/nouveau_mxm.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/gpu/drm/nouveau/nouveau_mxm.c	2012-02-06 12:27:43.000000000 -0700
@@ -656,7 +656,16 @@
 
 	if (mxm_shadow(dev, mxm[0])) {
 		MXM_MSG(dev, "failed to locate valid SIS\n");
+#if 0
+		/* we should, perhaps, fall back to some kind of limited
+		 * mode here if the x86 vbios hasn't already done the
+		 * work for us (so we prevent loading with completely
+		 * whacked vbios tables).
+		 */
 		return -EINVAL;
+#else
+		return 0;
+#endif
 	}
 
 	MXM_MSG(dev, "MXMS Version %d.%d\n",
diff -Naur linux-3.3-rc2/drivers/gpu/drm/nouveau/nv50_pm.c wm8505-3.3rc2/drivers/gpu/drm/nouveau/nv50_pm.c
--- linux-3.3-rc2/drivers/gpu/drm/nouveau/nv50_pm.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/gpu/drm/nouveau/nv50_pm.c	2012-02-06 12:27:43.000000000 -0700
@@ -495,9 +495,9 @@
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nv50_pm_state *info;
 	struct pll_lims pll;
-	int ret = -EINVAL;
+	int clk, ret = -EINVAL;
 	int N, M, P1, P2;
-	u32 clk, out;
+	u32 out;
 
 	if (dev_priv->chipset == 0xaa ||
 	    dev_priv->chipset == 0xac)
diff -Naur linux-3.3-rc2/drivers/gpu/drm/radeon/atombios_crtc.c wm8505-3.3rc2/drivers/gpu/drm/radeon/atombios_crtc.c
--- linux-3.3-rc2/drivers/gpu/drm/radeon/atombios_crtc.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/gpu/drm/radeon/atombios_crtc.c	2012-02-06 12:27:43.000000000 -0700
@@ -1184,7 +1184,7 @@
 	WREG32(EVERGREEN_GRPH_ENABLE + radeon_crtc->crtc_offset, 1);
 
 	WREG32(EVERGREEN_DESKTOP_HEIGHT + radeon_crtc->crtc_offset,
-	       crtc->mode.vdisplay);
+	       target_fb->height);
 	x &= ~3;
 	y &= ~1;
 	WREG32(EVERGREEN_VIEWPORT_START + radeon_crtc->crtc_offset,
@@ -1353,7 +1353,7 @@
 	WREG32(AVIVO_D1GRPH_ENABLE + radeon_crtc->crtc_offset, 1);
 
 	WREG32(AVIVO_D1MODE_DESKTOP_HEIGHT + radeon_crtc->crtc_offset,
-	       crtc->mode.vdisplay);
+	       target_fb->height);
 	x &= ~3;
 	y &= ~1;
 	WREG32(AVIVO_D1MODE_VIEWPORT_START + radeon_crtc->crtc_offset,
diff -Naur linux-3.3-rc2/drivers/gpu/drm/radeon/atombios_dp.c wm8505-3.3rc2/drivers/gpu/drm/radeon/atombios_dp.c
--- linux-3.3-rc2/drivers/gpu/drm/radeon/atombios_dp.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/gpu/drm/radeon/atombios_dp.c	2012-02-06 12:27:43.000000000 -0700
@@ -564,9 +564,21 @@
 	    ENCODER_OBJECT_ID_NUTMEG)
 		panel_mode = DP_PANEL_MODE_INTERNAL_DP1_MODE;
 	else if (radeon_connector_encoder_get_dp_bridge_encoder_id(connector) ==
-		 ENCODER_OBJECT_ID_TRAVIS)
-		panel_mode = DP_PANEL_MODE_INTERNAL_DP2_MODE;
-	else if (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {
+		 ENCODER_OBJECT_ID_TRAVIS) {
+		u8 id[6];
+		int i;
+		for (i = 0; i < 6; i++)
+			id[i] = radeon_read_dpcd_reg(radeon_connector, 0x503 + i);
+		if (id[0] == 0x73 &&
+		    id[1] == 0x69 &&
+		    id[2] == 0x76 &&
+		    id[3] == 0x61 &&
+		    id[4] == 0x72 &&
+		    id[5] == 0x54)
+			panel_mode = DP_PANEL_MODE_INTERNAL_DP1_MODE;
+		else
+			panel_mode = DP_PANEL_MODE_INTERNAL_DP2_MODE;
+	} else if (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {
 		u8 tmp = radeon_read_dpcd_reg(radeon_connector, DP_EDP_CONFIGURATION_CAP);
 		if (tmp & 1)
 			panel_mode = DP_PANEL_MODE_INTERNAL_DP2_MODE;
diff -Naur linux-3.3-rc2/drivers/gpu/drm/radeon/r600_blit_kms.c wm8505-3.3rc2/drivers/gpu/drm/radeon/r600_blit_kms.c
--- linux-3.3-rc2/drivers/gpu/drm/radeon/r600_blit_kms.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/gpu/drm/radeon/r600_blit_kms.c	2012-02-06 12:27:43.000000000 -0700
@@ -468,27 +468,42 @@
 	radeon_ring_write(ring, sq_stack_resource_mgmt_2);
 }
 
+#define I2F_MAX_BITS 15
+#define I2F_MAX_INPUT  ((1 << I2F_MAX_BITS) - 1)
+#define I2F_SHIFT (24 - I2F_MAX_BITS)
+
+/*
+ * Converts unsigned integer into 32-bit IEEE floating point representation.
+ * Conversion is not universal and only works for the range from 0
+ * to 2^I2F_MAX_BITS-1. Currently we only use it with inputs between
+ * 0 and 16384 (inclusive), so I2F_MAX_BITS=15 is enough. If necessary,
+ * I2F_MAX_BITS can be increased, but that will add to the loop iterations
+ * and slow us down. Conversion is done by shifting the input and counting
+ * down until the first 1 reaches bit position 23. The resulting counter
+ * and the shifted input are, respectively, the exponent and the fraction.
+ * The sign is always zero.
+ */
 static uint32_t i2f(uint32_t input)
 {
 	u32 result, i, exponent, fraction;
 
-	if ((input & 0x3fff) == 0)
-		result = 0; /* 0 is a special case */
+	WARN_ON_ONCE(input > I2F_MAX_INPUT);
+
+	if ((input & I2F_MAX_INPUT) == 0)
+		result = 0;
 	else {
-		exponent = 140; /* exponent biased by 127; */
-		fraction = (input & 0x3fff) << 10; /* cheat and only
-						      handle numbers below 2^^15 */
-		for (i = 0; i < 14; i++) {
+		exponent = 126 + I2F_MAX_BITS;
+		fraction = (input & I2F_MAX_INPUT) << I2F_SHIFT;
+
+		for (i = 0; i < I2F_MAX_BITS; i++) {
 			if (fraction & 0x800000)
 				break;
 			else {
-				fraction = fraction << 1; /* keep
-							     shifting left until top bit = 1 */
+				fraction = fraction << 1;
 				exponent = exponent - 1;
 			}
 		}
-		result = exponent << 23 | (fraction & 0x7fffff); /* mask
-								    off top bit; assumed 1 */
+		result = exponent << 23 | (fraction & 0x7fffff);
 	}
 	return result;
 }
diff -Naur linux-3.3-rc2/drivers/gpu/drm/radeon/radeon_atpx_handler.c wm8505-3.3rc2/drivers/gpu/drm/radeon/radeon_atpx_handler.c
--- linux-3.3-rc2/drivers/gpu/drm/radeon/radeon_atpx_handler.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/gpu/drm/radeon/radeon_atpx_handler.c	2012-02-06 12:27:43.000000000 -0700
@@ -59,8 +59,9 @@
 
 	obj = (union acpi_object *)buffer.pointer;
 	memcpy(bios+offset, obj->buffer.pointer, obj->buffer.length);
+	len = obj->buffer.length;
 	kfree(buffer.pointer);
-	return obj->buffer.length;
+	return len;
 }
 
 bool radeon_atrm_supported(struct pci_dev *pdev)
diff -Naur linux-3.3-rc2/drivers/gpu/drm/radeon/radeon_device.c wm8505-3.3rc2/drivers/gpu/drm/radeon/radeon_device.c
--- linux-3.3-rc2/drivers/gpu/drm/radeon/radeon_device.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/gpu/drm/radeon/radeon_device.c	2012-02-06 12:27:43.000000000 -0700
@@ -883,6 +883,8 @@
 	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
+	drm_kms_helper_poll_disable(dev);
+
 	/* turn off display hw */
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
 		drm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);
@@ -972,6 +974,8 @@
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
 		drm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);
 	}
+
+	drm_kms_helper_poll_enable(dev);
 	return 0;
 }
 
diff -Naur linux-3.3-rc2/drivers/gpu/drm/radeon/radeon_i2c.c wm8505-3.3rc2/drivers/gpu/drm/radeon/radeon_i2c.c
--- linux-3.3-rc2/drivers/gpu/drm/radeon/radeon_i2c.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/gpu/drm/radeon/radeon_i2c.c	2012-02-06 12:27:43.000000000 -0700
@@ -958,6 +958,7 @@
 	i2c->rec = *rec;
 	i2c->adapter.owner = THIS_MODULE;
 	i2c->adapter.class = I2C_CLASS_DDC;
+	i2c->adapter.dev.parent = &dev->pdev->dev;
 	i2c->dev = dev;
 	snprintf(i2c->adapter.name, sizeof(i2c->adapter.name),
 		 "Radeon aux bus %s", name);
diff -Naur linux-3.3-rc2/drivers/i2c/busses/i2c-omap.c wm8505-3.3rc2/drivers/i2c/busses/i2c-omap.c
--- linux-3.3-rc2/drivers/i2c/busses/i2c-omap.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/i2c/busses/i2c-omap.c	2012-02-06 12:27:43.000000000 -0700
@@ -1018,7 +1018,7 @@
 		goto err_release_region;
 	}
 
-	match = of_match_device(omap_i2c_of_match, &pdev->dev);
+	match = of_match_device(of_match_ptr(omap_i2c_of_match), &pdev->dev);
 	if (match) {
 		u32 freq = 100000; /* default to 100000 Hz */
 
diff -Naur linux-3.3-rc2/drivers/infiniband/core/ucma.c wm8505-3.3rc2/drivers/infiniband/core/ucma.c
--- linux-3.3-rc2/drivers/infiniband/core/ucma.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/core/ucma.c	2012-02-06 12:27:43.000000000 -0700
@@ -808,9 +808,12 @@
 		return PTR_ERR(ctx);
 
 	if (cmd.conn_param.valid) {
-		ctx->uid = cmd.uid;
 		ucma_copy_conn_param(&conn_param, &cmd.conn_param);
+		mutex_lock(&file->mut);
 		ret = rdma_accept(ctx->cm_id, &conn_param);
+		if (!ret)
+			ctx->uid = cmd.uid;
+		mutex_unlock(&file->mut);
 	} else
 		ret = rdma_accept(ctx->cm_id, NULL);
 
diff -Naur linux-3.3-rc2/drivers/infiniband/core/uverbs_cmd.c wm8505-3.3rc2/drivers/infiniband/core/uverbs_cmd.c
--- linux-3.3-rc2/drivers/infiniband/core/uverbs_cmd.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/core/uverbs_cmd.c	2012-02-06 12:27:43.000000000 -0700
@@ -1485,6 +1485,7 @@
 		qp->event_handler = attr.event_handler;
 		qp->qp_context	  = attr.qp_context;
 		qp->qp_type	  = attr.qp_type;
+		atomic_set(&qp->usecnt, 0);
 		atomic_inc(&pd->usecnt);
 		atomic_inc(&attr.send_cq->usecnt);
 		if (attr.recv_cq)
diff -Naur linux-3.3-rc2/drivers/infiniband/core/verbs.c wm8505-3.3rc2/drivers/infiniband/core/verbs.c
--- linux-3.3-rc2/drivers/infiniband/core/verbs.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/core/verbs.c	2012-02-06 12:27:43.000000000 -0700
@@ -421,6 +421,7 @@
 		qp->uobject    = NULL;
 		qp->qp_type    = qp_init_attr->qp_type;
 
+		atomic_set(&qp->usecnt, 0);
 		if (qp_init_attr->qp_type == IB_QPT_XRC_TGT) {
 			qp->event_handler = __ib_shared_qp_event_handler;
 			qp->qp_context = qp;
@@ -430,7 +431,6 @@
 			qp->xrcd = qp_init_attr->xrcd;
 			atomic_inc(&qp_init_attr->xrcd->usecnt);
 			INIT_LIST_HEAD(&qp->open_list);
-			atomic_set(&qp->usecnt, 0);
 
 			real_qp = qp;
 			qp = __ib_open_qp(real_qp, qp_init_attr->event_handler,
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/ipath/ipath_fs.c wm8505-3.3rc2/drivers/infiniband/hw/ipath/ipath_fs.c
--- linux-3.3-rc2/drivers/infiniband/hw/ipath/ipath_fs.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/ipath/ipath_fs.c	2012-02-06 12:27:43.000000000 -0700
@@ -89,7 +89,7 @@
 		error = ipathfs_mknod(parent->d_inode, *dentry,
 				      mode, fops, data);
 	else
-		error = PTR_ERR(dentry);
+		error = PTR_ERR(*dentry);
 	mutex_unlock(&parent->d_inode->i_mutex);
 
 	return error;
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/mlx4/mad.c wm8505-3.3rc2/drivers/infiniband/hw/mlx4/mad.c
--- linux-3.3-rc2/drivers/infiniband/hw/mlx4/mad.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/mlx4/mad.c	2012-02-06 12:27:43.000000000 -0700
@@ -257,12 +257,9 @@
 			return IB_MAD_RESULT_SUCCESS;
 
 		/*
-		 * Don't process SMInfo queries or vendor-specific
-		 * MADs -- the SMA can't handle them.
+		 * Don't process SMInfo queries -- the SMA can't handle them.
 		 */
-		if (in_mad->mad_hdr.attr_id == IB_SMP_ATTR_SM_INFO ||
-		    ((in_mad->mad_hdr.attr_id & IB_SMP_ATTR_VENDOR_MASK) ==
-		     IB_SMP_ATTR_VENDOR_MASK))
+		if (in_mad->mad_hdr.attr_id == IB_SMP_ATTR_SM_INFO)
 			return IB_MAD_RESULT_SUCCESS;
 	} else if (in_mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_PERF_MGMT ||
 		   in_mad->mad_hdr.mgmt_class == MLX4_IB_VENDOR_CLASS1   ||
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes.c wm8505-3.3rc2/drivers/infiniband/hw/nes/nes.c
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes.c	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006 - 2009 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2006 - 2011 Intel Corporation.  All rights reserved.
  * Copyright (c) 2005 Open Grid Computing, Inc. All rights reserved.
  *
  * This software is available to you under a choice of one of two
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes_cm.c wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_cm.c
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes_cm.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_cm.c	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006 - 2009 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2006 - 2011 Intel Corporation.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -233,6 +233,7 @@
 	u8 *start_ptr = &start_addr;
 	u8 **start_buff = &start_ptr;
 	u16 buff_len = 0;
+	struct ietf_mpa_v1 *mpa_frame;
 
 	skb = dev_alloc_skb(MAX_CM_BUFFER);
 	if (!skb) {
@@ -242,6 +243,8 @@
 
 	/* send an MPA reject frame */
 	cm_build_mpa_frame(cm_node, start_buff, &buff_len, NULL, MPA_KEY_REPLY);
+	mpa_frame = (struct ietf_mpa_v1 *)*start_buff;
+	mpa_frame->flags |= IETF_MPA_FLAGS_REJECT;
 	form_cm_frame(skb, cm_node, NULL, 0, *start_buff, buff_len, SET_ACK | SET_FIN);
 
 	cm_node->state = NES_CM_STATE_FIN_WAIT1;
@@ -1360,8 +1363,7 @@
 				if (!memcmp(nesadapter->arp_table[arpindex].mac_addr,
 					    neigh->ha, ETH_ALEN)) {
 					/* Mac address same as in nes_arp_table */
-					ip_rt_put(rt);
-					return rc;
+					goto out;
 				}
 
 				nes_manage_arp_cache(nesvnic->netdev,
@@ -1377,6 +1379,8 @@
 			neigh_event_send(neigh, NULL);
 		}
 	}
+
+out:
 	rcu_read_unlock();
 	ip_rt_put(rt);
 	return rc;
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes_cm.h wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_cm.h
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes_cm.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_cm.h	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006 - 2009 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2006 - 2011 Intel Corporation.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes_context.h wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_context.h
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes_context.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_context.h	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006 - 2009 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2006 - 2011 Intel Corporation.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes.h wm8505-3.3rc2/drivers/infiniband/hw/nes/nes.h
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes.h	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006 - 2009 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2006 - 2011 Intel Corporation.  All rights reserved.
  * Copyright (c) 2005 Open Grid Computing, Inc. All rights reserved.
  *
  * This software is available to you under a choice of one of two
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes_hw.c wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_hw.c
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes_hw.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_hw.c	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006 - 2009 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2006 - 2011 Intel Corporation.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes_hw.h wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_hw.h
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes_hw.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_hw.h	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
-* Copyright (c) 2006 - 2009 Intel Corporation.  All rights reserved.
+* Copyright (c) 2006 - 2011 Intel Corporation.  All rights reserved.
 *
 * This software is available to you under a choice of one of two
 * licenses.  You may choose to be licensed under the terms of the GNU
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes_mgt.c wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_mgt.c
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes_mgt.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_mgt.c	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006 - 2009 Intel-NE, Inc.  All rights reserved.
+ * Copyright (c) 2006 - 2011 Intel-NE, Inc.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes_mgt.h wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_mgt.h
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes_mgt.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_mgt.h	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
-* Copyright (c) 2010 Intel-NE, Inc.  All rights reserved.
+* Copyright (c) 2006 - 2011 Intel-NE, Inc.  All rights reserved.
 *
 * This software is available to you under a choice of one of two
 * licenses.  You may choose to be licensed under the terms of the GNU
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes_nic.c wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_nic.c
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes_nic.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_nic.c	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006 - 2009 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2006 - 2011 Intel Corporation.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes_user.h wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_user.h
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes_user.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_user.h	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006 - 2009 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2006 - 2011 Intel Corporation.  All rights reserved.
  * Copyright (c) 2005 Topspin Communications.  All rights reserved.
  * Copyright (c) 2005 Cisco Systems.  All rights reserved.
  * Copyright (c) 2005 Open Grid Computing, Inc. All rights reserved.
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes_utils.c wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_utils.c
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes_utils.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_utils.c	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006 - 2009 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2006 - 2011 Intel Corporation.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes_verbs.c wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_verbs.c
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes_verbs.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_verbs.c	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006 - 2009 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2006 - 2011 Intel Corporation.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -3428,6 +3428,8 @@
 					    NES_IWARP_SQ_FMR_WQE_LENGTH_LOW_IDX,
 					    ib_wr->wr.fast_reg.length);
 			set_wqe_32bit_value(wqe->wqe_words,
+					    NES_IWARP_SQ_FMR_WQE_LENGTH_HIGH_IDX, 0);
+			set_wqe_32bit_value(wqe->wqe_words,
 					    NES_IWARP_SQ_FMR_WQE_MR_STAG_IDX,
 					    ib_wr->wr.fast_reg.rkey);
 			/* Set page size: */
@@ -3724,7 +3726,7 @@
 						entry->opcode = IB_WC_SEND;
 						break;
 					case NES_IWARP_SQ_OP_LOCINV:
-						entry->opcode = IB_WR_LOCAL_INV;
+						entry->opcode = IB_WC_LOCAL_INV;
 						break;
 					case NES_IWARP_SQ_OP_FAST_REG:
 						entry->opcode = IB_WC_FAST_REG_MR;
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/nes/nes_verbs.h wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_verbs.h
--- linux-3.3-rc2/drivers/infiniband/hw/nes/nes_verbs.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/nes/nes_verbs.h	2012-02-06 12:27:43.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006 - 2009 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2006 - 2011 Intel Corporation.  All rights reserved.
  * Copyright (c) 2005 Open Grid Computing, Inc. All rights reserved.
  *
  * This software is available to you under a choice of one of two
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/qib/qib_iba6120.c wm8505-3.3rc2/drivers/infiniband/hw/qib/qib_iba6120.c
--- linux-3.3-rc2/drivers/infiniband/hw/qib/qib_iba6120.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/qib/qib_iba6120.c	2012-02-06 12:27:43.000000000 -0700
@@ -2105,7 +2105,7 @@
 	dd->cspec->dummy_hdrq = dma_alloc_coherent(&dd->pcidev->dev,
 					dd->rcd[0]->rcvhdrq_size,
 					&dd->cspec->dummy_hdrq_phys,
-					GFP_KERNEL | __GFP_COMP);
+					GFP_ATOMIC | __GFP_COMP);
 	if (!dd->cspec->dummy_hdrq) {
 		qib_devinfo(dd->pcidev, "Couldn't allocate dummy hdrq\n");
 		/* fallback to just 0'ing */
diff -Naur linux-3.3-rc2/drivers/infiniband/hw/qib/qib_pcie.c wm8505-3.3rc2/drivers/infiniband/hw/qib/qib_pcie.c
--- linux-3.3-rc2/drivers/infiniband/hw/qib/qib_pcie.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/infiniband/hw/qib/qib_pcie.c	2012-02-06 12:27:43.000000000 -0700
@@ -560,7 +560,7 @@
  * BIOS may not set PCIe bus-utilization parameters for best performance.
  * Check and optionally adjust them to maximize our throughput.
  */
-static int qib_pcie_caps = 0x51;
+static int qib_pcie_caps;
 module_param_named(pcie_caps, qib_pcie_caps, int, S_IRUGO);
 MODULE_PARM_DESC(pcie_caps, "Max PCIe tuning: Payload (0..3), ReadReq (4..7)");
 
diff -Naur linux-3.3-rc2/drivers/input/evdev.c wm8505-3.3rc2/drivers/input/evdev.c
--- linux-3.3-rc2/drivers/input/evdev.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/input/evdev.c	2012-02-06 12:27:43.000000000 -0700
@@ -386,7 +386,7 @@
 	struct evdev_client *client = file->private_data;
 	struct evdev *evdev = client->evdev;
 	struct input_event event;
-	int retval;
+	int retval = 0;
 
 	if (count < input_event_size())
 		return -EINVAL;
diff -Naur linux-3.3-rc2/drivers/input/keyboard/twl4030_keypad.c wm8505-3.3rc2/drivers/input/keyboard/twl4030_keypad.c
--- linux-3.3-rc2/drivers/input/keyboard/twl4030_keypad.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/input/keyboard/twl4030_keypad.c	2012-02-06 12:27:43.000000000 -0700
@@ -34,7 +34,6 @@
 #include <linux/i2c/twl.h>
 #include <linux/slab.h>
 
-
 /*
  * The TWL4030 family chips include a keypad controller that supports
  * up to an 8x8 switch matrix.  The controller can issue system wakeup
@@ -302,7 +301,7 @@
 	if (twl4030_kpwrite_u8(kp, i, KEYP_DEB) < 0)
 		return -EIO;
 
-	/* Set timeout period to 100 ms */
+	/* Set timeout period to 200 ms */
 	i = KEYP_PERIOD_US(200000, PTV_PRESCALER);
 	if (twl4030_kpwrite_u8(kp, (i & 0xFF), KEYP_TIMEOUT_L) < 0)
 		return -EIO;
@@ -466,4 +465,3 @@
 MODULE_DESCRIPTION("TWL4030 Keypad Driver");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:twl4030_keypad");
-
diff -Naur linux-3.3-rc2/drivers/input/serio/i8042.h wm8505-3.3rc2/drivers/input/serio/i8042.h
--- linux-3.3-rc2/drivers/input/serio/i8042.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/input/serio/i8042.h	2012-02-06 12:27:43.000000000 -0700
@@ -16,6 +16,8 @@
 
 #if defined(CONFIG_MACH_JAZZ)
 #include "i8042-jazzio.h"
+#elif defined(CONFIG_ARCH_VT8500)
+#include "i8042-vt8500.h"
 #elif defined(CONFIG_SGI_HAS_I8042)
 #include "i8042-ip22io.h"
 #elif defined(CONFIG_SNI_RM)
diff -Naur linux-3.3-rc2/drivers/input/serio/i8042-vt8500.h wm8505-3.3rc2/drivers/input/serio/i8042-vt8500.h
--- linux-3.3-rc2/drivers/input/serio/i8042-vt8500.h	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/drivers/input/serio/i8042-vt8500.h	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,77 @@
+#ifndef _I8042_VT8500_H
+#define _I8042_VT8500_H
+
+#include <mach/i8042.h>
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+static void __iomem *regbase;
+
+/*
+ * Names.
+ */
+
+#define I8042_KBD_PHYS_DESC "vt8500ps2/serio0"
+#define I8042_AUX_PHYS_DESC "vt8500ps2/serio1"
+#define I8042_MUX_PHYS_DESC "vt8500ps2/serio%d"
+
+/*
+ * IRQs.
+ */
+
+#define I8042_KBD_IRQ	(wmt_i8042_kbd_irq)
+#define I8042_AUX_IRQ	(wmt_i8042_aux_irq)
+
+
+/*
+ * Register numbers.
+ */
+
+#define I8042_COMMAND_REG	(regbase + 0x4)
+#define I8042_STATUS_REG	(regbase + 0x4)
+#define I8042_DATA_REG		(regbase + 0x0)
+
+static inline int i8042_read_data(void)
+{
+	return readl(I8042_DATA_REG);
+}
+
+static inline int i8042_read_status(void)
+{
+	return readl(I8042_STATUS_REG);
+}
+
+static inline void i8042_write_data(int val)
+{
+	writel(val, I8042_DATA_REG);
+}
+
+static inline void i8042_write_command(int val)
+{
+	writel(val, I8042_COMMAND_REG);
+}
+
+static inline int i8042_platform_init(void)
+{
+	i8042_reset = true;
+
+	if (!wmt_i8042_base)
+		return -ENODEV;
+
+	regbase = ioremap(wmt_i8042_base, SZ_1K);
+	if (!regbase)
+		return -ENODEV;
+
+	return 0;
+}
+
+static inline void i8042_platform_exit(void)
+{
+	iounmap(regbase);
+}
+
+#endif /* _I8042_VT8500_H */
diff -Naur linux-3.3-rc2/drivers/input/serio/i8042-x86ia64io.h wm8505-3.3rc2/drivers/input/serio/i8042-x86ia64io.h
--- linux-3.3-rc2/drivers/input/serio/i8042-x86ia64io.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/input/serio/i8042-x86ia64io.h	2012-02-06 12:27:43.000000000 -0700
@@ -512,6 +512,13 @@
 			DMI_MATCH(DMI_PRODUCT_NAME, "Vostro 1720"),
 		},
 	},
+	{
+		/* Lenovo Ideapad U455 */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "20046"),
+		},
+	},
 	{ }
 };
 
diff -Naur linux-3.3-rc2/drivers/input/serio/Kconfig wm8505-3.3rc2/drivers/input/serio/Kconfig
--- linux-3.3-rc2/drivers/input/serio/Kconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/input/serio/Kconfig	2012-02-06 12:27:43.000000000 -0700
@@ -21,7 +21,8 @@
 config SERIO_I8042
 	tristate "i8042 PC Keyboard controller" if EXPERT || !X86
 	default y
-	depends on !PARISC && (!ARM || ARCH_SHARK || FOOTBRIDGE_HOST) && \
+	depends on !PARISC && \
+		  (!ARM || ARCH_SHARK || ARCH_VT8500 || FOOTBRIDGE_HOST) && \
 		   (!SUPERH || SH_CAYMAN) && !M68K && !BLACKFIN
 	help
 	  i8042 is the chip over which the standard AT keyboard and PS/2
diff -Naur linux-3.3-rc2/drivers/input/serio/serio_raw.c wm8505-3.3rc2/drivers/input/serio/serio_raw.c
--- linux-3.3-rc2/drivers/input/serio/serio_raw.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/input/serio/serio_raw.c	2012-02-06 12:27:43.000000000 -0700
@@ -164,7 +164,8 @@
 	struct serio_raw_client *client = file->private_data;
 	struct serio_raw *serio_raw = client->serio_raw;
 	char uninitialized_var(c);
-	ssize_t retval = 0;
+	ssize_t read = 0;
+	int retval;
 
 	if (serio_raw->dead)
 		return -ENODEV;
@@ -180,13 +181,15 @@
 	if (serio_raw->dead)
 		return -ENODEV;
 
-	while (retval < count && serio_raw_fetch_byte(serio_raw, &c)) {
-		if (put_user(c, buffer++))
-			return -EFAULT;
-		retval++;
+	while (read < count && serio_raw_fetch_byte(serio_raw, &c)) {
+		if (put_user(c, buffer++)) {
+			retval = -EFAULT;
+			break;
+		}
+		read++;
 	}
 
-	return retval;
+	return read ?: retval;
 }
 
 static ssize_t serio_raw_write(struct file *file, const char __user *buffer,
diff -Naur linux-3.3-rc2/drivers/misc/lkdtm.c wm8505-3.3rc2/drivers/misc/lkdtm.c
--- linux-3.3-rc2/drivers/misc/lkdtm.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/misc/lkdtm.c	2012-02-06 12:27:43.000000000 -0700
@@ -354,6 +354,7 @@
 static void lkdtm_handler(void)
 {
 	unsigned long flags;
+	bool do_it = false;
 
 	spin_lock_irqsave(&count_lock, flags);
 	count--;
@@ -361,10 +362,13 @@
 			cp_name_to_str(cpoint), cp_type_to_str(cptype), count);
 
 	if (count == 0) {
-		lkdtm_do_action(cptype);
+		do_it = true;
 		count = cpoint_count;
 	}
 	spin_unlock_irqrestore(&count_lock, flags);
+
+	if (do_it)
+		lkdtm_do_action(cptype);
 }
 
 static int lkdtm_register_cpoint(enum cname which)
diff -Naur linux-3.3-rc2/drivers/mmc/host/Kconfig wm8505-3.3rc2/drivers/mmc/host/Kconfig
--- linux-3.3-rc2/drivers/mmc/host/Kconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/mmc/host/Kconfig	2012-02-06 12:27:43.000000000 -0700
@@ -595,3 +595,10 @@
 
 	  Note: These controllers only support SDIO cards and do not
 	  support MMC or SD memory cards.
+
+config MMC_WMT
+	tristate "WonderMedia SD/MMC Controller support"
+	depends on ARCH_VT8500
+	help
+	  This selects support for the SD/MMC controller found in
+	  VIA VT8500, WonderMedia WM8505, WM8650 and similar SoC's.
diff -Naur linux-3.3-rc2/drivers/mmc/host/Makefile wm8505-3.3rc2/drivers/mmc/host/Makefile
--- linux-3.3-rc2/drivers/mmc/host/Makefile	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/mmc/host/Makefile	2012-02-06 12:27:43.000000000 -0700
@@ -43,6 +43,7 @@
 obj-$(CONFIG_MMC_JZ4740)	+= jz4740_mmc.o
 obj-$(CONFIG_MMC_VUB300)	+= vub300.o
 obj-$(CONFIG_MMC_USHC)		+= ushc.o
+obj-$(CONFIG_MMC_WMT)		+= wmt-sdmmc.o
 
 obj-$(CONFIG_MMC_SDHCI_PLTFM)		+= sdhci-pltfm.o
 obj-$(CONFIG_MMC_SDHCI_CNS3XXX)		+= sdhci-cns3xxx.o
diff -Naur linux-3.3-rc2/drivers/mmc/host/wmt-sdmmc.c wm8505-3.3rc2/drivers/mmc/host/wmt-sdmmc.c
--- linux-3.3-rc2/drivers/mmc/host/wmt-sdmmc.c	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/drivers/mmc/host/wmt-sdmmc.c	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,1150 @@
+/*
+ *  linux/drivers/mmc/host/wmt-sdmmc.c - VT8500/WM8505 AHB to MMC/SD driver
+ *
+ *  Copyright (C) 2010 Tony Prisk
+ *  Copyright (C) 2008 WonderMedia Technologies, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+
+#include <asm/byteorder.h>
+
+
+#define DRIVER_NAME "wmt-sdmmc"
+
+
+/* MMC/SD controller registers (VT8500/WM8505) */
+#define SDMMC_CTLR			0x00
+#define SDMMC_CMD			0x01
+#define SDMMC_RSPTYPE		0x02
+#define SDMMC_ARG			0x04
+#define SDMMC_BUSMODE		0x08
+#define SDMMC_BLKLEN		0x0C
+#define SDMMC_BLKCNT		0x0E
+#define SDMMC_RSP			0x10
+#define SDMMC_CBCR			0x20
+#define SDMMC_INTMASK0		0x24
+#define SDMMC_INTMASK1		0x25
+#define SDMMC_STS0			0x28
+#define SDMMC_STS1			0x29
+#define SDMMC_STS2			0x2A
+#define SDMMC_STS3			0x2B
+#define SDMMC_RSPTIMEOUT		0x2C
+#define SDMMC_CLK			0x30	/* VT8500 only */
+#define SDMMC_EXTCTRL		0x34
+#define SDMMC_SBLKLEN		0x38
+#define SDMMC_DMATIMEOUT		0x3C
+
+
+/* SDMMC_CTLR bit fields */
+#define CTLR_CMD_START		0x01
+#define CTLR_CMD_WRITE		0x04
+#define CTLR_FIFO_RESET		0x08
+
+/* SDMMC_BUSMODE bit fields */
+#define BM_SPI_MODE			0x01
+#define BM_FOURBIT_MODE		0x02
+#define BM_EIGHTBIT_MODE		0x04
+#define BM_SD_OFF			0x10
+#define BM_SPI_CS			0x20
+#define BM_SD_POWER			0x40
+#define BM_SOFT_RESET		0x80
+#define BM_ONEBIT_MASK		0xFD
+
+/* SDMMC_BLKLEN bit fields */
+#define BLKL_CRCERR_ABORT	0x0800
+#define BLKL_CD_POL_HIGH		0x1000
+#define BLKL_GPI_CD			0x2000
+#define BLKL_DATA3_CD		0x4000
+#define BLKL_INT_ENABLE		0x8000
+
+/* SDMMC_INTMASK0 bit fields */
+#define INT0_MBLK_TRAN_DONE_INT_EN	0x10
+#define INT0_BLK_TRAN_DONE_INT_EN	0x20
+#define INT0_CD_INT_EN			0x40
+#define INT0_DI_INT_EN			0x80
+
+/* SDMMC_INTMASK1 bit fields */
+#define INT1_CMD_RES_TRAN_DONE_INT_EN	0x02
+#define INT1_CMD_RES_TOUT_INT_EN		0x04
+#define INT1_MBLK_AUTO_STOP_INT_EN		0x08
+#define INT1_DATA_TOUT_INT_EN			0x10
+#define INT1_RESCRC_ERR_INT_EN		0x20
+#define INT1_RCRC_ERR_INT_EN			0x40
+#define INT1_WCRC_ERR_INT_EN			0x80
+
+/* SDMMC_STS0 bit fields */
+#define STS0_WRITE_PROTECT		0x02
+#define STS0_CD_DATA3			0x04
+#define STS0_CD_GPI				0x08
+#define STS0_MBLK_DONE			0x10
+#define STS0_BLK_DONE			0x20
+#define STS0_CARD_DETECT			0x40
+#define STS0_DEVICE_INS			0x80
+
+/* SDMMC_STS1 bit fields */
+#define STS1_SDIO_INT			0x01
+#define STS1_CMDRSP_DONE			0x02
+#define STS1_RSP_TIMEOUT			0x04
+#define STS1_AUTOSTOP_DONE		0x08
+#define STS1_DATA_TIMEOUT		0x10
+#define STS1_RSP_CRC_ERR			0x20
+#define STS1_RCRC_ERR			0x40
+#define STS1_WCRC_ERR			0x80
+
+/* SDMMC_STS2 bit fields */
+#define STS2_CMD_RES_BUSY		0x10
+#define STS2_DATARSP_BUSY		0x20
+#define STS2_DIS_FORCECLK		0x80
+
+
+/* MMC/SD DMA Controller Registers */
+#define SDDMA_GCR			0x100
+#define SDDMA_IER			0x104
+#define SDDMA_ISR			0x108
+#define SDDMA_DESPR			0x10C
+#define SDDMA_RBR			0x110
+#define SDDMA_DAR			0x114
+#define SDDMA_BAR			0x118
+#define SDDMA_CPR			0x11C
+#define SDDMA_CCR			0x120
+
+
+/* SDDMA_GCR bit fields */
+#define DMA_GCR_DMA_EN			0x00000001
+#define DMA_GCR_SOFT_RESET		0x00000100
+
+/* SDDMA_IER bit fields */
+#define DMA_IER_INT_EN			0x00000001
+
+/* SDDMA_ISR bit fields */
+#define DMA_ISR_INT_STS			0x00000001
+
+/* SDDMA_RBR bit fields */
+#define DMA_RBR_FORMAT			0x40000000
+#define DMA_RBR_END				0x80000000
+
+/* SDDMA_CCR bit fields */
+#define DMA_CCR_RUN				0x00000080
+#define DMA_CCR_IF_TO_PERIPHERAL	0x00000000
+#define DMA_CCR_PERIPHERAL_TO_IF	0x00400000
+
+/* SDDMA_CCR event status */
+#define DMA_CCR_EVT_NO_STATUS		0x00000000
+#define DMA_CCR_EVT_UNDERRUN		0x00000001
+#define DMA_CCR_EVT_OVERRUN		0x00000002
+#define DMA_CCR_EVT_DESP_READ		0x00000003
+#define DMA_CCR_EVT_DATA_RW		0x00000004
+#define DMA_CCR_EVT_EARLY_END		0x00000005
+#define DMA_CCR_EVT_SUCCESS		0x0000000F
+
+/* Driver Versions */
+#define WMT_MCI_3426_A0			6
+#define WMT_MCI_3426_A1			7
+#define WMT_MCI_3426_A2			8
+#define WMT_MCI_3437_A0			9
+#define WMT_MCI_3437_A1			10
+#define WMT_MCI_3429			11
+#define WMT_MCI_3451_A0			12
+#define WMT_MCI_3465			13
+
+struct wmt_dma_descriptor {
+	u32 flags;
+	u32 data_buffer_addr;
+	u32 branch_addr;
+	u32 reserved1;
+};
+
+struct wmt_mci_priv {
+	struct mmc_host *mmc;
+	void __iomem *sdmmc_base;
+
+	int irq_regular;
+	int irq_dma;
+
+	void *dma_desc_buffer;
+	dma_addr_t dma_desc_device_addr;
+
+	struct completion cmdcomp;
+	struct completion datacomp;
+
+	struct completion *comp_cmd;
+	struct completion *comp_dma;
+
+	struct mmc_request *req;
+	struct mmc_command *cmd;
+
+	struct clk *clk_sdmmc;
+
+	u32 driver_version;
+};
+
+/*
+ * TODO: Clock Management Code for SD/MMC controller
+ *	 should be replace with clocks.c eventually
+ */
+
+void __iomem *pmc_base;
+
+static void wmt_mci_clk_enable(void)
+{
+	u32 reg_tmp;
+	reg_tmp = readl(pmc_base + 0x254);
+	writel(reg_tmp | (1 << 18), pmc_base + 0x254);
+}
+
+static void wmt_mci_clk_set_rate(u32 rate)
+{
+	u32 pll_mul = (readl(pmc_base + 0x204) & 0x1F);
+	u32 pll_prediv = (readl(pmc_base + 0x204) & 0x100) ? 1 : 2;
+	u32 pll_b;
+	u32 clk_div;
+
+	if (rate == 0)
+		return;
+
+	if (pll_mul < 4)
+		pll_mul = 1;
+	else
+		pll_mul *= 2;
+
+	/* parent rate = 25Mhz */
+	pll_b = 25000000 * pll_mul / pll_prediv;
+
+	if (pll_b % rate)
+		clk_div = pll_b / rate + 1;
+	else
+		clk_div = pll_b / rate;
+
+	if (clk_div > 32)
+		clk_div = 0;
+
+	writel(clk_div, pmc_base + 0x328);
+}
+
+/* End Clock Management */
+
+/* Helper functions for the SD variations */
+
+#define WMT_SD_POWER_OFF	0
+#define WMT_SD_POWER_ON		1
+static void wmt_set_sd_power(struct wmt_mci_priv *priv, int enable)
+{
+	u32 reg_tmp;
+	if (enable) {
+		/* enable SD power */
+		/* VT3465 inverts the BM_SD_OFF bit usage */
+		if (priv->driver_version == WMT_MCI_3465)
+		{
+			reg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);
+			writeb(reg_tmp | BM_SD_OFF, priv->sdmmc_base + SDMMC_BUSMODE);
+		} else {
+			reg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);
+			writeb(reg_tmp & (~BM_SD_OFF), priv->sdmmc_base + SDMMC_BUSMODE);
+		}
+	} else {
+		/* disable SD power */
+		/* VT3465 inverts the BM_SD_OFF bit usage */
+		if (priv->driver_version == WMT_MCI_3465)
+		{
+			reg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);
+			writeb(reg_tmp & (~BM_SD_OFF), priv->sdmmc_base + SDMMC_BUSMODE);
+		} else {
+			reg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);
+			writeb(reg_tmp | BM_SD_OFF, priv->sdmmc_base + SDMMC_BUSMODE);
+		}
+	}
+}
+
+/* Version detection code */
+static u32 wmt_mci_scc_id(void)
+{
+	void __iomem *scc_base;
+	u32 scc_id = 0;
+	scc_base = ioremap(0xD8120000, 4);
+	if (scc_base) {
+		scc_id = readl(scc_base);
+		iounmap(scc_base);
+	}
+	return scc_id;
+}
+
+static u32 wmt_mci_driver_version(void)
+{
+	u32 scc_id;
+	u16 hw_scc;
+	u16 chip_version;
+
+	scc_id = wmt_mci_scc_id();
+	hw_scc = (scc_id >> 16) & 0xFFFF;
+	chip_version = ((scc_id & 0xF00) >> 4) + 0x90 + ((scc_id & 0xFF) - 1);
+
+	switch (hw_scc) {
+	case 0x3426:
+		if (chip_version < 0xA1)
+			return WMT_MCI_3426_A0;
+		if (chip_version == 0xA1)
+			return WMT_MCI_3426_A1;
+		if (chip_version > 0xA1)
+			return WMT_MCI_3426_A2;
+		return 0;
+	case 0x3437:
+		if (chip_version < 0xA1)
+			return WMT_MCI_3437_A0;
+		if (chip_version >= 0xA1)
+			return WMT_MCI_3437_A1;
+		return 0;
+	case 0x3429:
+		return WMT_MCI_3429;
+	case 0x3451:
+		if (chip_version < 0xA1)
+			return WMT_MCI_3451_A0;
+		return 0;
+	case 0x3465:
+		return WMT_MCI_3465;
+	default:
+		return 0;
+	}
+}
+
+/* End version detection code */
+
+static void wmt_mci_read_response(struct mmc_host *mmc)
+{
+	struct wmt_mci_priv *priv;
+	int idx1, idx2;
+	u8 tmp_resp;
+	u32 response;
+
+	priv = mmc_priv(mmc);
+
+	for (idx1 = 0; idx1 < 4; idx1++) {
+		response = 0;
+		for (idx2 = 0; idx2 < 4; idx2++) {
+			if ((idx1 == 3) && (idx2 == 3))
+				tmp_resp = readb(priv->sdmmc_base + SDMMC_RSP);
+			else
+				tmp_resp = readb(priv->sdmmc_base + SDMMC_RSP + (idx1*4) +
+								idx2 + 1);
+			response |= (tmp_resp << (idx2 * 8));
+		}
+		priv->cmd->resp[idx1] = cpu_to_be32(response);
+	}
+}
+
+static void wmt_mci_start_command(struct wmt_mci_priv *priv)
+{
+	u32 reg_tmp;
+
+	/* start command */
+	reg_tmp = readb(priv->sdmmc_base + SDMMC_CTLR);
+	writeb(reg_tmp | CTLR_CMD_START, priv->sdmmc_base + SDMMC_CTLR);
+}
+
+static int wmt_mci_send_command(struct mmc_host *mmc, u8 command, u8 cmdtype,
+		u32 arg, u8 rsptype)
+{
+	struct wmt_mci_priv *priv;
+	u32 reg_tmp;
+
+	priv = mmc_priv(mmc);
+
+	/* write command, arg, resptype registers */
+	writeb(command, priv->sdmmc_base + SDMMC_CMD);
+	writel(arg, priv->sdmmc_base + SDMMC_ARG);
+	writeb(rsptype, priv->sdmmc_base + SDMMC_RSPTYPE);
+
+	/* reset response FIFO */
+	reg_tmp = readb(priv->sdmmc_base + SDMMC_CTLR);
+	writeb(reg_tmp | CTLR_FIFO_RESET, priv->sdmmc_base + SDMMC_CTLR);
+
+	/* ensure clock enabled - VT3465 */
+	wmt_set_sd_power(priv, WMT_SD_POWER_ON);
+
+	/* clear status bits */
+	writeb(0xFF, priv->sdmmc_base + SDMMC_STS0);
+	writeb(0xFF, priv->sdmmc_base + SDMMC_STS1);
+	writeb(0xFF, priv->sdmmc_base + SDMMC_STS2);
+	writeb(0xFF, priv->sdmmc_base + SDMMC_STS3);
+
+	/* set command type */
+	reg_tmp = readb(priv->sdmmc_base + SDMMC_CTLR);
+	writeb((reg_tmp & 0x0F) | (cmdtype << 4), priv->sdmmc_base +
+		SDMMC_CTLR);
+
+	return 0;
+}
+
+static void wmt_mci_disable_dma(struct wmt_mci_priv *priv)
+{
+	writel(DMA_ISR_INT_STS, priv->sdmmc_base + SDDMA_ISR);
+	writel(0, priv->sdmmc_base + SDDMA_IER);
+}
+
+static void wmt_complete_data_request(struct wmt_mci_priv *priv)
+{
+	struct mmc_request *req;
+	req = priv->req;
+
+	req->data->bytes_xfered = req->data->blksz * req->data->blocks;
+
+	/* unmap the DMA pages used for write data */
+	if (req->data->flags & MMC_DATA_WRITE)
+		dma_unmap_sg(mmc_dev(priv->mmc), req->data->sg,
+			req->data->sg_len, DMA_TO_DEVICE);
+	else
+		dma_unmap_sg(mmc_dev(priv->mmc), req->data->sg,
+			req->data->sg_len, DMA_FROM_DEVICE);
+
+	/* Check if the DMA ISR returned a data error */
+	if ((req->cmd->error) || (req->data->error))
+		mmc_request_done(priv->mmc, req);
+	else {
+		wmt_mci_read_response(priv->mmc);
+		if (!req->data->stop)
+			/* single-block read/write requests end here*/
+			mmc_request_done(priv->mmc, req);
+		else {
+			/*
+			 * we change the priv->cmd variable so the response is stored
+			 * in the stop struct rather than the original calling command
+			 * struct
+			 */
+			priv->comp_cmd = &priv->cmdcomp;
+			init_completion(priv->comp_cmd);
+			priv->cmd = req->data->stop;
+			wmt_mci_send_command(priv->mmc, req->data->stop->opcode, 7,
+							req->data->stop->arg, 9);
+			wmt_mci_start_command(priv);
+		}
+	}
+}
+
+static irqreturn_t wmt_mci_dma_isr(int irq_num, void *data)
+{
+	struct mmc_host *mmc;
+	struct wmt_mci_priv *priv;
+
+	int status;
+
+	priv = (struct wmt_mci_priv *)data;
+	mmc = priv->mmc;
+
+	status = readl(priv->sdmmc_base + SDDMA_CCR) & 0x0F;
+
+	if (status != DMA_CCR_EVT_SUCCESS) {
+		printk(KERN_ERR "[MMC/SD] DMA Status = %d\n", status);
+		priv->req->data->error = -ETIMEDOUT;
+		complete(priv->comp_dma);
+		return IRQ_HANDLED;
+	}
+
+	priv->req->data->error = 0;
+
+	wmt_mci_disable_dma(priv);
+
+	complete(priv->comp_dma);
+
+	if (priv->comp_cmd)
+		if (completion_done(priv->comp_cmd))
+			/* if the command (reguler) interrupt has already completed,
+			 * finish off the request otherwise we wait for the command
+			 * interrupt and finish from there.
+			 */
+			wmt_complete_data_request(priv);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t wmt_mci_regular_isr(int irq_num, void *data)
+{
+	struct wmt_mci_priv *priv;
+	u32 status0;
+	u32 status1;
+	u32 status2;
+	u32 reg_tmp;
+	int cmd_done;
+
+	priv = (struct wmt_mci_priv *)data;
+	cmd_done = 0;
+	status0 = readb(priv->sdmmc_base + SDMMC_STS0);
+	status1 = readb(priv->sdmmc_base + SDMMC_STS1);
+	status2 = readb(priv->sdmmc_base + SDMMC_STS2);
+
+	/* Check for card insertion */
+	reg_tmp = readb(priv->sdmmc_base + SDMMC_INTMASK0);
+	if ((reg_tmp & INT0_DI_INT_EN) && (status0 & STS0_DEVICE_INS)) {
+		mmc_detect_change(priv->mmc, 0);
+		if (priv->cmd)
+			priv->cmd->error = -ETIMEDOUT;
+		if (priv->comp_cmd)
+			complete(priv->comp_cmd);
+		if (priv->comp_dma) {
+			wmt_mci_disable_dma(priv);
+			complete(priv->comp_dma);
+		}
+		writeb(STS0_DEVICE_INS, priv->sdmmc_base + SDMMC_STS0);
+		return IRQ_HANDLED;
+	}
+
+	if ((!priv->req->data) ||
+		((priv->req->data->stop) && (priv->cmd == priv->req->data->stop))) {
+		/* handle non-data & stop_transmission requests */
+		if (status1 & STS1_CMDRSP_DONE) {
+			priv->cmd->error = 0;
+			cmd_done = 1;
+		} else
+		if ((status1 & STS1_RSP_TIMEOUT) || (status1 & STS1_DATA_TIMEOUT)) {
+			priv->cmd->error = -ETIMEDOUT;
+			cmd_done = 1;
+		}
+		if (cmd_done) {
+			priv->comp_cmd = NULL;
+
+			if (!priv->cmd->error)
+				wmt_mci_read_response(priv->mmc);
+
+			priv->cmd = NULL;
+
+			/* All requests end here except single-block read/write */
+			mmc_request_done(priv->mmc, priv->req);
+		}
+	} else {
+		/* handle data requests */
+		if (status1 & STS1_CMDRSP_DONE) {
+			if (priv->cmd)
+				priv->cmd->error = 0;
+			if (priv->comp_cmd)
+				complete(priv->comp_cmd);
+		}
+
+		if ((status1 & STS1_RSP_TIMEOUT) || (status1 & STS1_DATA_TIMEOUT)) {
+			if (priv->cmd)
+				priv->cmd->error = -ETIMEDOUT;
+			if (priv->comp_cmd)
+				complete(priv->comp_cmd);
+			if (priv->comp_dma) {
+				wmt_mci_disable_dma(priv);
+				complete(priv->comp_dma);
+			}
+		}
+
+		if (priv->comp_dma)
+			/* if the dma interrupt has already completed, finish off the
+			 * request otherwise we wait for the DMA interrupt and finish
+			 * from there.
+			 */
+			if (completion_done(priv->comp_dma))
+				wmt_complete_data_request(priv);
+	}
+
+	writeb(status0, priv->sdmmc_base + SDMMC_STS0);
+	writeb(status1, priv->sdmmc_base + SDMMC_STS1);
+	writeb(status2, priv->sdmmc_base + SDMMC_STS2);
+
+	return IRQ_HANDLED;
+}
+
+static void wmt_reset_hardware(struct mmc_host *mmc)
+{
+	struct wmt_mci_priv *priv;
+	u32 reg_tmp;
+
+	priv = mmc_priv(mmc);
+
+	/* reset controller */
+	reg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);
+	writeb(reg_tmp | BM_SOFT_RESET, priv->sdmmc_base + SDMMC_BUSMODE);
+
+	/* reset response FIFO */
+	reg_tmp = readb(priv->sdmmc_base + SDMMC_CTLR);
+	writeb(reg_tmp | CTLR_FIFO_RESET, priv->sdmmc_base + SDMMC_CTLR);
+
+	/* enable GPI pin to detect card - necessary??? */
+	writew(BLKL_INT_ENABLE | BLKL_GPI_CD, priv->sdmmc_base + SDMMC_BLKLEN);
+
+	/* clear interrupt status */
+	writeb(0xFF, priv->sdmmc_base + SDMMC_STS0);
+	writeb(0xFF, priv->sdmmc_base + SDMMC_STS1);
+
+	/* setup interrupts */
+	writeb(INT0_CD_INT_EN | INT0_DI_INT_EN, priv->sdmmc_base +
+		SDMMC_INTMASK0);
+	writeb(INT1_DATA_TOUT_INT_EN | INT1_CMD_RES_TRAN_DONE_INT_EN |
+		INT1_CMD_RES_TOUT_INT_EN, priv->sdmmc_base + SDMMC_INTMASK1);
+
+	/* set the DMA timeout */
+	writew(8191, priv->sdmmc_base + SDMMC_DMATIMEOUT);
+
+	/* auto clock freezing enable */
+	reg_tmp = readb(priv->sdmmc_base + SDMMC_STS2);
+	writeb(reg_tmp | STS2_DIS_FORCECLK, priv->sdmmc_base + SDMMC_STS2);
+
+	/* set a default clock speed of 400Khz */
+	wmt_mci_clk_set_rate(400000);
+}
+
+static int wmt_dma_init(struct mmc_host *mmc)
+{
+	struct wmt_mci_priv *priv;
+
+	priv = mmc_priv(mmc);
+
+	writel(DMA_GCR_SOFT_RESET, priv->sdmmc_base + SDDMA_GCR);
+	writel(DMA_GCR_DMA_EN, priv->sdmmc_base + SDDMA_GCR);
+	if ((readl(priv->sdmmc_base + SDDMA_GCR) & DMA_GCR_DMA_EN) != 0)
+		return 0;
+	else
+		return 1;
+}
+
+static void wmt_dma_init_descriptor(struct wmt_dma_descriptor *desc,
+			u16 req_count, u32 buffer_addr, u32 branch_addr, int end)
+{
+	desc->flags = 0x40000000 | req_count;
+	if (end)
+		desc->flags |= 0x80000000;
+	desc->data_buffer_addr = buffer_addr;
+	desc->branch_addr = branch_addr;
+}
+
+#define PDMA_READ	0x00
+#define PDMA_WRITE	0x01
+
+static void wmt_dma_config(struct mmc_host *mmc, u32 descaddr, u8 dir)
+{
+	struct wmt_mci_priv *priv;
+	u32 reg_tmp;
+
+	priv = mmc_priv(mmc);
+
+	/* Enable DMA Interrupts */
+	writel(DMA_IER_INT_EN, priv->sdmmc_base + SDDMA_IER);
+
+	/* Write DMA Descriptor Pointer Register */
+	writel(descaddr, priv->sdmmc_base + SDDMA_DESPR);
+
+	writel(0x00, priv->sdmmc_base + SDDMA_CCR);
+
+	if (dir == PDMA_WRITE) {
+		reg_tmp = readl(priv->sdmmc_base + SDDMA_CCR);
+		writel(reg_tmp & DMA_CCR_IF_TO_PERIPHERAL, priv->sdmmc_base +
+				SDDMA_CCR);
+	} else {
+		reg_tmp = readl(priv->sdmmc_base + SDDMA_CCR);
+		writel(reg_tmp | DMA_CCR_PERIPHERAL_TO_IF, priv->sdmmc_base +
+				SDDMA_CCR);
+	}
+}
+
+static void wmt_dma_start(struct wmt_mci_priv *priv)
+{
+	u32 reg_tmp;
+
+	reg_tmp = readl(priv->sdmmc_base + SDDMA_CCR);
+	writel(reg_tmp | DMA_CCR_RUN, priv->sdmmc_base + SDDMA_CCR);
+}
+
+static void wmt_mci_request(struct mmc_host *mmc, struct mmc_request *req)
+{
+	struct wmt_mci_priv *priv;
+	struct wmt_dma_descriptor *desc;
+	u8 command;
+	u8 cmdtype;
+	u32 arg;
+	u8 rsptype;
+	u32 reg_tmp;
+
+	struct scatterlist *sg;
+	int i;
+	int sg_cnt;
+	int offset;
+	u32 dma_address;
+	int desc_cnt;
+
+	priv = mmc_priv(mmc);
+	priv->req = req;
+
+	/*
+	 * Use the cmd variable to pass a pointer to the resp[] structure
+	 * This is required on multi-block requests to pass the pointer to the
+	 * stop command
+	 */
+	priv->cmd = req->cmd;
+
+	command = req->cmd->opcode;
+	arg = req->cmd->arg;
+	rsptype = mmc_resp_type(req->cmd);
+	cmdtype = 0;
+
+	/* rsptype=7 only valid for SPI commands - should be =2 for SD */
+	if (rsptype == 7)
+		rsptype = 2;
+	/* rsptype=21 is R1B, convert for controller */
+	if (rsptype == 21)
+		rsptype = 9;
+
+	if (!req->data) {
+		wmt_mci_send_command(mmc, command, cmdtype, arg, rsptype);
+		wmt_mci_start_command(priv);
+		/* completion is now handled in the regular_isr() */
+	}
+	if (req->data) {
+		priv->comp_cmd = &priv->cmdcomp;
+		init_completion(priv->comp_cmd);
+
+		wmt_dma_init(mmc);
+
+		/* set controller data length */
+		reg_tmp = readw(priv->sdmmc_base + SDMMC_BLKLEN);
+		writew((reg_tmp & 0xF800) | (req->data->blksz - 1),
+			priv->sdmmc_base + SDMMC_BLKLEN);
+
+		/* set controller block count */
+		writew(req->data->blocks, priv->sdmmc_base + SDMMC_BLKCNT);
+
+		desc = (struct wmt_dma_descriptor *)priv->dma_desc_buffer;
+
+		if (req->data->flags & MMC_DATA_WRITE) {
+			sg_cnt = dma_map_sg(mmc_dev(mmc), req->data->sg,
+						req->data->sg_len, DMA_TO_DEVICE);
+			cmdtype = 1;
+			if (req->data->blocks > 1)
+				cmdtype = 3;
+		} else {
+			sg_cnt = dma_map_sg(mmc_dev(mmc), req->data->sg,
+						req->data->sg_len, DMA_FROM_DEVICE);
+			cmdtype = 2;
+			if (req->data->blocks > 1)
+				cmdtype = 4;
+		}
+
+		dma_address = priv->dma_desc_device_addr + 16;
+		desc_cnt = 0;
+
+		for_each_sg(req->data->sg, sg, sg_cnt, i) {
+			offset = 0;
+			while (offset < sg_dma_len(sg)) {
+				wmt_dma_init_descriptor(desc, req->data->blksz,
+						sg_dma_address(sg)+offset, dma_address, 0);
+				desc++;
+				desc_cnt++;
+				offset += req->data->blksz;
+				dma_address += 16;
+				if (desc_cnt == req->data->blocks)
+					break;
+			}
+		}
+		desc--;
+		desc->flags |= 0x80000000;
+
+		if (req->data->flags & MMC_DATA_WRITE)
+			wmt_dma_config(mmc, priv->dma_desc_device_addr, PDMA_WRITE);
+		else
+			wmt_dma_config(mmc, priv->dma_desc_device_addr, PDMA_READ);
+
+		wmt_mci_send_command(mmc, command, cmdtype, arg, rsptype);
+
+		priv->comp_dma = &priv->datacomp;
+		init_completion(priv->comp_dma);
+
+		wmt_dma_start(priv);
+		wmt_mci_start_command(priv);
+	}
+}
+
+static void wmt_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct wmt_mci_priv *priv;
+	u32 reg_tmp;
+
+	priv = mmc_priv(mmc);
+
+	if (ios->power_mode == MMC_POWER_UP) {
+		wmt_reset_hardware(mmc);
+
+		wmt_set_sd_power(priv, WMT_SD_POWER_ON);
+	}
+	if (ios->power_mode == MMC_POWER_OFF) {
+		wmt_set_sd_power(priv, WMT_SD_POWER_OFF);
+	}
+
+	wmt_mci_clk_set_rate(ios->clock);
+
+	switch (ios->bus_width) {
+	case MMC_BUS_WIDTH_8:
+		reg_tmp = readb(priv->sdmmc_base + SDMMC_EXTCTRL);
+		writeb(reg_tmp | 0x04, priv->sdmmc_base + SDMMC_EXTCTRL);
+		break;
+	case MMC_BUS_WIDTH_4:
+		reg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);
+		writeb(reg_tmp | BM_FOURBIT_MODE, priv->sdmmc_base + SDMMC_BUSMODE);
+
+		reg_tmp = readb(priv->sdmmc_base + SDMMC_EXTCTRL);
+		writeb(reg_tmp & 0xFB, priv->sdmmc_base + SDMMC_EXTCTRL);
+		break;
+	case MMC_BUS_WIDTH_1:
+		reg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);
+		writeb(reg_tmp & BM_ONEBIT_MASK, priv->sdmmc_base + SDMMC_BUSMODE);
+
+		reg_tmp = readb(priv->sdmmc_base + SDMMC_EXTCTRL);
+		writeb(reg_tmp & 0xFB, priv->sdmmc_base + SDMMC_EXTCTRL);
+		break;
+	}
+}
+
+static int wmt_mci_get_ro(struct mmc_host *mmc)
+{
+	struct wmt_mci_priv *priv;
+
+	priv = mmc_priv(mmc);
+	return ((readb(priv->sdmmc_base + SDMMC_STS0) >> 1) ^ 1) & 1;
+}
+
+static int wmt_mci_get_cd(struct mmc_host *mmc)
+{
+	struct wmt_mci_priv *priv;
+	u32 status0;
+
+	priv = mmc_priv(mmc);
+	status0 = readb(priv->sdmmc_base + SDMMC_STS0);
+	if (priv->driver_version >= WMT_MCI_3426_A0)
+	{
+		if (status0 & STS0_CD_GPI)
+			return 0;
+		else
+			return 1;
+	} else {
+		if (status0 & STS0_CD_GPI)
+			return 1;
+		else
+			return 0;
+	}
+}
+
+static struct mmc_host_ops wmt_mci_ops = {
+	.request = wmt_mci_request,
+	.set_ios = wmt_mci_set_ios,
+	.get_ro = wmt_mci_get_ro,
+	.get_cd = wmt_mci_get_cd,
+};
+
+static int __init wmt_mci_probe(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct wmt_mci_priv *priv;
+	struct resource *res;
+	int ret;
+	int platform_irq1;
+	int platform_irq2;
+	u32 driver_version;
+	void __iomem *gpio_base = 0;
+	u32 reg_tmp;
+
+	driver_version = wmt_mci_driver_version();
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		printk(KERN_ERR "[MMC/SD] Getting platform resource failed: MMIO\n");
+		return -ENXIO;
+	}
+
+	if (!request_mem_region(res->start,
+			res->end - res->start + 1, DRIVER_NAME)) {
+		printk(KERN_ERR "[MMC/SD] Getting memory region failed\n");
+		return -EBUSY;
+	}
+
+	/*
+	 * Two irqs should be defined, first for regular ISR, second for DMA ISR
+	 */
+	platform_irq1 = platform_get_irq(pdev, 0);
+	platform_irq2 = platform_get_irq(pdev, 1);
+
+	if ((platform_irq1 == NO_IRQ) | (platform_irq2 == NO_IRQ)) {
+		printk(KERN_ERR "[MMC/SD] Getting platform IRQs failed!\n");
+		ret = -ENXIO;
+		goto fail1;
+	}
+
+	mmc = mmc_alloc_host(sizeof(struct wmt_mci_priv), &pdev->dev);
+	if (!mmc) {
+		printk(KERN_ERR "[MMC/SD] Failed to allocate mmc_host\n");
+		ret = -ENOMEM;
+		goto fail1;
+	}
+
+	mmc->ops = &wmt_mci_ops;
+	mmc->f_min = 390425;
+	mmc->f_max = 50000000;
+	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
+	mmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED |
+			MMC_CAP_SD_HIGHSPEED;
+	mmc->max_seg_size = 65024;
+	mmc->max_segs = 128;
+	mmc->max_req_size = (16*512*mmc->max_segs);
+	mmc->max_blk_size = 2048;
+	mmc->max_blk_count = mmc->max_req_size / 512;
+
+	priv = mmc_priv(mmc);
+	priv->mmc = mmc;
+
+	priv->driver_version = driver_version;
+
+	/* Enable SD1 pin sharing - 3465 */
+	if (driver_version == WMT_MCI_3465)
+	{
+		gpio_base = ioremap(0xD8110000, 0x500);
+		if (!gpio_base)
+		{
+			printk(KERN_ERR "[MMC/SD] Failed to map GPIO IO space\n");
+			ret = -ENOMEM;
+			goto fail2;
+		}
+		/* PIN_SHARING_SEL */
+		reg_tmp = readl(gpio_base + 0x200);
+		writel(reg_tmp | 0x02, gpio_base + 0x200);
+		/* PULL_CTRL GP3 */
+		reg_tmp = readb(gpio_base + 0x4C3);
+		writeb(reg_tmp | 0x20, gpio_base + 0x4C3);
+		/* PULL_EN GP3 */
+		reg_tmp = readb(gpio_base + 0x483);
+		writeb(reg_tmp | 0x20, gpio_base + 0x483);
+	}
+
+	priv->sdmmc_base = ioremap(res->start, res->end - res->start + 1);
+	if (!priv->sdmmc_base) {
+		printk(KERN_ERR "[MMC/SD] Failed to map IO space\n");
+		ret = -ENOMEM;
+		goto fail2;
+	}
+
+	priv->irq_regular = platform_irq1;
+	priv->irq_dma = platform_irq2;
+
+	ret = request_irq(platform_irq1, wmt_mci_regular_isr, 0, "sdmmc", priv);
+	if (ret) {
+		printk(KERN_ERR "[MMC/SD] Failed to register interrupt handler \
+				(regular)\n");
+		goto fail3;
+	}
+
+	ret = request_irq(platform_irq2, wmt_mci_dma_isr, 32, "sdmmc", priv);
+	if (ret) {
+		printk(KERN_ERR "[MMC/SD] Failed to register interrupt handler \
+				(DMA)\n");
+		goto fail4;
+	}
+
+	/* alloc some DMA buffers for descriptors/transfers */
+	priv->dma_desc_buffer = dma_alloc_coherent(&pdev->dev,
+			mmc->max_blk_count * 16, &priv->dma_desc_device_addr, 208);
+	if (!priv->dma_desc_buffer) {
+		printk(KERN_ERR "[MMC/SD] Failed to allocate DMA descriptor \
+				memory\n");
+		ret = -EPERM;
+		goto fail5;
+	}
+
+	platform_set_drvdata(pdev, mmc);
+
+//	priv->clk_sdmmc = clk_get(NULL, "sdmmc");
+//	clk_enable(priv->clk_sdmmc);
+	pmc_base = ioremap(0xD8130000, 0x380);
+	if (!pmc_base) {
+		printk(KERN_ERR "[MMC/SD] Failed to remap power management \
+				registers\n");
+		ret = -ENOMEM;
+		goto fail5;
+	}
+	wmt_mci_clk_enable();
+
+	/* Configure GPIO7 as a low output */
+	gpio_request(7, "gpio-sd");
+	gpio_direction_output(7, 0);
+
+	/* configure the controller to a known 'ready' state */
+	wmt_reset_hardware(mmc);
+
+	if (driver_version == WMT_MCI_3465)
+	{
+		/* CTRL GP3 */
+		reg_tmp = readb(gpio_base + 0x43);
+		writeb(reg_tmp & ~0x20, gpio_base + 0x43);
+
+		iounmap(gpio_base);
+	}
+
+	mmc_add_host(mmc);
+
+	printk(KERN_INFO "[MMC/SD] WMT MCI Controller registered \
+			(DriverVersion=%d)\n", driver_version);
+
+	return 0;
+fail5:
+	free_irq(platform_irq1, priv);
+fail4:
+	free_irq(platform_irq1, priv);
+fail3:
+	iounmap(priv->sdmmc_base);
+fail2:
+	mmc_free_host(mmc);
+fail1:
+	release_mem_region(res->start, res->end - res->start + 1);
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int wmt_mci_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	u32 reg_tmp;
+	struct mmc_host *mmc;
+	struct wmt_mci_priv *priv;
+	int ret;
+
+	mmc = platform_get_drvdata(pdev);
+	if (!mmc)
+		return 0;
+
+	priv = mmc_priv(mmc);
+	ret = mmc_suspend_host(mmc);
+	if (!ret) {
+		reg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);
+		writeb(reg_tmp | BM_SOFT_RESET, priv->sdmmc_base + SDMMC_BUSMODE);
+	
+		reg_tmp = readw(priv->sdmmc_base + SDMMC_BLKLEN);
+		writew(reg_tmp & 0x5FFF, priv->sdmmc_base + SDMMC_BLKLEN);
+
+		writeb(0xFF, priv->sdmmc_base + SDMMC_STS0);
+		writeb(0xFF, priv->sdmmc_base + SDMMC_STS1);
+	}
+	/* disable SD clock */
+	return ret;
+}
+
+static int wmt_mci_resume(struct platform_device *pdev)
+{
+	u32 reg_tmp;
+	struct mmc_host *mmc;
+	struct wmt_mci_priv *priv;
+	int ret = 0;
+
+	mmc = platform_get_drvdata(pdev);
+	if (mmc) {
+		priv = mmc_priv(mmc);
+		/* enable SD clock */
+
+		reg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);
+		writeb(reg_tmp | BM_SOFT_RESET, priv->sdmmc_base + SDMMC_BUSMODE);
+
+		reg_tmp = readw(priv->sdmmc_base + SDMMC_BLKLEN);
+		writew(reg_tmp | (BLKL_GPI_CD | BLKL_INT_ENABLE), priv->sdmmc_base + SDMMC_BLKLEN);
+
+		reg_tmp = readb(priv->sdmmc_base + SDMMC_INTMASK0);
+		writeb(reg_tmp | INT0_DI_INT_EN, priv->sdmmc_base + SDMMC_INTMASK0);
+
+		ret = mmc_resume_host(mmc);
+	}
+
+	return ret;
+}
+#else
+
+#define wmt_mci_suspend NULL
+#define wmt_mci_resume NULL
+
+#endif
+
+static int __exit wmt_mci_remove(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct wmt_mci_priv *priv;
+	struct resource *res;
+	u32 reg_tmp;
+
+	/* TODO: temporary clock code */
+	if (pmc_base)
+		iounmap(pmc_base);
+
+	mmc = platform_get_drvdata(pdev);
+	priv = mmc_priv(mmc);
+
+	/* reset SD controller */
+	reg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);
+	writel(reg_tmp | BM_SOFT_RESET, priv->sdmmc_base + SDMMC_BUSMODE);
+	reg_tmp = readw(priv->sdmmc_base + SDMMC_BLKLEN);
+	writew(reg_tmp & ~(0xA000), priv->sdmmc_base + SDMMC_BLKLEN);
+	writeb(0xFF, priv->sdmmc_base + SDMMC_STS0);
+	writeb(0xFF, priv->sdmmc_base + SDMMC_STS1);
+
+	/* release the dma buffers */
+	dma_free_coherent(&pdev->dev, priv->mmc->max_blk_count * 16,
+			priv->dma_desc_buffer, priv->dma_desc_device_addr);
+
+	mmc_remove_host(mmc);
+
+	free_irq(priv->irq_regular, priv);
+	free_irq(priv->irq_dma, priv);
+
+	iounmap(priv->sdmmc_base);
+
+//	clk_disable(priv->clk_sdmmc);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	mmc_free_host(mmc);
+
+	platform_set_drvdata(pdev, NULL);
+
+	printk(KERN_INFO "[MMC/SD] WMT MCI device removed\n");
+
+	return 0;
+}
+
+
+static struct platform_driver wmt_mci_driver = {
+	.remove = __exit_p(wmt_mci_remove),
+	.suspend = wmt_mci_suspend,
+	.resume = wmt_mci_resume,
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init wmt_mci_init(void)
+{
+	return platform_driver_probe(&wmt_mci_driver, &wmt_mci_probe);
+}
+
+static void __exit wmt_mci_exit(void)
+{
+	platform_driver_unregister(&wmt_mci_driver);
+}
+
+module_init(wmt_mci_init);
+module_exit(wmt_mci_exit);
+
+MODULE_DESCRIPTION("WMT MMC/SD Driver");
+MODULE_AUTHOR("Tony Prisk");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:wmt-sdmmc");
diff -Naur linux-3.3-rc2/drivers/mtd/mtdcore.c wm8505-3.3rc2/drivers/mtd/mtdcore.c
--- linux-3.3-rc2/drivers/mtd/mtdcore.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/mtd/mtdcore.c	2012-02-06 12:27:43.000000000 -0700
@@ -119,7 +119,7 @@
 {
 	struct mtd_info *mtd = dev_get_drvdata(dev);
 
-	return mtd_suspend(mtd);
+	return mtd ? mtd_suspend(mtd) : 0;
 }
 
 static int mtd_cls_resume(struct device *dev)
diff -Naur linux-3.3-rc2/drivers/mtd/nand/atmel_nand.c wm8505-3.3rc2/drivers/mtd/nand/atmel_nand.c
--- linux-3.3-rc2/drivers/mtd/nand/atmel_nand.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/mtd/nand/atmel_nand.c	2012-02-06 12:27:43.000000000 -0700
@@ -161,6 +161,37 @@
                 !!host->board->rdy_pin_active_low;
 }
 
+/*
+ * Minimal-overhead PIO for data access.
+ */
+static void atmel_read_buf8(struct mtd_info *mtd, u8 *buf, int len)
+{
+	struct nand_chip	*nand_chip = mtd->priv;
+
+	__raw_readsb(nand_chip->IO_ADDR_R, buf, len);
+}
+
+static void atmel_read_buf16(struct mtd_info *mtd, u8 *buf, int len)
+{
+	struct nand_chip	*nand_chip = mtd->priv;
+
+	__raw_readsw(nand_chip->IO_ADDR_R, buf, len / 2);
+}
+
+static void atmel_write_buf8(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	struct nand_chip	*nand_chip = mtd->priv;
+
+	__raw_writesb(nand_chip->IO_ADDR_W, buf, len);
+}
+
+static void atmel_write_buf16(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	struct nand_chip	*nand_chip = mtd->priv;
+
+	__raw_writesw(nand_chip->IO_ADDR_W, buf, len / 2);
+}
+
 static void dma_complete_func(void *completion)
 {
 	complete(completion);
@@ -235,27 +266,33 @@
 static void atmel_read_buf(struct mtd_info *mtd, u8 *buf, int len)
 {
 	struct nand_chip *chip = mtd->priv;
+	struct atmel_nand_host *host = chip->priv;
 
 	if (use_dma && len > mtd->oobsize)
 		/* only use DMA for bigger than oob size: better performances */
 		if (atmel_nand_dma_op(mtd, buf, len, 1) == 0)
 			return;
 
-	/* if no DMA operation possible, use PIO */
-	memcpy_fromio(buf, chip->IO_ADDR_R, len);
+	if (host->board->bus_width_16)
+		atmel_read_buf16(mtd, buf, len);
+	else
+		atmel_read_buf8(mtd, buf, len);
 }
 
 static void atmel_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
 {
 	struct nand_chip *chip = mtd->priv;
+	struct atmel_nand_host *host = chip->priv;
 
 	if (use_dma && len > mtd->oobsize)
 		/* only use DMA for bigger than oob size: better performances */
 		if (atmel_nand_dma_op(mtd, (void *)buf, len, 0) == 0)
 			return;
 
-	/* if no DMA operation possible, use PIO */
-	memcpy_toio(chip->IO_ADDR_W, buf, len);
+	if (host->board->bus_width_16)
+		atmel_write_buf16(mtd, buf, len);
+	else
+		atmel_write_buf8(mtd, buf, len);
 }
 
 /*
diff -Naur linux-3.3-rc2/drivers/mtd/nand/gpmi-nand/gpmi-lib.c wm8505-3.3rc2/drivers/mtd/nand/gpmi-nand/gpmi-lib.c
--- linux-3.3-rc2/drivers/mtd/nand/gpmi-nand/gpmi-lib.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/mtd/nand/gpmi-nand/gpmi-lib.c	2012-02-06 12:27:43.000000000 -0700
@@ -69,17 +69,19 @@
  *  [1] enable the module.
  *  [2] reset the module.
  *
- * In most of the cases, it's ok. But there is a hardware bug in the BCH block.
+ * In most of the cases, it's ok.
+ * But in MX23, there is a hardware bug in the BCH block (see erratum #2847).
  * If you try to soft reset the BCH block, it becomes unusable until
  * the next hard reset. This case occurs in the NAND boot mode. When the board
  * boots by NAND, the ROM of the chip will initialize the BCH blocks itself.
  * So If the driver tries to reset the BCH again, the BCH will not work anymore.
- * You will see a DMA timeout in this case.
+ * You will see a DMA timeout in this case. The bug has been fixed
+ * in the following chips, such as MX28.
  *
  * To avoid this bug, just add a new parameter `just_enable` for
  * the mxs_reset_block(), and rewrite it here.
  */
-int gpmi_reset_block(void __iomem *reset_addr, bool just_enable)
+static int gpmi_reset_block(void __iomem *reset_addr, bool just_enable)
 {
 	int ret;
 	int timeout = 0x400;
@@ -206,7 +208,15 @@
 	if (ret)
 		goto err_out;
 
-	ret = gpmi_reset_block(r->bch_regs, true);
+	/*
+	* Due to erratum #2847 of the MX23, the BCH cannot be soft reset on this
+	* chip, otherwise it will lock up. So we skip resetting BCH on the MX23.
+	* On the other hand, the MX28 needs the reset, because one case has been
+	* seen where the BCH produced ECC errors constantly after 10000
+	* consecutive reboots. The latter case has not been seen on the MX23 yet,
+	* still we don't know if it could happen there as well.
+	*/
+	ret = gpmi_reset_block(r->bch_regs, GPMI_IS_MX23(this));
 	if (ret)
 		goto err_out;
 
diff -Naur linux-3.3-rc2/drivers/mtd/nand/Kconfig wm8505-3.3rc2/drivers/mtd/nand/Kconfig
--- linux-3.3-rc2/drivers/mtd/nand/Kconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/mtd/nand/Kconfig	2012-02-06 12:27:43.000000000 -0700
@@ -536,4 +536,11 @@
 	  Enables support for NAND Flash chips on the ST Microelectronics
 	  Flexible Static Memory Controller (FSMC)
 
+config MTD_NAND_WMT
+	tristate "Support for NAND on VIA/WonderMedia SoC's"
+	depends on ARCH_VT8500
+	help
+	  This enables support for the NAND controller found in VIA VT8500,
+	  WonderMedia WM8505 and possibly other similar chips.
+
 endif # MTD_NAND
diff -Naur linux-3.3-rc2/drivers/mtd/nand/Makefile wm8505-3.3rc2/drivers/mtd/nand/Makefile
--- linux-3.3-rc2/drivers/mtd/nand/Makefile	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/mtd/nand/Makefile	2012-02-06 12:27:43.000000000 -0700
@@ -49,5 +49,6 @@
 obj-$(CONFIG_MTD_NAND_RICOH)		+= r852.o
 obj-$(CONFIG_MTD_NAND_JZ4740)		+= jz4740_nand.o
 obj-$(CONFIG_MTD_NAND_GPMI_NAND)	+= gpmi-nand/
+obj-$(CONFIG_MTD_NAND_WMT)		+= wmt_nand.o
 
 nand-objs := nand_base.o nand_bbt.o
diff -Naur linux-3.3-rc2/drivers/mtd/nand/nand_base.c wm8505-3.3rc2/drivers/mtd/nand/nand_base.c
--- linux-3.3-rc2/drivers/mtd/nand/nand_base.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/mtd/nand/nand_base.c	2012-02-06 12:27:43.000000000 -0700
@@ -2588,7 +2588,7 @@
 	instr->state = MTD_ERASING;
 
 	while (len) {
-		/* Heck if we have a bad block, we do not erase bad blocks! */
+		/* Check if we have a bad block, we do not erase bad blocks! */
 		if (nand_block_checkbad(mtd, ((loff_t) page) <<
 					chip->page_shift, 0, allowbbt)) {
 			pr_warn("%s: attempt to erase a bad block at page 0x%08x\n",
diff -Naur linux-3.3-rc2/drivers/mtd/nand/wmt_nand.c wm8505-3.3rc2/drivers/mtd/nand/wmt_nand.c
--- linux-3.3-rc2/drivers/mtd/nand/wmt_nand.c	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/drivers/mtd/nand/wmt_nand.c	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,1202 @@
+/**
+ *
+ * Copyright (C) 2008 WonderMedia Technologies, Inc.
+ * Copyright (C) 2010 Alexey Charkov <alchark@gmail.com>
+ * Copyright (C) 2011 Darek Marcinkiewicz <reksio@newterm.pl>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*
+ * This is device driver for the NAND flash controller present
+ * on WonderMedia VT8500/WM8505 SOCs.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/mtd/nand.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/partitions.h>
+#include <linux/slab.h>
+
+#define VT8500_DATAPORT				0x00
+#define VT8500_MISC_STAT_PORT			0x28
+#define VT8500_COMMAND_READY			0x04
+#define VT8500_TRANSFER_IN_PROGRESS		0x02
+#define VT8500_READY_FLAG			0x01
+
+#define VT8500_SMC_DMA_COUNTER			0x30
+
+#define VT8500_ECC_BCH_CTRL			0x8c
+#define VT8500_ECC_TYPE_MASK			0xfffffff0
+#define VT8500_READ_RESUME			(1 << 8)
+#define VT8500_ECC_1BIT				0
+#define VT8500_ECC_4BIT				1
+#define VT8500_ECC_8BIT				2
+#define VT8500_ECC_12BIT			3
+#define VT8500_ECC_16BIT			4
+#define VT8500_ECC_24BITPER1K			5
+#define VT8500_ECC_40BITPER1K			6
+#define VT8500_ECC_44BITPER1K			7
+#define VT8500_ECC_44BIT			8
+
+#define VT8500_ECC_BCH_INT_MASK			0x90
+#define VT8500_ECC_BCH_INT_STAT1		0x94
+#define VT8500_ECC_BCH_INT_STAT2		0x98
+
+#define VT8500_ECC_BCH_ERR_POS1			0x9c
+#define VT8500_ECC_BCH_ERR_POS2			0xa0
+#define VT8500_NAND_TYPE_SEL			0x48
+
+#define VT8500_READ_CYCLE_PULE_CTRL		0x50
+#define VT8500_PULE_DIVISOR_MASK		0xffff0000;
+#define VT8500_PULE_DIVISOR_INITIAL_VALUE_MASK	0x2424
+
+#define VT8500_MISC_CTRL			0x54
+#define VT8500_SOFTWARE_ECC			0x4
+
+#define VT8500_PAGESIZE_DIVIDER_SEL		0x5c
+#define VT8500_CHIP_ENABLE_CTRL			0x44
+
+#define VT8500_DMA_COUNTER			0x20
+
+/*
+ * Control Registers
+ */
+#define VT8500_COMCTRL				0x04
+#define VT8500_COMPORT0				0x08
+#define VT8500_COMPORT1_2			0x0c
+#define VT8500_COMPORT3_4			0x10
+#define VT8500_COMPORT5_6			0x14
+#define VT8500_COMPORT7				0x18
+#define VT8500_COMPORT8_9			0x1c
+
+#define NFC_DMA_GCR				0x100
+#define NFC_DMA_IER				0x104
+#define NFC_DMA_ISR				0x108
+#define NFC_DMA_DESPR				0x10C
+#define NFC_DMA_RBR				0x110
+#define NFC_DMA_BAR				0x118
+#define NFC_DMA_DAR				0x114
+#define NFC_DMA_CPR				0x11C
+#define NFC_DMA_CCR				0x120
+
+#define VT8500_SMC_ENABLE			0x24
+
+/*
+ *  Status Control Registers
+ */
+#define VT8500_HOST_STAT_CHANGE			0x2c
+#define VT8500_BUSY_2_READY			0x8
+
+#define ECC_FIFO_0				0xc0
+#define ECC_FIFO_1				0xc4
+#define ECC_FIFO_2				0xc8
+#define ECC_FIFO_3				0xcc
+#define ECC_FIFO_4				0xd0
+#define ECC_FIFO_5				0xd4
+#define ECC_FIFO_6				0xd8
+#define ECC_FIFO_7				0xdc
+#define ECC_FIFO_8				0xe0
+#define ECC_FIFO_9				0xe4
+#define ECC_FIFO_a				0xe8
+#define ECC_FIFO_b				0xec
+#define ECC_FIFO_c				0xf0
+#define ECC_FIFO_d				0xf4
+#define ECC_FIFO_e				0xf8
+#define ECC_FIFO_f				0xfc
+
+/*
+ *	NAND PDMA - DMA_CCR : DMAContext Control Register for Channel 0
+ */
+#define VT8500_NAND_READ			0x00
+#define VT8500_NAND_WRITE			0x01
+#define VT8500_NAND_CCR_RUN			0x00000080
+#define VT8500_NAND_CCR_IF_TO_PERIPHERAL	0x00000000
+#define VT8500_NAND_CCR_PERIPHERAL_TO_IF	0x00400000
+#define VT8500_NAND_CCR_EVTCODE			0x0000000f
+#define VT8500_NAND_CCR_EVT_NO_STATUS		0x00000000
+#define VT8500_NAND_CCR_EVT_FF_UNDERRUN		0x00000001
+#define VT8500_NAND_CCR_EVT_FF_OVERRUN		0x00000002
+#define VT8500_NAND_CCR_EVT_DESP_READ		0x00000003
+#define VT8500_NAND_CCR_EVT_DATA_RW		0x00000004
+#define VT8500_NAND_CCR_EVT_EARLY_END		0x00000005
+#define VT8500_NAND_CCR_EVT_SUCCESS		0x0000000f
+
+#define VT8500_NAND_IER_INT_STS			0x00000001
+	/* [0] -- DMA interrupt status */
+#define VT8500_NAND_GCR_DMA_EN			0x00000001
+	/* [0] -- DMA controller enable */
+#define VT8500_NAND_GCR_SOFTRESET		0x00000100
+	/* [8] -- Software rest */
+
+#define VT8500_DMA_BUFFER_SIZE			4096
+
+#define VT8500_ECC_CORRECTION_FINISHED		0x100
+#define VT8500_ECC_ERROR			0x1
+#define VT8500_ECC_ERROR_OOB			(1 << 11)
+
+#define VT8500_COMMAND_NO_DATA			0x80
+#define VT8500_COMMAND_HAS_DATA			0x0
+
+#define VT8500_COMMAND_NAND_2_NFC		0x40
+#define VT8500_COMMAND_NFC_2_NAND		0x00
+
+#define VT8500_COMMAND_CYCLES_DMA		0
+#define VT8500_COMMAND_CYCLES_NONE		0
+#define VT8500_COMMAND_CYCLES_SINGLE		0x20
+
+#define VT8500_COMMAND_MULT_COMMANDS		0x10
+
+#define VT8500_TRIGGER_COMMAND			0x01
+
+#define VT8500_TYPE_SEL_CFG_WP_DISABLE		(1<<4)
+#define VT8500_TYPE_SEL_CFG_OLDDATA_E		(1<<2)
+#define VT8500_TYPE_SEL_CFG_WIDTH_8		0
+#define VT8500_TYPE_SEL_CFG_WIDTH_16		(1<<3)
+#define VT8500_TYPE_SEL_CFG_PAGE_512		0
+#define VT8500_TYPE_SEL_CFG_PAGE_2K		1
+#define VT8500_TYPE_SEL_CFG_PAGE_4K		2
+#define VT8500_TYPE_SEL_CFG_PAGE_8K		3
+#define VT8500_TYPE_SEL_CFG_DIRECT_MAP		(1<<5)
+#define VT8500_TYPE_SEL_CFG_CHECK_ALLFF		(1<<6)
+
+#define VT8500_PAGE_BLOCK_DIVISOR_MASK		0x000000e0
+#define VT8500_PAGE_BLOCK_DIVISOR_SHIFT		5
+#define VT8500_INTERRUPTS_ENABLE		0x101
+
+#define VT8500_INT1_REG				0x4c
+
+#define VT8500_DISABLE_MASKABLE_INTERRUPTS	0x40
+#define VT8500_DISABLE_BUSY_2_READY_INTERRUPT	0x08
+#define VT8500_DISABLE_UNCORRECTABLE_ERR_INTERRUPT	0x04
+#define VT8500_DISABLE_1BIT_ERROR_INTERRUPT	0x02
+#define VT8500_DISABLE_REDUNTANT_ERR_INTERRUPT	0x01
+
+#define VT8500_INT1_MASK  \
+	(VT8500_DISABLE_MASKABLE_INTERRUPTS | \
+	VT8500_DISABLE_UNCORRECTABLE_ERR_INTERRUPT | \
+	VT8500_DISABLE_REDUNTANT_ERR_INTERRUPT)
+
+#define PMPMB_ADDR				0x0204
+#define PMNAND_ADDR				0x0330
+#define PMCS_ADDR				0x0000
+#define PMCEU_ADDR				0x0254
+
+#define PLL_B_CLOCK_SPEED			25 /*Mhz*/
+#define NAND_MAX_CLOCK_SPEED			56 /*Mhz*/
+
+static struct nand_ecclayout vt8500_oobinfo = {
+	.eccbytes = 7,
+	.eccpos = {24, 25, 26, 27, 28, 29, 30},
+	.oobavail = 24,
+	.oobfree = { {0, 24} }
+};
+
+struct vt8500_dma_desc {
+	u32 req_count:16;
+	u32 i:1;
+	u32 r1:13;
+	u32 format:1;
+	u32 end:1;
+	u32 addr:32;
+	u32 branch_addr:32;
+	u32 r2:32;
+};
+
+struct vt8500_priv {
+	struct mtd_info mtd;
+	struct nand_chip nand;
+
+	struct device *device;
+
+	dma_addr_t dmaaddr;
+	unsigned char *dmabuf;
+
+	dma_addr_t dma_d_addr;
+	struct vt8500_dma_desc *dma_desc;
+
+	int dataptr;
+
+	int page;
+
+	int nand_irq;
+	int dma_irq;
+
+	unsigned long dma_status;
+
+	struct completion nand_complete;
+	struct completion dma_complete;
+
+	struct resource *nfc_mem_region;
+};
+
+static uint8_t vt8500_bbt_pattern[] = { 'B', 'b', 't', '0' };
+
+static struct nand_bbt_descr vt8500_bbt_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 9,
+	.len = 4,
+	.veroffs = 1,
+	.maxblocks = 4,
+	.pattern = vt8500_bbt_pattern,
+};
+
+static uint8_t vt8500_mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr vt8500_bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 9,
+	.len = 4,
+	.veroffs = 1,
+	.maxblocks = 4,
+	.pattern = vt8500_mirror_pattern,
+};
+
+struct vt8500_priv *vt8500_mtd_to_priv(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct vt8500_priv, mtd);
+}
+
+int vt8500_get_bit(struct vt8500_priv *vt8500, int address, unsigned bit)
+{
+	return readl(vt8500->nand.IO_ADDR_R + address) & bit;
+}
+
+void vt8500_set_bit(struct vt8500_priv *vt8500, int address, unsigned val)
+{
+	unsigned long t = readl(vt8500->nand.IO_ADDR_R + address);
+	t |= val;
+	writel(t, vt8500->nand.IO_ADDR_R + address);
+}
+
+void vt8500_clear_bit(struct vt8500_priv *vt8500, int address, unsigned bit)
+{
+	unsigned long t = readl(vt8500->nand.IO_ADDR_R + address);
+	t &= ~bit;
+	writel(t, vt8500->nand.IO_ADDR_R + address);
+}
+
+static int vt8500_set_clock(struct vt8500_priv *vt8500)
+{
+	unsigned long clock_freq;
+	unsigned long divisor;
+	unsigned long mult;
+	unsigned long ptRP = 12000;
+	unsigned long ptRC = 25000;
+	unsigned long ptWP = 12000;
+	unsigned long ptWC = 25000;
+	unsigned long reg;
+	unsigned long pule_reg;
+	unsigned long min_val;
+
+	void __iomem *pmc_mem = ioremap(0xd8130000, 0x400);
+	BUG_ON(pmc_mem == NULL);
+
+	mult = readb(pmc_mem + PMPMB_ADDR) & 0x1f;
+	if (mult < 4)
+		clock_freq = PLL_B_CLOCK_SPEED;
+	else
+		clock_freq = mult * 2 * PLL_B_CLOCK_SPEED;
+
+	if (readb(pmc_mem + PMPMB_ADDR) & 0x100)
+		clock_freq /= 2;
+
+	dev_info(vt8500->device, "Clock frequency: %ld\n", clock_freq);
+
+	min_val = min(min(ptRP, ptRC), min(ptWP, ptWC));
+
+	divisor = clock_freq / NAND_MAX_CLOCK_SPEED + 1;
+
+	pule_reg = readl(vt8500->nand.IO_ADDR_R +
+		VT8500_READ_CYCLE_PULE_CTRL) & VT8500_PULE_DIVISOR_MASK;
+
+	reg = ptRP / min_val;
+	reg <<= 4;
+
+	reg |= ptRC / min_val;
+	reg <<= 4;
+
+	reg |= ptWP / min_val;
+	reg <<= 4;
+
+	reg |= ptWC / min_val;
+
+	dev_info(vt8500->device, "Setting divisor: %ld\n", divisor);
+
+	writel((divisor & 0x1FF), pmc_mem + PMNAND_ADDR);
+	while ((readl(pmc_mem + PMCS_ADDR)) & (1 << 25))
+		cpu_relax();
+	dev_info(vt8500->device, "Setting pule register value: %lx\n", reg);
+
+	writel(pule_reg | reg,
+	       vt8500->nand.IO_ADDR_R + VT8500_READ_CYCLE_PULE_CTRL);
+
+	iounmap(pmc_mem);
+
+	return 0;
+}
+
+void __iomem *vt8500_nand_addr_cycle_to_reg(struct vt8500_priv *vt8500,
+					    int cycle)
+{
+	u8 *addr_reg = vt8500->nand.IO_ADDR_R + VT8500_COMPORT1_2;
+	return addr_reg + 4 * (cycle / 2) + cycle % 2;
+}
+
+static int vt8500_set_addr(struct vt8500_priv *vt8500, int column,
+			   int page_addr)
+{
+	struct nand_chip *chip = &vt8500->nand;
+	int addr_cycle = 0;
+	u8 *addr_reg;
+
+	if (column != -1) {
+		addr_reg = vt8500_nand_addr_cycle_to_reg(vt8500, addr_cycle++);
+		writeb(column, addr_reg);
+		column >>= 8;
+
+		addr_reg = vt8500_nand_addr_cycle_to_reg(vt8500, addr_cycle++);
+		writeb(column, addr_reg);
+	}
+
+	if (page_addr != -1) {
+		addr_reg = vt8500_nand_addr_cycle_to_reg(vt8500, addr_cycle++);
+		writeb(page_addr, addr_reg);
+		page_addr >>= 8;
+
+		addr_reg = vt8500_nand_addr_cycle_to_reg(vt8500, addr_cycle++);
+		writeb(page_addr, addr_reg);
+
+		if (chip->chip_shift - chip->page_shift > 16) {
+			page_addr >>= 8;
+			addr_reg =
+			    vt8500_nand_addr_cycle_to_reg(vt8500, addr_cycle++);
+			writeb(page_addr, addr_reg);
+		}
+	}
+
+	return addr_cycle;
+}
+
+static void vt8500_clear_busy2ready(struct vt8500_priv *vt8500)
+{
+	vt8500_set_bit(vt8500, VT8500_HOST_STAT_CHANGE, VT8500_BUSY_2_READY);
+}
+
+static int vt8500_get_busy2ready(struct vt8500_priv *vt8500)
+{
+	return vt8500_get_bit(vt8500, VT8500_HOST_STAT_CHANGE,
+			      VT8500_BUSY_2_READY);
+}
+
+static int vt8500_wait_cmd_ready(struct vt8500_priv *vt8500)
+{
+	int loop_guard = (1 << 20);
+
+	while (--loop_guard &&
+		vt8500_get_bit(vt8500, VT8500_MISC_STAT_PORT,
+			       VT8500_COMMAND_READY))
+		cpu_relax();
+
+	BUG_ON(!loop_guard);
+
+	return 0;
+}
+
+static int vt8500_wait_transfer_ready(struct vt8500_priv *vt8500)
+{
+	int loop_guard = (1 << 28);
+
+	while (--loop_guard &&
+		vt8500_get_bit(vt8500, VT8500_MISC_STAT_PORT,
+			       VT8500_TRANSFER_IN_PROGRESS))
+		cpu_relax();
+
+	BUG_ON(!loop_guard);
+
+	return 0;
+}
+
+static int vt8500_device_ready(struct mtd_info *mtd)
+{
+	struct vt8500_priv *vt8500 = vt8500_mtd_to_priv(mtd);
+	return vt8500_get_bit(vt8500, VT8500_MISC_STAT_PORT, VT8500_READY_FLAG);
+}
+
+static int vt8500_read_page(struct mtd_info *mtd, struct nand_chip *chip,
+			    uint8_t *buf, int page)
+{
+	struct vt8500_priv *vt8500 = vt8500_mtd_to_priv(mtd);
+
+	chip->read_buf(mtd, buf, mtd->writesize);
+	memcpy_fromio(chip->oob_poi, vt8500->nand.IO_ADDR_R + ECC_FIFO_0,
+		      min(64u, mtd->oobsize));
+
+	return 0;
+}
+
+static void vt8500_trigger_command(struct vt8500_priv *vt8500, int flag,
+				   int command_bytes);
+static void vt8500_setup_dma_transfer(struct vt8500_priv *vt8500,
+				      int direction);
+static int vt8500_wait_dma_end(struct vt8500_priv *vt8500);
+
+static int vt8500_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
+			    int page)
+{
+	int addr_cycle;
+	int status;
+	struct vt8500_priv *vt8500 = vt8500_mtd_to_priv(mtd);
+
+	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+	vt8500->dataptr = 0;
+	addr_cycle = vt8500_set_addr(vt8500, 0, page);
+	vt8500_setup_dma_transfer(vt8500, VT8500_NAND_WRITE);
+
+	memset_io(vt8500->nand.IO_ADDR_R + ECC_FIFO_0, 0xff, 64);
+	memcpy_toio(vt8500->nand.IO_ADDR_R + ECC_FIFO_0, chip->oob_poi,
+		    min(24u, mtd->oobsize));
+
+	writeb(NAND_CMD_SEQIN, vt8500->nand.IO_ADDR_W);
+	vt8500_trigger_command(vt8500, VT8500_COMMAND_NFC_2_NAND,
+			       addr_cycle + 1);
+
+	vt8500_wait_dma_end(vt8500);
+
+	vt8500_wait_transfer_ready(vt8500);
+
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+
+}
+
+static void vt8500_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+			      const uint8_t *buf)
+{
+	int addr_cycle;
+	struct vt8500_priv *vt8500 = vt8500_mtd_to_priv(mtd);
+
+	memset_io(vt8500->nand.IO_ADDR_R + ECC_FIFO_0, 0xff, 64);
+	memcpy_toio(vt8500->nand.IO_ADDR_R + ECC_FIFO_0, chip->oob_poi,
+		    min(24u, mtd->oobsize));
+
+	vt8500->dataptr = 0;
+	chip->write_buf(mtd, buf, mtd->writesize);
+
+	addr_cycle = vt8500_set_addr(vt8500, 0, vt8500->page);
+
+	vt8500_setup_dma_transfer(vt8500, VT8500_NAND_WRITE);
+
+	writeb(NAND_CMD_SEQIN, vt8500->nand.IO_ADDR_W);
+	vt8500_trigger_command(vt8500, VT8500_COMMAND_NFC_2_NAND,
+			       addr_cycle + 1);
+
+	vt8500_wait_dma_end(vt8500);
+
+	vt8500_wait_transfer_ready(vt8500);
+}
+
+static int vt8500_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf, int page)
+{
+	struct vt8500_priv *vt8500 = vt8500_mtd_to_priv(mtd);
+
+	chip->read_buf(mtd, buf, mtd->writesize);
+	memcpy_fromio(chip->oob_poi, vt8500->nand.IO_ADDR_R + ECC_FIFO_0,
+		      min(64u, mtd->oobsize));
+
+	return 0;
+}
+
+static void vt8500_select_chip(struct mtd_info *mtd, int chipnr)
+{
+
+	struct vt8500_priv *vt8500 = vt8500_mtd_to_priv(mtd);
+
+	dev_dbg(vt8500->device, "Selecting chip nr %d", chipnr);
+
+	switch (chipnr) {
+	case -1:
+		writeb(0xff, vt8500->nand.IO_ADDR_R + VT8500_CHIP_ENABLE_CTRL);
+		break;
+	case 0:
+		writeb(0xfe, vt8500->nand.IO_ADDR_R + VT8500_CHIP_ENABLE_CTRL);
+		break;
+	default:
+		dev_err(vt8500->device,
+			"Only one chip nr 0 is supported, got chip nr:%d",
+			chipnr);
+		BUG();
+		break;
+	}
+}
+
+static void vt8500_setup_command(struct vt8500_priv *vt8500, int flag,
+				 int command_bytes)
+{
+	u8 byte = 0;
+	byte |= flag;
+	byte |= command_bytes << 1;
+	writeb(byte, vt8500->nand.IO_ADDR_R + VT8500_COMCTRL);
+}
+
+static void vt8500_trigger_command(struct vt8500_priv *vt8500, int flag,
+				   int command_bytes)
+{
+	flag |= VT8500_TRIGGER_COMMAND;
+	vt8500_setup_command(vt8500, flag, command_bytes);
+}
+
+static void vt8500_read_resume(struct vt8500_priv *vt8500)
+{
+	vt8500_set_bit(vt8500, VT8500_ECC_BCH_CTRL, VT8500_READ_RESUME);
+}
+
+static u8 vt8500_bit_correct(u8 val, int bit)
+{
+	return val ^ (1 << bit);
+}
+
+static void vt8500_correct_error(struct vt8500_priv *vt8500)
+{
+	int i, err_count, err_byte, err_bit, err_reg, oob, bank, err_idx;
+	u8 v;
+
+	err_count = readl(vt8500->nand.IO_ADDR_R + VT8500_ECC_BCH_INT_STAT2) & 0xf;
+	oob =
+	    vt8500_get_bit(vt8500, VT8500_ECC_BCH_INT_STAT2,
+			   VT8500_ECC_ERROR_OOB);
+
+	if (!oob)
+		bank =
+		    (readl(vt8500->nand.IO_ADDR_R + VT8500_ECC_BCH_INT_STAT2) >> 8) &
+		    0x3;
+
+	if (err_count > 4) {
+		dev_info(vt8500->device,
+			 "Too many errors(%d), cannot correct.\n", err_count);
+
+		vt8500->mtd.ecc_stats.failed++;
+		vt8500_read_resume(vt8500);
+		return;
+	}
+
+	for (i = 0; i < err_count; i++) {
+		err_reg =
+		    readl(vt8500->nand.IO_ADDR_R + VT8500_ECC_BCH_ERR_POS1 +
+			  4 * (i / 2));
+		if (i % 2)
+			err_reg >>= 16;
+		err_reg &= 0x1fff;
+		err_byte = err_reg >> 3;
+		err_bit = err_reg & 0x7;
+
+		dev_info(vt8500->device, "Correcting byte: %d, bit: %d\n",
+			 err_byte, err_bit);
+
+		if (!oob) {
+			err_idx = vt8500->nand.ecc.size * bank + err_byte;
+			v = vt8500->dmabuf[err_idx];
+			v = vt8500_bit_correct(v, err_bit);
+			vt8500->dmabuf[err_idx] = v;
+		} else {
+			v = readb(vt8500->nand.IO_ADDR_R + ECC_FIFO_0 + err_byte);
+			v = vt8500_bit_correct(v, err_bit);
+			writeb(v, vt8500->nand.IO_ADDR_R + ECC_FIFO_0 + err_byte);
+		}
+	}
+
+	vt8500_read_resume(vt8500);
+}
+
+static void vt8500_setup_dma_transfer(struct vt8500_priv *vt8500, int direction)
+{
+	unsigned long tmp;
+
+	writew(vt8500->mtd.writesize - 1, vt8500->nand.IO_ADDR_R + VT8500_DMA_COUNTER);
+
+	if (readl(vt8500->nand.IO_ADDR_R + NFC_DMA_ISR) & VT8500_NAND_IER_INT_STS) {
+		int loop_guard = 1 << 20;
+
+		writel(VT8500_NAND_IER_INT_STS, vt8500->nand.IO_ADDR_R + NFC_DMA_ISR);
+
+		while (--loop_guard &&
+			(readl(vt8500->nand.IO_ADDR_R + NFC_DMA_ISR) &
+			VT8500_NAND_IER_INT_STS))
+			cpu_relax();
+
+		if (!loop_guard) {
+			dev_err(vt8500->device,
+				"PDMA interrupt status can't be cleared");
+			dev_err(vt8500->device, "NFC_DMA_ISR = 0x%8.8x\n",
+				(unsigned int)readl(vt8500->nand.IO_ADDR_R +
+						    NFC_DMA_ISR));
+			BUG();
+		}
+	}
+
+	writel(VT8500_NAND_GCR_SOFTRESET, vt8500->nand.IO_ADDR_R + NFC_DMA_GCR);
+	writel(VT8500_NAND_GCR_DMA_EN, vt8500->nand.IO_ADDR_R + NFC_DMA_GCR);
+	/* check if we really succeeded */
+	BUG_ON((readl(vt8500->nand.IO_ADDR_R + NFC_DMA_GCR) & VT8500_NAND_GCR_DMA_EN)
+	       == 0);
+
+	memset(vt8500->dma_desc, 0, sizeof(*vt8500->dma_desc));
+	vt8500->dma_desc->req_count = vt8500->mtd.writesize;
+	vt8500->dma_desc->format = 1;
+	vt8500->dma_desc->i = 1;
+	vt8500->dma_desc->addr = (u32) vt8500->dmaaddr;
+	vt8500->dma_desc->end = 1;
+
+	writel((u32) vt8500->dma_d_addr, vt8500->nand.IO_ADDR_R + NFC_DMA_DESPR);
+
+	/* set direction */
+	tmp = readl(vt8500->nand.IO_ADDR_R + NFC_DMA_CCR);
+	if (direction == VT8500_NAND_READ)
+		tmp |= VT8500_NAND_CCR_PERIPHERAL_TO_IF;
+	else
+		tmp &= ~VT8500_NAND_CCR_IF_TO_PERIPHERAL;
+	writel(tmp, vt8500->nand.IO_ADDR_R + NFC_DMA_CCR);
+
+	writel(1, vt8500->nand.IO_ADDR_R + NFC_DMA_IER);
+
+	tmp = readl(vt8500->nand.IO_ADDR_R + NFC_DMA_CCR);
+	tmp |= VT8500_NAND_CCR_RUN;
+	writel(tmp, vt8500->nand.IO_ADDR_R + NFC_DMA_CCR);
+
+}
+
+static int vt8500_wait_dma_end(struct vt8500_priv *vt8500)
+{
+	if (!wait_for_completion_interruptible_timeout
+	    (&vt8500->dma_complete, msecs_to_jiffies(1000))) {
+		dev_err(vt8500->device, "Waiting for dma interrupt failed!\n");
+		return -1;
+	}
+
+	if (vt8500->dma_status == VT8500_NAND_CCR_EVT_FF_UNDERRUN)
+		dev_err(vt8500->device, "PDMA Buffer under run!\n");
+
+	if (vt8500->dma_status == VT8500_NAND_CCR_EVT_FF_OVERRUN)
+		dev_err(vt8500->device, "PDMA Buffer over run!\n");
+
+	if (vt8500->dma_status == VT8500_NAND_CCR_EVT_DESP_READ)
+		dev_err(vt8500->device, "PDMA read Descriptor error!\n");
+
+	if (vt8500->dma_status == VT8500_NAND_CCR_EVT_DATA_RW)
+		dev_err(vt8500->device,
+			"PDMA read/write memory descriptor error!\n");
+
+	if (vt8500->dma_status == VT8500_NAND_CCR_EVT_EARLY_END)
+		dev_err(vt8500->device, "PDMA read early end!\n");
+
+	return 0;
+}
+
+static int vt8500_wait_nand_completion(struct vt8500_priv *vt8500)
+{
+	if (!wait_for_completion_interruptible_timeout
+	    (&vt8500->nand_complete, msecs_to_jiffies(1000))) {
+		dev_err(vt8500->device, "Waiting for nand interrupt failed!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void vt8500_read_command(struct vt8500_priv *vt8500, int page_addr,
+				int column, int command)
+{
+	int addr_cycle;
+	unsigned short tmp;
+
+	if (command == NAND_CMD_READOOB && column != -1)
+		column +=
+		    (vt8500->nand.ecc.size +
+		     vt8500->nand.ecc.bytes) * vt8500->nand.ecc.steps;
+
+	addr_cycle = vt8500_set_addr(vt8500, column, page_addr);
+
+	if (command == NAND_CMD_READ0)
+		vt8500_setup_dma_transfer(vt8500, VT8500_NAND_READ);
+
+	tmp = readw(vt8500->nand.IO_ADDR_R + VT8500_ECC_BCH_INT_STAT1);
+	tmp |= VT8500_ECC_ERROR | VT8500_ECC_CORRECTION_FINISHED;
+	writew(tmp, vt8500->nand.IO_ADDR_R + VT8500_ECC_BCH_INT_STAT1);
+
+	vt8500->dataptr = 0;
+
+	writeb(NAND_CMD_READ0, vt8500->nand.IO_ADDR_W);
+	writeb(NAND_CMD_READSTART,
+	       vt8500_nand_addr_cycle_to_reg(vt8500, addr_cycle));
+	vt8500_trigger_command(vt8500,
+			       VT8500_COMMAND_NAND_2_NFC |
+			       VT8500_COMMAND_MULT_COMMANDS, addr_cycle + 2);
+
+	if (command == NAND_CMD_READ0)
+		vt8500_wait_dma_end(vt8500);
+
+	vt8500_wait_nand_completion(vt8500);
+}
+
+static void vt8500_nand_cmdfunc(struct mtd_info *mtd, unsigned command,
+				int column, int page_addr)
+{
+
+	struct vt8500_priv *vt8500 = vt8500_mtd_to_priv(mtd);
+	int addr_cycle = 0;
+
+	dev_dbg(vt8500->device, "Command: %u, column: %x, page_addr: %x\n",
+		command, column, page_addr);
+
+	switch (command) {
+	case NAND_CMD_SEQIN:
+		vt8500->page = page_addr;
+		return;
+	case NAND_CMD_READID:
+	case NAND_CMD_ERASE1:
+		addr_cycle = vt8500_set_addr(vt8500, column, page_addr);
+	case NAND_CMD_RESET:
+	case NAND_CMD_ERASE2:
+	case NAND_CMD_PAGEPROG:
+	case NAND_CMD_STATUS:
+		writeb(command, vt8500->nand.IO_ADDR_W);
+
+		vt8500_trigger_command(vt8500, VT8500_COMMAND_NO_DATA |
+				       VT8500_COMMAND_NFC_2_NAND |
+				       VT8500_COMMAND_CYCLES_NONE,
+				       addr_cycle + 1);
+		if (command == NAND_CMD_ERASE1 || command == NAND_CMD_STATUS
+					       || command == NAND_CMD_READID)
+			vt8500_wait_cmd_ready(vt8500);
+		else
+			vt8500_wait_nand_completion(vt8500);
+
+		break;
+	case NAND_CMD_READOOB:
+	case NAND_CMD_READ0:
+		vt8500_read_command(vt8500, page_addr, column, command);
+		break;
+	default:
+		dev_err(vt8500->device,
+			"Command: %u, column: %d, page_addr: %d\n", command,
+			column, page_addr);
+		BUG();
+	}
+}
+
+static int vt8500_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+			   int page, int sndcmd)
+{
+
+	struct vt8500_priv *vt8500 = vt8500_mtd_to_priv(mtd);
+	uint8_t *buf = chip->oob_poi;
+
+	vt8500_set_bit(vt8500, VT8500_SMC_ENABLE, 0x02);
+
+	if (sndcmd)
+		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+
+	memcpy_fromio(buf, vt8500->nand.IO_ADDR_R + ECC_FIFO_0,
+		      min(64u, mtd->oobsize));
+
+	vt8500_clear_bit(vt8500, VT8500_SMC_ENABLE, 0x02);
+	return 0;
+}
+
+static void vt8500_init_chip(struct vt8500_priv *vt8500)
+{
+	unsigned long t;
+	u32 page_per_block_div;
+	u8 type = VT8500_TYPE_SEL_CFG_CHECK_ALLFF
+	    | VT8500_TYPE_SEL_CFG_WP_DISABLE
+	    | VT8500_TYPE_SEL_CFG_DIRECT_MAP
+	    | VT8500_TYPE_SEL_CFG_WIDTH_8 | VT8500_TYPE_SEL_CFG_DIRECT_MAP;
+
+	switch (vt8500->mtd.writesize) {
+	case 512:
+		type |= VT8500_TYPE_SEL_CFG_PAGE_512;
+		break;
+	case 2048:
+		type |= VT8500_TYPE_SEL_CFG_PAGE_2K;
+		break;
+	case 4096:
+		type |= VT8500_TYPE_SEL_CFG_PAGE_4K;
+		break;
+	case 8192:
+		type |= VT8500_TYPE_SEL_CFG_PAGE_8K;
+		break;
+	default:
+		BUG();
+	}
+
+	writeb(type, vt8500->nand.IO_ADDR_R + VT8500_NAND_TYPE_SEL);
+
+	switch (vt8500->mtd.erasesize / vt8500->mtd.writesize) {
+	case 16:
+		page_per_block_div = 0;
+		break;
+	case 32:
+		page_per_block_div = 1;
+		break;
+	case 64:
+		page_per_block_div = 2;
+		break;
+	case 128:
+		page_per_block_div = 3;
+		break;
+	case 256:
+		page_per_block_div = 4;
+		break;
+	case 512:
+		page_per_block_div = 5;
+		break;
+	default:
+		BUG();
+	}
+	page_per_block_div <<= VT8500_PAGE_BLOCK_DIVISOR_SHIFT;
+
+	t = readl(vt8500->nand.IO_ADDR_R + VT8500_PAGESIZE_DIVIDER_SEL);
+	t &= ~VT8500_PAGE_BLOCK_DIVISOR_MASK;
+	t |= page_per_block_div;
+	writel(t, vt8500->nand.IO_ADDR_R + VT8500_PAGESIZE_DIVIDER_SEL);
+
+	/* set ecc type */
+	t = readl(vt8500->nand.IO_ADDR_R + VT8500_ECC_BCH_CTRL);
+	t &= VT8500_ECC_TYPE_MASK;
+
+	if (vt8500->mtd.writesize >= 8192)
+		t |= VT8500_ECC_24BITPER1K;
+	else if (vt8500->mtd.writesize >= 4096 && vt8500->mtd.oobsize >= 218)
+		t |= VT8500_ECC_12BIT;
+	else if (vt8500->mtd.writesize > 512)
+		t |= VT8500_ECC_4BIT;
+	else
+		t |= VT8500_ECC_1BIT;
+
+	writel(t, vt8500->nand.IO_ADDR_R + VT8500_ECC_BCH_CTRL);
+
+	/* enable hardware ecc */
+	vt8500_clear_bit(vt8500, VT8500_MISC_CTRL, VT8500_SOFTWARE_ECC);
+
+	/* enable ecc interrupt */
+	writew(VT8500_INTERRUPTS_ENABLE,
+	       vt8500->nand.IO_ADDR_R + VT8500_ECC_BCH_INT_MASK);
+}
+
+static void vt8500_write_buf(struct mtd_info *mtd, const uint8_t * buf, int len)
+{
+	struct vt8500_priv *vt8500 = vt8500_mtd_to_priv(mtd);
+
+	len = min(len, (VT8500_DMA_BUFFER_SIZE - vt8500->dataptr));
+
+	memcpy(vt8500->dmabuf + vt8500->dataptr, buf, len);
+	vt8500->dataptr += len;
+}
+
+static void vt8500_read_buf(struct mtd_info *mtd, uint8_t * buf, int len)
+{
+	struct vt8500_priv *vt8500 = vt8500_mtd_to_priv(mtd);
+
+	len = min(len, (VT8500_DMA_BUFFER_SIZE - vt8500->dataptr));
+
+	memcpy(buf, vt8500->dmabuf + vt8500->dataptr, len);
+	vt8500->dataptr += len;
+}
+
+static uint8_t vt8500_read_byte(struct mtd_info *mtd)
+{
+	struct vt8500_priv *vt8500 = vt8500_mtd_to_priv(mtd);
+
+	vt8500_trigger_command(vt8500, VT8500_COMMAND_HAS_DATA |
+				VT8500_COMMAND_NAND_2_NFC |
+				VT8500_COMMAND_CYCLES_SINGLE, 0);
+
+	if (vt8500_wait_cmd_ready(vt8500))
+		dev_warn(vt8500->device, "Timed out waiting for command completion before reading byte\n");
+
+	vt8500_wait_transfer_ready(vt8500);
+
+	return readb(vt8500->nand.IO_ADDR_R);
+}
+
+static void vt8500_clock_on(int on, struct vt8500_priv *vt8500)
+{
+	unsigned long t;
+	void __iomem *pmc_mem = ioremap(0xd8130000, 0x400);
+	BUG_ON(pmc_mem == NULL);
+
+	dev_dbg(vt8500->device, "Settting clock: %d\n", on);
+	t = readl(pmc_mem + PMCEU_ADDR);
+	if (on)
+		writel(t | 0x0010000, pmc_mem + PMCEU_ADDR);
+	else
+		writel(t & ~0x0010000, pmc_mem + PMCEU_ADDR);
+
+	iounmap(pmc_mem);
+
+}
+
+static void vt8500_start_up(struct vt8500_priv *vt8500)
+{
+	vt8500_clock_on(1, vt8500);
+
+	vt8500_read_resume(vt8500);
+
+	writel(VT8500_INT1_MASK, vt8500->nand.IO_ADDR_R + VT8500_INT1_REG);
+}
+
+static irqreturn_t vt8500_nand_irq(int irq_num, void *_vt8500)
+{
+	struct vt8500_priv *vt8500 = _vt8500;
+
+	int loop_guard = 1 << 20;
+
+	if (vt8500_get_bit(vt8500, VT8500_ECC_BCH_INT_STAT1,
+	    VT8500_ECC_ERROR)) {
+		vt8500_correct_error(vt8500);
+		return IRQ_HANDLED;
+	}
+
+	while (--loop_guard && !vt8500_get_busy2ready(vt8500))
+		cpu_relax();
+
+	BUG_ON(!loop_guard);
+
+	vt8500_clear_busy2ready(vt8500);
+	complete(&vt8500->nand_complete);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t vt8500_dma_irq(int irq_num, void *_priv)
+{
+	struct vt8500_priv *vt8500 = _priv;
+
+	if (readl(vt8500->nand.IO_ADDR_R + NFC_DMA_ISR) & VT8500_NAND_IER_INT_STS) {
+		vt8500->dma_status =
+		    readl(vt8500->nand.IO_ADDR_R +
+			  NFC_DMA_CCR) & VT8500_NAND_CCR_EVTCODE;
+		writel(VT8500_NAND_IER_INT_STS, vt8500->nand.IO_ADDR_R + NFC_DMA_ISR);
+	}
+	complete(&vt8500->dma_complete);
+	return IRQ_HANDLED;
+}
+
+static int vt8500_probe(struct platform_device *dev)
+{
+	struct vt8500_priv *vt8500;
+	struct resource *res;
+	int err;
+	int num_partitions = 0;
+	struct mtd_partition *partitions = NULL;
+	void __iomem *iobase;
+
+	vt8500 = kzalloc(sizeof(struct vt8500_priv), GFP_KERNEL);
+	if (vt8500 == NULL)
+		return -ENOMEM;
+
+	vt8500->device = &dev->dev;
+	dev_set_drvdata(&dev->dev, vt8500);
+
+	res  = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (!request_mem_region(res->start, resource_size(res), dev->name)) {
+		dev_err(vt8500->device,
+			"Failed to request NFC NAND memory region");
+		err = -ENOENT;
+		goto error_1;
+	}
+	vt8500->nfc_mem_region = res;
+
+	iobase = ioremap(res->start, resource_size(res));
+	if (!iobase) {
+		dev_err(vt8500->device, "ioremap failed on nfc regs");
+		err = -ENOMEM;
+		goto error_2;
+	}
+
+	vt8500->dmabuf =
+	    dma_alloc_coherent(&dev->dev, VT8500_DMA_BUFFER_SIZE,
+			       &vt8500->dmaaddr, GFP_KERNEL);
+	if (!vt8500->dmabuf) {
+		dev_err(vt8500->device, "Failed to allocate dma memory");
+		err = -ENOMEM;
+		goto error_3;
+	}
+
+	vt8500->dma_desc =
+	    dma_alloc_coherent(&dev->dev, sizeof(*vt8500->dma_desc),
+			       &vt8500->dma_d_addr, GFP_KERNEL);
+	if (!vt8500->dma_desc) {
+		dev_err(vt8500->device,
+			"Failed to allocate dma memory for dma descriptor");
+		err = -ENOMEM;
+		goto error_4;
+	}
+
+	vt8500->nand_irq = platform_get_irq(dev, 0);
+	if (vt8500->nand_irq == NO_IRQ) {
+		dev_err(vt8500->device, "Failed to retrive nand irq");
+		err = -EINVAL;
+		goto error_5;
+	}
+
+	vt8500->dma_irq = platform_get_irq(dev, 1);
+	if (vt8500->dma_irq == NO_IRQ) {
+		dev_err(vt8500->device, "Failed to retrive nand dma irq");
+		err = -EINVAL;
+		goto error_5;
+	}
+
+	if (request_irq(vt8500->nand_irq, vt8500_nand_irq, 0, "nand", vt8500)) {
+		dev_err(vt8500->device, "Failed to register nand irq handler");
+		err = -EINVAL;
+		goto error_5;
+	}
+
+	if (request_irq(vt8500->dma_irq, vt8500_dma_irq, 0, "nand", vt8500)) {
+		dev_err(vt8500->device, "Failed to register dma irq handler");
+		err = -EINVAL;
+		goto error_6;
+	}
+
+	vt8500->mtd.priv = &vt8500->nand;
+	vt8500->mtd.owner = THIS_MODULE;
+	vt8500->mtd.name = "vt8500_nand";
+
+	vt8500->nand.ecc.layout = &vt8500_oobinfo;
+	vt8500->nand.bbt_td = &vt8500_bbt_descr;
+	vt8500->nand.bbt_md = &vt8500_bbt_mirror_descr;
+	vt8500->nand.ecc.mode = NAND_ECC_HW;
+	vt8500->nand.ecc.size = 512;
+	vt8500->nand.ecc.bytes = 8;
+	vt8500->nand.ecc.steps = 8;
+
+	vt8500->nand.IO_ADDR_R = iobase;
+	vt8500->nand.IO_ADDR_W = iobase + VT8500_COMPORT0;
+	vt8500->nand.cmdfunc = vt8500_nand_cmdfunc;
+	vt8500->nand.dev_ready = vt8500_device_ready;
+	vt8500->nand.read_byte = vt8500_read_byte;
+	vt8500->nand.read_buf = vt8500_read_buf;
+	vt8500->nand.write_buf = vt8500_write_buf;
+	vt8500->nand.select_chip = vt8500_select_chip;
+	vt8500->nand.ecc.read_page = vt8500_read_page;
+	vt8500->nand.ecc.read_page_raw = vt8500_read_page_raw;
+	vt8500->nand.ecc.read_oob = vt8500_read_oob;
+	vt8500->nand.ecc.write_page_raw = vt8500_write_page;
+	vt8500->nand.ecc.write_page = vt8500_write_page;
+	vt8500->nand.ecc.write_oob = vt8500_write_oob;
+	vt8500->nand.chip_delay = 20;
+
+	init_completion(&vt8500->nand_complete);
+	init_completion(&vt8500->dma_complete);
+
+	vt8500_start_up(vt8500);
+
+	vt8500_set_clock(vt8500);
+
+	if (nand_scan(&vt8500->mtd, 1)) {
+		dev_err(vt8500->device, "NAND scan failed");
+		err = -ENXIO;
+		goto error_7;
+	}
+
+	vt8500_init_chip(vt8500);
+
+	err = mtd_device_register(&vt8500->mtd, partitions, num_partitions);
+	if (!err)
+		return 0;
+
+	nand_release(&vt8500->mtd);
+
+error_7:
+	free_irq(vt8500->dma_irq, vt8500);
+error_6:
+	free_irq(vt8500->nand_irq, vt8500);
+error_5:
+	dma_free_coherent(&dev->dev, sizeof(*vt8500->dma_desc),
+			  vt8500->dma_desc, vt8500->dma_d_addr);
+error_4:
+	dma_free_coherent(&dev->dev, VT8500_DMA_BUFFER_SIZE, vt8500->dmabuf,
+			  vt8500->dmaaddr);
+error_3:
+	iounmap(iobase);
+error_2:
+	release_mem_region(res->start, resource_size(res));
+error_1:
+	kfree(vt8500);
+	return err;
+}
+
+static int vt8500_remove(struct platform_device *dev)
+{
+
+	struct vt8500_priv *vt8500 = dev_get_drvdata(&dev->dev);
+	dev_set_drvdata(&dev->dev, NULL);
+
+	nand_release(&vt8500->mtd);
+
+	vt8500_clock_on(0, vt8500);
+
+	iounmap(vt8500->nand.IO_ADDR_R);
+	release_mem_region(vt8500->nfc_mem_region->start,
+			   vt8500->nfc_mem_region->end -
+			   vt8500->nfc_mem_region->start + 1);
+
+	dma_free_coherent(&dev->dev, VT8500_DMA_BUFFER_SIZE, vt8500->dmabuf,
+			  vt8500->dmaaddr);
+	dma_free_coherent(&dev->dev, sizeof(*vt8500->dma_desc),
+			  vt8500->dma_desc, vt8500->dma_d_addr);
+
+	free_irq(vt8500->dma_irq, vt8500);
+	free_irq(vt8500->nand_irq, vt8500);
+
+	kfree(vt8500);
+
+	return 0;
+}
+
+struct platform_driver vt8500_driver = {
+	.probe = vt8500_probe,
+	.remove = __devexit_p(vt8500_remove),
+	.driver = {
+		   .name = "vt8500-nand"}
+};
+
+static int __init vt8500_init(void)
+{
+	return platform_driver_register(&vt8500_driver);
+}
+
+static void __devexit vt8500_exit(void)
+{
+	platform_driver_unregister(&vt8500_driver);
+}
+
+module_init(vt8500_init);
+module_exit(vt8500_exit);
+
+MODULE_DESCRIPTION("WonderMedia VT8500/WM8505 NAND Flash Driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.3-rc2/drivers/net/ethernet/Kconfig wm8505-3.3rc2/drivers/net/ethernet/Kconfig
--- linux-3.3-rc2/drivers/net/ethernet/Kconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/net/ethernet/Kconfig	2012-02-06 12:27:43.000000000 -0700
@@ -142,7 +142,6 @@
 
 source "drivers/net/ethernet/packetengines/Kconfig"
 source "drivers/net/ethernet/pasemi/Kconfig"
-source "drivers/net/ethernet/pmc-sierra/Kconfig"
 source "drivers/net/ethernet/qlogic/Kconfig"
 source "drivers/net/ethernet/racal/Kconfig"
 source "drivers/net/ethernet/realtek/Kconfig"
diff -Naur linux-3.3-rc2/drivers/net/ethernet/Makefile wm8505-3.3rc2/drivers/net/ethernet/Makefile
--- linux-3.3-rc2/drivers/net/ethernet/Makefile	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/net/ethernet/Makefile	2012-02-06 12:27:43.000000000 -0700
@@ -52,7 +52,6 @@
 obj-$(CONFIG_ETHOC) += ethoc.o
 obj-$(CONFIG_NET_PACKET_ENGINE) += packetengines/
 obj-$(CONFIG_NET_VENDOR_PASEMI) += pasemi/
-obj-$(CONFIG_NET_VENDOR_PMC_SIERRA) += pmc-sierra/
 obj-$(CONFIG_NET_VENDOR_QLOGIC) += qlogic/
 obj-$(CONFIG_NET_VENDOR_RACAL) += racal/
 obj-$(CONFIG_NET_VENDOR_REALTEK) += realtek/
diff -Naur linux-3.3-rc2/drivers/net/ethernet/pmc-sierra/Kconfig wm8505-3.3rc2/drivers/net/ethernet/pmc-sierra/Kconfig
--- linux-3.3-rc2/drivers/net/ethernet/pmc-sierra/Kconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/net/ethernet/pmc-sierra/Kconfig	1969-12-31 17:00:00.000000000 -0700
@@ -1,16 +0,0 @@
-config NET_VENDOR_PMC_SIERRA
-        bool "PMC-Sierra devices"
-        default y
-        depends on PMC_YOSEMITE
-
-if NET_VENDOR_PMC_SIERRA
-
-config TITAN_GE
-	bool "PMC-Sierra TITAN Gigabit Ethernet Support"
-	depends on PMC_YOSEMITE
-        default y
-	help
-	  This enables support for the the integrated ethernet of
-	  PMC-Sierra's Titan SoC.
-
-endif # NET_VENDOR_PMC_SIERRA
diff -Naur linux-3.3-rc2/drivers/net/ethernet/pmc-sierra/Makefile wm8505-3.3rc2/drivers/net/ethernet/pmc-sierra/Makefile
--- linux-3.3-rc2/drivers/net/ethernet/pmc-sierra/Makefile	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/net/ethernet/pmc-sierra/Makefile	1969-12-31 17:00:00.000000000 -0700
@@ -1 +0,0 @@
-obj-$(CONFIG_TITAN_GE) += titan_mdio.o titan_ge.o
diff -Naur linux-3.3-rc2/drivers/net/ethernet/pmc-sierra/titan_ge.c wm8505-3.3rc2/drivers/net/ethernet/pmc-sierra/titan_ge.c
--- linux-3.3-rc2/drivers/net/ethernet/pmc-sierra/titan_ge.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/net/ethernet/pmc-sierra/titan_ge.c	1969-12-31 17:00:00.000000000 -0700
@@ -1,2069 +0,0 @@
-/*
- * drivers/net/titan_ge.c - Driver for Titan ethernet ports
- *
- * Copyright (C) 2003 PMC-Sierra Inc.
- * Author : Manish Lachwani (lachwani@pmc-sierra.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-/*
- * The MAC unit of the Titan consists of the following:
- *
- * -> XDMA Engine to move data to from the memory to the MAC packet FIFO
- * -> FIFO is where the incoming and outgoing data is placed
- * -> TRTG is the unit that pulls the data from the FIFO for Tx and pushes
- *    the data into the FIFO for Rx
- * -> TMAC is the outgoing MAC interface and RMAC is the incoming.
- * -> AFX is the address filtering block
- * -> GMII block to communicate with the PHY
- *
- * Rx will look like the following:
- * GMII --> RMAC --> AFX --> TRTG --> Rx FIFO --> XDMA --> CPU memory
- *
- * Tx will look like the following:
- * CPU memory --> XDMA --> Tx FIFO --> TRTG --> TMAC --> GMII
- *
- * The Titan driver has support for the following performance features:
- * -> Rx side checksumming
- * -> Jumbo Frames
- * -> Interrupt Coalscing
- * -> Rx NAPI
- * -> SKB Recycling
- * -> Transmit/Receive descriptors in SRAM
- * -> Fast routing for IP forwarding
- */
-
-#include <linux/dma-mapping.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/ioport.h>
-#include <linux/interrupt.h>
-#include <linux/slab.h>
-#include <linux/string.h>
-#include <linux/errno.h>
-#include <linux/ip.h>
-#include <linux/init.h>
-#include <linux/in.h>
-#include <linux/platform_device.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/mii.h>
-#include <linux/delay.h>
-#include <linux/skbuff.h>
-#include <linux/prefetch.h>
-
-/* For MII specifc registers, titan_mdio.h should be included */
-#include <net/ip.h>
-
-#include <asm/bitops.h>
-#include <asm/io.h>
-#include <asm/types.h>
-#include <asm/pgtable.h>
-#include <asm/system.h>
-#include <asm/titan_dep.h>
-
-#include "titan_ge.h"
-#include "titan_mdio.h"
-
-/* Static Function Declarations	 */
-static int titan_ge_eth_open(struct net_device *);
-static void titan_ge_eth_stop(struct net_device *);
-static struct net_device_stats *titan_ge_get_stats(struct net_device *);
-static int titan_ge_init_rx_desc_ring(titan_ge_port_info *, int, int,
-				      unsigned long, unsigned long,
-				      unsigned long);
-static int titan_ge_init_tx_desc_ring(titan_ge_port_info *, int,
-				      unsigned long, unsigned long);
-
-static int titan_ge_open(struct net_device *);
-static int titan_ge_start_xmit(struct sk_buff *, struct net_device *);
-static int titan_ge_stop(struct net_device *);
-
-static unsigned long titan_ge_tx_coal(unsigned long, int);
-
-static void titan_ge_port_reset(unsigned int);
-static int titan_ge_free_tx_queue(titan_ge_port_info *);
-static int titan_ge_rx_task(struct net_device *, titan_ge_port_info *);
-static int titan_ge_port_start(struct net_device *, titan_ge_port_info *);
-
-static int titan_ge_return_tx_desc(titan_ge_port_info *, int);
-
-/*
- * Some configuration for the FIFO and the XDMA channel needs
- * to be done only once for all the ports. This flag controls
- * that
- */
-static unsigned long config_done;
-
-/*
- * One time out of memory flag
- */
-static unsigned int oom_flag;
-
-static int titan_ge_poll(struct net_device *netdev, int *budget);
-
-static int titan_ge_receive_queue(struct net_device *, unsigned int);
-
-static struct platform_device *titan_ge_device[3];
-
-/* MAC Address */
-extern unsigned char titan_ge_mac_addr_base[6];
-
-unsigned long titan_ge_base;
-static unsigned long titan_ge_sram;
-
-static char titan_string[] = "titan";
-
-/*
- * The Titan GE has two alignment requirements:
- * -> skb->data to be cacheline aligned (32 byte)
- * -> IP header alignment to 16 bytes
- *
- * The latter is not implemented. So, that results in an extra copy on
- * the Rx. This is a big performance hog. For the former case, the
- * dev_alloc_skb() has been replaced with titan_ge_alloc_skb(). The size
- * requested is calculated:
- *
- * Ethernet Frame Size : 1518
- * Ethernet Header     : 14
- * Future Titan change for IP header alignment : 2
- *
- * Hence, we allocate (1518 + 14 + 2+ 64) = 1580 bytes.  For IP header
- * alignment, we use skb_reserve().
- */
-
-#define ALIGNED_RX_SKB_ADDR(addr) \
-	((((unsigned long)(addr) + (64UL - 1UL)) \
-	& ~(64UL - 1UL)) - (unsigned long)(addr))
-
-#define titan_ge_alloc_skb(__length, __gfp_flags) \
-({      struct sk_buff *__skb; \
-	__skb = alloc_skb((__length) + 64, (__gfp_flags)); \
-	if(__skb) { \
-		int __offset = (int) ALIGNED_RX_SKB_ADDR(__skb->data); \
-		if(__offset) \
-			skb_reserve(__skb, __offset); \
-	} \
-	__skb; \
-})
-
-/*
- * Configure the GMII block of the Titan based on what the PHY tells us
- */
-static void titan_ge_gmii_config(int port_num)
-{
-	unsigned int reg_data = 0, phy_reg;
-	int err;
-
-	err = titan_ge_mdio_read(port_num, TITAN_GE_MDIO_PHY_STATUS, &phy_reg);
-
-	if (err == TITAN_GE_MDIO_ERROR) {
-		printk(KERN_ERR
-		       "Could not read PHY control register 0x11 \n");
-		printk(KERN_ERR
-			"Setting speed to 1000 Mbps and Duplex to Full \n");
-
-		return;
-	}
-
-	err = titan_ge_mdio_write(port_num, TITAN_GE_MDIO_PHY_IE, 0);
-
-	if (phy_reg & 0x8000) {
-		if (phy_reg & 0x2000) {
-			/* Full Duplex and 1000 Mbps */
-			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
-					(port_num << 12)), 0x201);
-		}  else {
-			/* Half Duplex and 1000 Mbps */
-			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
-					(port_num << 12)), 0x2201);
-			}
-	}
-	if (phy_reg & 0x4000) {
-		if (phy_reg & 0x2000) {
-			/* Full Duplex and 100 Mbps */
-			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
-					(port_num << 12)), 0x100);
-		} else {
-			/* Half Duplex and 100 Mbps */
-			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
-					(port_num << 12)), 0x2100);
-		}
-	}
-	reg_data = TITAN_GE_READ(TITAN_GE_GMII_CONFIG_GENERAL +
-				(port_num << 12));
-	reg_data |= 0x3;
-	TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_GENERAL +
-			(port_num << 12)), reg_data);
-}
-
-/*
- * Enable the TMAC if it is not
- */
-static void titan_ge_enable_tx(unsigned int port_num)
-{
-	unsigned long reg_data;
-
-	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 + (port_num << 12));
-	if (!(reg_data & 0x8000)) {
-		printk("TMAC disabled for port %d!! \n", port_num);
-
-		reg_data |= 0x0001;	/* Enable TMAC */
-		reg_data |= 0x4000;	/* CRC Check Enable */
-		reg_data |= 0x2000;	/* Padding enable */
-		reg_data |= 0x0800;	/* CRC Add enable */
-		reg_data |= 0x0080;	/* PAUSE frame */
-
-		TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
-				(port_num << 12)), reg_data);
-	}
-}
-
-/*
- * Tx Timeout function
- */
-static void titan_ge_tx_timeout(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-
-	printk(KERN_INFO "%s: TX timeout  ", netdev->name);
-	printk(KERN_INFO "Resetting card \n");
-
-	/* Do the reset outside of interrupt context */
-	schedule_work(&titan_ge_eth->tx_timeout_task);
-}
-
-/*
- * Update the AFX tables for UC and MC for slice 0 only
- */
-static void titan_ge_update_afx(titan_ge_port_info * titan_ge_eth)
-{
-	int port = titan_ge_eth->port_num;
-	unsigned int i;
-	volatile unsigned long reg_data = 0;
-	u8 p_addr[6];
-
-	memcpy(p_addr, titan_ge_eth->port_mac_addr, 6);
-
-	/* Set the MAC address here for TMAC and RMAC */
-	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_HI + (port << 12)),
-		       ((p_addr[5] << 8) | p_addr[4]));
-	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_MID + (port << 12)),
-		       ((p_addr[3] << 8) | p_addr[2]));
-	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_LOW + (port << 12)),
-		       ((p_addr[1] << 8) | p_addr[0]));
-
-	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_HI + (port << 12)),
-		       ((p_addr[5] << 8) | p_addr[4]));
-	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_MID + (port << 12)),
-		       ((p_addr[3] << 8) | p_addr[2]));
-	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_LOW + (port << 12)),
-		       ((p_addr[1] << 8) | p_addr[0]));
-
-	TITAN_GE_WRITE((0x112c | (port << 12)), 0x1);
-	/* Configure the eight address filters */
-	for (i = 0; i < 8; i++) {
-		/* Select each of the eight filters */
-		TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_2 +
-				(port << 12)), i);
-
-		/* Configure the match */
-		reg_data = 0x9;	/* Forward Enable Bit */
-		TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_0 +
-				(port << 12)), reg_data);
-
-		/* Finally, AFX Exact Match Address Registers */
-		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_LOW + (port << 12)),
-			       ((p_addr[1] << 8) | p_addr[0]));
-		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_MID + (port << 12)),
-			       ((p_addr[3] << 8) | p_addr[2]));
-		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_HIGH + (port << 12)),
-			       ((p_addr[5] << 8) | p_addr[4]));
-
-		/* VLAN id set to 0 */
-		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_VID +
-				(port << 12)), 0);
-	}
-}
-
-/*
- * Actual Routine to reset the adapter when the timeout occurred
- */
-static void titan_ge_tx_timeout_task(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	int port = titan_ge_eth->port_num;
-
-	printk("Titan GE: Transmit timed out. Resetting ... \n");
-
-	/* Dump debug info */
-	printk(KERN_ERR "TRTG cause : %x \n",
-			TITAN_GE_READ(0x100c + (port << 12)));
-
-	/* Fix this for the other ports */
-	printk(KERN_ERR "FIFO cause : %x \n", TITAN_GE_READ(0x482c));
-	printk(KERN_ERR "IE cause : %x \n", TITAN_GE_READ(0x0040));
-	printk(KERN_ERR "XDMA GDI ERROR : %x \n",
-			TITAN_GE_READ(0x5008 + (port << 8)));
-	printk(KERN_ERR "CHANNEL ERROR: %x \n",
-			TITAN_GE_READ(TITAN_GE_CHANNEL0_INTERRUPT
-						+ (port << 8)));
-
-	netif_device_detach(netdev);
-	titan_ge_port_reset(titan_ge_eth->port_num);
-	titan_ge_port_start(netdev, titan_ge_eth);
-	netif_device_attach(netdev);
-}
-
-/*
- * Change the MTU of the Ethernet Device
- */
-static int titan_ge_change_mtu(struct net_device *netdev, int new_mtu)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned long flags;
-
-	if ((new_mtu > 9500) || (new_mtu < 64))
-		return -EINVAL;
-
-	spin_lock_irqsave(&titan_ge_eth->lock, flags);
-
-	netdev->mtu = new_mtu;
-
-	/* Now we have to reopen the interface so that SKBs with the new
-	 * size will be allocated */
-
-	if (netif_running(netdev)) {
-		titan_ge_eth_stop(netdev);
-
-		if (titan_ge_eth_open(netdev) != TITAN_OK) {
-			printk(KERN_ERR
-			       "%s: Fatal error on opening device\n",
-			       netdev->name);
-			spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-			return -1;
-		}
-	}
-
-	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-	return 0;
-}
-
-/*
- * Titan Gbe Interrupt Handler. All the three ports send interrupt to one line
- * only. Once an interrupt is triggered, figure out the port and then check
- * the channel.
- */
-static irqreturn_t titan_ge_int_handler(int irq, void *dev_id)
-{
-	struct net_device *netdev = (struct net_device *) dev_id;
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	unsigned int reg_data;
-	unsigned int eth_int_cause_error = 0, is;
-	unsigned long eth_int_cause1;
-	int err = 0;
-#ifdef CONFIG_SMP
-	unsigned long eth_int_cause2;
-#endif
-
-	/* Ack the CPU interrupt */
-	switch (port_num) {
-	case 0:
-		is = OCD_READ(RM9000x2_OCD_INTP0STATUS1);
-		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR1, is);
-
-#ifdef CONFIG_SMP
-		is = OCD_READ(RM9000x2_OCD_INTP1STATUS1);
-		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR1, is);
-#endif
-		break;
-
-	case 1:
-		is = OCD_READ(RM9000x2_OCD_INTP0STATUS0);
-		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR0, is);
-
-#ifdef CONFIG_SMP
-		is = OCD_READ(RM9000x2_OCD_INTP1STATUS0);
-		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR0, is);
-#endif
-		break;
-
-	case 2:
-		is = OCD_READ(RM9000x2_OCD_INTP0STATUS4);
-		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR4, is);
-
-#ifdef CONFIG_SMP
-		is = OCD_READ(RM9000x2_OCD_INTP1STATUS4);
-		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR4, is);
-#endif
-	}
-
-	eth_int_cause1 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_A);
-#ifdef CONFIG_SMP
-	eth_int_cause2 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_B);
-#endif
-
-	/* Spurious interrupt */
-#ifdef CONFIG_SMP
-	if ( (eth_int_cause1 == 0) && (eth_int_cause2 == 0)) {
-#else
-	if (eth_int_cause1 == 0) {
-#endif
-		eth_int_cause_error = TITAN_GE_READ(TITAN_GE_CHANNEL0_INTERRUPT +
-					(port_num << 8));
-
-		if (eth_int_cause_error == 0)
-			return IRQ_NONE;
-	}
-
-	/* Handle Tx first. No need to ack interrupts */
-#ifdef CONFIG_SMP
-	if ( (eth_int_cause1 & 0x20202) ||
-		(eth_int_cause2 & 0x20202) )
-#else
-	if (eth_int_cause1 & 0x20202)
-#endif
-		titan_ge_free_tx_queue(titan_ge_eth);
-
-	/* Handle the Rx next */
-#ifdef CONFIG_SMP
-	if ( (eth_int_cause1 & 0x10101) ||
-		(eth_int_cause2 & 0x10101)) {
-#else
-	if (eth_int_cause1 & 0x10101) {
-#endif
-		if (netif_rx_schedule_prep(netdev)) {
-			unsigned int ack;
-
-			ack = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
-			/* Disable Tx and Rx both */
-			if (port_num == 0)
-				ack &= ~(0x3);
-			if (port_num == 1)
-				ack &= ~(0x300);
-
-			if (port_num == 2)
-				ack &= ~(0x30000);
-
-			/* Interrupts have been disabled */
-			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, ack);
-
-			__netif_rx_schedule(netdev);
-		}
-	}
-
-	/* Handle error interrupts */
-	if (eth_int_cause_error && (eth_int_cause_error != 0x2)) {
-		printk(KERN_ERR
-			"XDMA Channel Error : %x  on port %d\n",
-			eth_int_cause_error, port_num);
-
-		printk(KERN_ERR
-			"XDMA GDI Hardware error : %x  on port %d\n",
-			TITAN_GE_READ(0x5008 + (port_num << 8)), port_num);
-
-		printk(KERN_ERR
-			"XDMA currently has %d Rx descriptors \n",
-			TITAN_GE_READ(0x5048 + (port_num << 8)));
-
-		printk(KERN_ERR
-			"XDMA currently has prefetcted %d Rx descriptors \n",
-			TITAN_GE_READ(0x505c + (port_num << 8)));
-
-		TITAN_GE_WRITE((TITAN_GE_CHANNEL0_INTERRUPT +
-			       (port_num << 8)), eth_int_cause_error);
-	}
-
-	/*
-	 * PHY interrupt to inform abt the changes. Reading the
-	 * PHY Status register will clear the interrupt
-	 */
-	if ((!(eth_int_cause1 & 0x30303)) &&
-		(eth_int_cause_error == 0)) {
-		err =
-		    titan_ge_mdio_read(port_num,
-			       TITAN_GE_MDIO_PHY_IS, &reg_data);
-
-		if (reg_data & 0x0400) {
-			/* Link status change */
-			titan_ge_mdio_read(port_num,
-				   TITAN_GE_MDIO_PHY_STATUS, &reg_data);
-			if (!(reg_data & 0x0400)) {
-				/* Link is down */
-				netif_carrier_off(netdev);
-				netif_stop_queue(netdev);
-			} else {
-				/* Link is up */
-				netif_carrier_on(netdev);
-				netif_wake_queue(netdev);
-
-				/* Enable the queue */
-				titan_ge_enable_tx(port_num);
-			}
-		}
-	}
-
-	return IRQ_HANDLED;
-}
-
-/*
- * Multicast and Promiscuous mode set. The
- * set_multi entry point is called whenever the
- * multicast address list or the network interface
- * flags are updated.
- */
-static void titan_ge_set_multi(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	unsigned long reg_data;
-
-	reg_data = TITAN_GE_READ(TITAN_GE_AFX_ADDRS_FILTER_CTRL_1 +
-				(port_num << 12));
-
-	if (netdev->flags & IFF_PROMISC) {
-		reg_data |= 0x2;
-	}
-	else if (netdev->flags & IFF_ALLMULTI) {
-		reg_data |= 0x01;
-		reg_data |= 0x400; /* Use the 64-bit Multicast Hash bin */
-	}
-	else {
-		reg_data = 0x2;
-	}
-
-	TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_1 +
-			(port_num << 12)), reg_data);
-	if (reg_data & 0x01) {
-		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_LOW +
-				(port_num << 12)), 0xffff);
-		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_MIDLOW +
-				(port_num << 12)), 0xffff);
-		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_MIDHI +
-				(port_num << 12)), 0xffff);
-		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_HI +
-				(port_num << 12)), 0xffff);
-	}
-}
-
-/*
- * Open the network device
- */
-static int titan_ge_open(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	unsigned int irq = TITAN_ETH_PORT_IRQ - port_num;
-	int retval;
-
-	retval = request_irq(irq, titan_ge_int_handler,
-		     SA_INTERRUPT | SA_SAMPLE_RANDOM , netdev->name, netdev);
-
-	if (retval != 0) {
-		printk(KERN_ERR "Cannot assign IRQ number to TITAN GE \n");
-		return -1;
-	}
-
-	netdev->irq = irq;
-	printk(KERN_INFO "Assigned IRQ %d to port %d\n", irq, port_num);
-
-	spin_lock_irq(&(titan_ge_eth->lock));
-
-	if (titan_ge_eth_open(netdev) != TITAN_OK) {
-		spin_unlock_irq(&(titan_ge_eth->lock));
-		printk("%s: Error opening interface \n", netdev->name);
-		free_irq(netdev->irq, netdev);
-		return -EBUSY;
-	}
-
-	spin_unlock_irq(&(titan_ge_eth->lock));
-
-	return 0;
-}
-
-/*
- * Allocate the SKBs for the Rx ring. Also used
- * for refilling the queue
- */
-static int titan_ge_rx_task(struct net_device *netdev,
-				titan_ge_port_info *titan_ge_port)
-{
-	struct device *device = &titan_ge_device[titan_ge_port->port_num]->dev;
-	volatile titan_ge_rx_desc *rx_desc;
-	struct sk_buff *skb;
-	int rx_used_desc;
-	int count = 0;
-
-	while (titan_ge_port->rx_ring_skbs < titan_ge_port->rx_ring_size) {
-
-	/* First try to get the skb from the recycler */
-#ifdef TITAN_GE_JUMBO_FRAMES
-		skb = titan_ge_alloc_skb(TITAN_GE_JUMBO_BUFSIZE, GFP_ATOMIC);
-#else
-		skb = titan_ge_alloc_skb(TITAN_GE_STD_BUFSIZE, GFP_ATOMIC);
-#endif
-		if (unlikely(!skb)) {
-			/* OOM, set the flag */
-			printk("OOM \n");
-			oom_flag = 1;
-			break;
-		}
-		count++;
-		skb->dev = netdev;
-
-		titan_ge_port->rx_ring_skbs++;
-
-		rx_used_desc = titan_ge_port->rx_used_desc_q;
-		rx_desc = &(titan_ge_port->rx_desc_area[rx_used_desc]);
-
-#ifdef TITAN_GE_JUMBO_FRAMES
-		rx_desc->buffer_addr = dma_map_single(device, skb->data,
-				TITAN_GE_JUMBO_BUFSIZE - 2, DMA_FROM_DEVICE);
-#else
-		rx_desc->buffer_addr = dma_map_single(device, skb->data,
-				TITAN_GE_STD_BUFSIZE - 2, DMA_FROM_DEVICE);
-#endif
-
-		titan_ge_port->rx_skb[rx_used_desc] = skb;
-		rx_desc->cmd_sts = TITAN_GE_RX_BUFFER_OWNED;
-
-		titan_ge_port->rx_used_desc_q =
-			(rx_used_desc + 1) % TITAN_GE_RX_QUEUE;
-	}
-
-	return count;
-}
-
-/*
- * Actual init of the Tital GE port. There is one register for
- * the channel configuration
- */
-static void titan_port_init(struct net_device *netdev,
-			    titan_ge_port_info * titan_ge_eth)
-{
-	unsigned long reg_data;
-
-	titan_ge_port_reset(titan_ge_eth->port_num);
-
-	/* First reset the TMAC */
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
-	reg_data |= 0x80000000;
-	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
-
-	udelay(30);
-
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
-	reg_data &= ~(0xc0000000);
-	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
-
-	/* Now reset the RMAC */
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
-	reg_data |= 0x00080000;
-	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
-
-	udelay(30);
-
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
-	reg_data &= ~(0x000c0000);
-	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
-}
-
-/*
- * Start the port. All the hardware specific configuration
- * for the XDMA, Tx FIFO, Rx FIFO, TMAC, RMAC, TRTG and AFX
- * go here
- */
-static int titan_ge_port_start(struct net_device *netdev,
-				titan_ge_port_info * titan_port)
-{
-	volatile unsigned long reg_data, reg_data1;
-	int port_num = titan_port->port_num;
-	int count = 0;
-	unsigned long reg_data_1;
-
-	if (config_done == 0) {
-		reg_data = TITAN_GE_READ(0x0004);
-		reg_data |= 0x100;
-		TITAN_GE_WRITE(0x0004, reg_data);
-
-		reg_data &= ~(0x100);
-		TITAN_GE_WRITE(0x0004, reg_data);
-
-		/* Turn on GMII/MII mode and turn off TBI mode */
-		reg_data = TITAN_GE_READ(TITAN_GE_TSB_CTRL_1);
-		reg_data |= 0x00000700;
-		reg_data &= ~(0x00800000); /* Fencing */
-
-		TITAN_GE_WRITE(0x000c, 0x00001100);
-
-		TITAN_GE_WRITE(TITAN_GE_TSB_CTRL_1, reg_data);
-
-		/* Set the CPU Resource Limit register */
-		TITAN_GE_WRITE(0x00f8, 0x8);
-
-		/* Be conservative when using the BIU buffers */
-		TITAN_GE_WRITE(0x0068, 0x4);
-	}
-
-	titan_port->tx_threshold = 0;
-	titan_port->rx_threshold = 0;
-
-	/* We need to write the descriptors for Tx and Rx */
-	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_TX_DESC + (port_num << 8)),
-		       (unsigned long) titan_port->tx_dma);
-	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_RX_DESC + (port_num << 8)),
-		       (unsigned long) titan_port->rx_dma);
-
-	if (config_done == 0) {
-		/* Step 1:  XDMA config	*/
-		reg_data = TITAN_GE_READ(TITAN_GE_XDMA_CONFIG);
-		reg_data &= ~(0x80000000);      /* clear reset */
-		reg_data |= 0x1 << 29;	/* sparse tx descriptor spacing */
-		reg_data |= 0x1 << 28;	/* sparse rx descriptor spacing */
-		reg_data |= (0x1 << 23) | (0x1 << 24);  /* Descriptor Coherency */
-		reg_data |= (0x1 << 21) | (0x1 << 22);  /* Data Coherency */
-		TITAN_GE_WRITE(TITAN_GE_XDMA_CONFIG, reg_data);
-	}
-
-	/* IR register for the XDMA */
-	reg_data = TITAN_GE_READ(TITAN_GE_GDI_INTERRUPT_ENABLE + (port_num << 8));
-	reg_data |= 0x80068000; /* No Rx_OOD */
-	TITAN_GE_WRITE((TITAN_GE_GDI_INTERRUPT_ENABLE + (port_num << 8)), reg_data);
-
-	/* Start the Tx and Rx XDMA controller */
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG + (port_num << 8));
-	reg_data &= 0x4fffffff;     /* Clear tx reset */
-	reg_data &= 0xfff4ffff;     /* Clear rx reset */
-
-#ifdef TITAN_GE_JUMBO_FRAMES
-	reg_data |= 0xa0 | 0x30030000;
-#else
-	reg_data |= 0x40 | 0x20030000;
-#endif
-
-#ifndef CONFIG_SMP
-	reg_data &= ~(0x10);
-	reg_data |= 0x0f; /* All of the packet */
-#endif
-
-	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG + (port_num << 8)), reg_data);
-
-	/* Rx desc count */
-	count = titan_ge_rx_task(netdev, titan_port);
-	TITAN_GE_WRITE((0x5048 + (port_num << 8)), count);
-	count = TITAN_GE_READ(0x5048 + (port_num << 8));
-
-	udelay(30);
-
-	/*
-	 * Step 2:  Configure the SDQPF, i.e. FIFO
-	 */
-	if (config_done == 0) {
-		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_CTL);
-		reg_data = 0x1;
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
-		reg_data &= ~(0x1);
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
-		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_CTL);
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
-
-		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_CTL);
-		reg_data = 0x1;
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
-		reg_data &= ~(0x1);
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
-		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_CTL);
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
-	}
-	/*
-	 * Enable RX FIFO 0, 4 and 8
-	 */
-	if (port_num == 0) {
-		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_0);
-
-		reg_data |= 0x100000;
-		reg_data |= (0xff << 10);
-
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_0, reg_data);
-		/*
-		 * BAV2,BAV and DAV settings for the Rx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x4844);
-		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
-		TITAN_GE_WRITE(0x4844, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_0, reg_data);
-
-		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_0);
-		reg_data |= 0x100000;
-
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
-
-		reg_data |= (0xff << 10);
-
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
-
-		/*
-		 * BAV2, BAV and DAV settings for the Tx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x4944);
-		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
-
-		TITAN_GE_WRITE(0x4944, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
-
-	}
-
-	if (port_num == 1) {
-		reg_data = TITAN_GE_READ(0x4870);
-
-		reg_data |= 0x100000;
-		reg_data |= (0xff << 10) | (0xff + 1);
-
-		TITAN_GE_WRITE(0x4870, reg_data);
-		/*
-		 * BAV2,BAV and DAV settings for the Rx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x4874);
-		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
-		TITAN_GE_WRITE(0x4874, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(0x4870, reg_data);
-
-		reg_data = TITAN_GE_READ(0x494c);
-		reg_data |= 0x100000;
-
-		TITAN_GE_WRITE(0x494c, reg_data);
-		reg_data |= (0xff << 10) | (0xff + 1);
-		TITAN_GE_WRITE(0x494c, reg_data);
-
-		/*
-		 * BAV2, BAV and DAV settings for the Tx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x4950);
-		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
-
-		TITAN_GE_WRITE(0x4950, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(0x494c, reg_data);
-	}
-
-	/*
-	 * Titan 1.2 revision does support port #2
-	 */
-	if (port_num == 2) {
-		/*
-		 * Put the descriptors in the SRAM
-		 */
-		reg_data = TITAN_GE_READ(0x48a0);
-
-		reg_data |= 0x100000;
-		reg_data |= (0xff << 10) | (2*(0xff + 1));
-
-		TITAN_GE_WRITE(0x48a0, reg_data);
-		/*
-		 * BAV2,BAV and DAV settings for the Rx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x48a4);
-		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
-		TITAN_GE_WRITE(0x48a4, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(0x48a0, reg_data);
-
-		reg_data = TITAN_GE_READ(0x4958);
-		reg_data |= 0x100000;
-
-		TITAN_GE_WRITE(0x4958, reg_data);
-		reg_data |= (0xff << 10) | (2*(0xff + 1));
-		TITAN_GE_WRITE(0x4958, reg_data);
-
-		/*
-		 * BAV2, BAV and DAV settings for the Tx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x495c);
-		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
-
-		TITAN_GE_WRITE(0x495c, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(0x4958, reg_data);
-	}
-
-	if (port_num == 2) {
-		reg_data = TITAN_GE_READ(0x48a0);
-
-		reg_data |= 0x100000;
-		reg_data |= (0xff << 10) | (2*(0xff + 1));
-
-		TITAN_GE_WRITE(0x48a0, reg_data);
-		/*
-		 * BAV2,BAV and DAV settings for the Rx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x48a4);
-		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
-		TITAN_GE_WRITE(0x48a4, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(0x48a0, reg_data);
-
-		reg_data = TITAN_GE_READ(0x4958);
-		reg_data |= 0x100000;
-
-		TITAN_GE_WRITE(0x4958, reg_data);
-		reg_data |= (0xff << 10) | (2*(0xff + 1));
-		TITAN_GE_WRITE(0x4958, reg_data);
-
-		/*
-		 * BAV2, BAV and DAV settings for the Tx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x495c);
-		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
-
-		TITAN_GE_WRITE(0x495c, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(0x4958, reg_data);
-	}
-
-	/*
-	 * Step 3:  TRTG block enable
-	 */
-	reg_data = TITAN_GE_READ(TITAN_GE_TRTG_CONFIG + (port_num << 12));
-
-	/*
-	 * This is the 1.2 revision of the chip. It has fix for the
-	 * IP header alignment. Now, the IP header begins at an
-	 * aligned address and this wont need an extra copy in the
-	 * driver. This performance drawback existed in the previous
-	 * versions of the silicon
-	 */
-	reg_data_1 = TITAN_GE_READ(0x103c + (port_num << 12));
-	reg_data_1 |= 0x40000000;
-	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
-
-	reg_data_1 |= 0x04000000;
-	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
-
-	mdelay(5);
-
-	reg_data_1 &= ~(0x04000000);
-	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
-
-	mdelay(5);
-
-	reg_data |= 0x0001;
-	TITAN_GE_WRITE((TITAN_GE_TRTG_CONFIG + (port_num << 12)), reg_data);
-
-	/*
-	 * Step 4:  Start the Tx activity
-	 */
-	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_2 + (port_num << 12)), 0xe197);
-#ifdef TITAN_GE_JUMBO_FRAMES
-	TITAN_GE_WRITE((0x1258 + (port_num << 12)), 0x4000);
-#endif
-	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 + (port_num << 12));
-	reg_data |= 0x0001;	/* Enable TMAC */
-	reg_data |= 0x6c70;	/* PAUSE also set */
-
-	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 + (port_num << 12)), reg_data);
-
-	udelay(30);
-
-	/* Destination Address drop bit */
-	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_2 + (port_num << 12));
-	reg_data |= 0x218;        /* DA_DROP bit and pause */
-	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_2 + (port_num << 12)), reg_data);
-
-	TITAN_GE_WRITE((0x1218 + (port_num << 12)), 0x3);
-
-#ifdef TITAN_GE_JUMBO_FRAMES
-	TITAN_GE_WRITE((0x1208 + (port_num << 12)), 0x4000);
-#endif
-	/* Start the Rx activity */
-	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 + (port_num << 12));
-	reg_data |= 0x0001;	/* RMAC Enable */
-	reg_data |= 0x0010;	/* CRC Check enable */
-	reg_data |= 0x0040;	/* Min Frame check enable */
-	reg_data |= 0x4400;	/* Max Frame check enable */
-
-	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 + (port_num << 12)), reg_data);
-
-	udelay(30);
-
-	/*
-	 * Enable the Interrupts for Tx and Rx
-	 */
-	reg_data1 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
-
-	if (port_num == 0) {
-		reg_data1 |= 0x3;
-#ifdef CONFIG_SMP
-		TITAN_GE_WRITE(0x0038, 0x003);
-#else
-		TITAN_GE_WRITE(0x0038, 0x303);
-#endif
-	}
-
-	if (port_num == 1) {
-		reg_data1 |= 0x300;
-	}
-
-	if (port_num == 2)
-		reg_data1 |= 0x30000;
-
-	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, reg_data1);
-	TITAN_GE_WRITE(0x003c, 0x300);
-
-	if (config_done == 0) {
-		TITAN_GE_WRITE(0x0024, 0x04000024);	/* IRQ vector */
-		TITAN_GE_WRITE(0x0020, 0x000fb000);	/* INTMSG base */
-	}
-
-	/* Priority */
-	reg_data = TITAN_GE_READ(0x1038 + (port_num << 12));
-	reg_data &= ~(0x00f00000);
-	TITAN_GE_WRITE((0x1038 + (port_num << 12)), reg_data);
-
-	/* Step 5:  GMII config */
-	titan_ge_gmii_config(port_num);
-
-	if (config_done == 0) {
-		TITAN_GE_WRITE(0x1a80, 0);
-		config_done = 1;
-	}
-
-	return TITAN_OK;
-}
-
-/*
- * Function to queue the packet for the Ethernet device
- */
-static void titan_ge_tx_queue(titan_ge_port_info * titan_ge_eth,
-				struct sk_buff * skb)
-{
-	struct device *device = &titan_ge_device[titan_ge_eth->port_num]->dev;
-	unsigned int curr_desc = titan_ge_eth->tx_curr_desc_q;
-	volatile titan_ge_tx_desc *tx_curr;
-	int port_num = titan_ge_eth->port_num;
-
-	tx_curr = &(titan_ge_eth->tx_desc_area[curr_desc]);
-	tx_curr->buffer_addr =
-		dma_map_single(device, skb->data, skb_headlen(skb),
-			       DMA_TO_DEVICE);
-
-	titan_ge_eth->tx_skb[curr_desc] = (struct sk_buff *) skb;
-	tx_curr->buffer_len = skb_headlen(skb);
-
-	/* Last descriptor enables interrupt and changes ownership */
-	tx_curr->cmd_sts = 0x1 | (1 << 15) | (1 << 5);
-
-	/* Kick the XDMA to start the transfer from memory to the FIFO */
-	TITAN_GE_WRITE((0x5044 + (port_num << 8)), 0x1);
-
-	/* Current descriptor updated */
-	titan_ge_eth->tx_curr_desc_q = (curr_desc + 1) % TITAN_GE_TX_QUEUE;
-
-	/* Prefetch the next descriptor */
-	prefetch((const void *)
-		 &titan_ge_eth->tx_desc_area[titan_ge_eth->tx_curr_desc_q]);
-}
-
-/*
- * Actually does the open of the Ethernet device
- */
-static int titan_ge_eth_open(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	struct device *device = &titan_ge_device[port_num]->dev;
-	unsigned long reg_data;
-	unsigned int phy_reg;
-	int err = 0;
-
-	/* Stop the Rx activity */
-	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 + (port_num << 12));
-	reg_data &= ~(0x00000001);
-	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 + (port_num << 12)), reg_data);
-
-	/* Clear the port interrupts */
-	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_INTERRUPT + (port_num << 8)), 0x0);
-
-	if (config_done == 0) {
-		TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0);
-		TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_B, 0);
-	}
-
-	/* Set the MAC Address */
-	memcpy(titan_ge_eth->port_mac_addr, netdev->dev_addr, 6);
-
-	if (config_done == 0)
-		titan_port_init(netdev, titan_ge_eth);
-
-	titan_ge_update_afx(titan_ge_eth);
-
-	/* Allocate the Tx ring now */
-	titan_ge_eth->tx_ring_skbs = 0;
-	titan_ge_eth->tx_ring_size = TITAN_GE_TX_QUEUE;
-
-	/* Allocate space in the SRAM for the descriptors */
-	titan_ge_eth->tx_desc_area = (titan_ge_tx_desc *)
-		(titan_ge_sram + TITAN_TX_RING_BYTES * port_num);
-	titan_ge_eth->tx_dma = TITAN_SRAM_BASE + TITAN_TX_RING_BYTES * port_num;
-
-	if (!titan_ge_eth->tx_desc_area) {
-		printk(KERN_ERR
-		       "%s: Cannot allocate Tx Ring (size %d bytes) for port %d\n",
-		       netdev->name, TITAN_TX_RING_BYTES, port_num);
-		return -ENOMEM;
-	}
-
-	memset(titan_ge_eth->tx_desc_area, 0, titan_ge_eth->tx_desc_area_size);
-
-	/* Now initialize the Tx descriptor ring */
-	titan_ge_init_tx_desc_ring(titan_ge_eth,
-				   titan_ge_eth->tx_ring_size,
-				   (unsigned long) titan_ge_eth->tx_desc_area,
-				   (unsigned long) titan_ge_eth->tx_dma);
-
-	/* Allocate the Rx ring now */
-	titan_ge_eth->rx_ring_size = TITAN_GE_RX_QUEUE;
-	titan_ge_eth->rx_ring_skbs = 0;
-
-	titan_ge_eth->rx_desc_area =
-		(titan_ge_rx_desc *)(titan_ge_sram + 0x1000 + TITAN_RX_RING_BYTES * port_num);
-
-	titan_ge_eth->rx_dma = TITAN_SRAM_BASE + 0x1000 + TITAN_RX_RING_BYTES * port_num;
-
-	if (!titan_ge_eth->rx_desc_area) {
-		printk(KERN_ERR "%s: Cannot allocate Rx Ring (size %d bytes)\n",
-		       netdev->name, TITAN_RX_RING_BYTES);
-
-		printk(KERN_ERR "%s: Freeing previously allocated TX queues...",
-		       netdev->name);
-
-		dma_free_coherent(device, titan_ge_eth->tx_desc_area_size,
-				    (void *) titan_ge_eth->tx_desc_area,
-				    titan_ge_eth->tx_dma);
-
-		return -ENOMEM;
-	}
-
-	memset(titan_ge_eth->rx_desc_area, 0, titan_ge_eth->rx_desc_area_size);
-
-	/* Now initialize the Rx ring */
-#ifdef TITAN_GE_JUMBO_FRAMES
-	if ((titan_ge_init_rx_desc_ring
-	    (titan_ge_eth, titan_ge_eth->rx_ring_size, TITAN_GE_JUMBO_BUFSIZE,
-	     (unsigned long) titan_ge_eth->rx_desc_area, 0,
-	      (unsigned long) titan_ge_eth->rx_dma)) == 0)
-#else
-	if ((titan_ge_init_rx_desc_ring
-	     (titan_ge_eth, titan_ge_eth->rx_ring_size, TITAN_GE_STD_BUFSIZE,
-	      (unsigned long) titan_ge_eth->rx_desc_area, 0,
-	      (unsigned long) titan_ge_eth->rx_dma)) == 0)
-#endif
-		panic("%s: Error initializing RX Ring\n", netdev->name);
-
-	/* Fill the Rx ring with the SKBs */
-	titan_ge_port_start(netdev, titan_ge_eth);
-
-	/*
-	 * Check if Interrupt Coalscing needs to be turned on. The
-	 * values specified in the register is multiplied by
-	 * (8 x 64 nanoseconds) to determine when an interrupt should
-	 * be sent to the CPU.
-	 */
-
-	if (TITAN_GE_TX_COAL) {
-		titan_ge_eth->tx_int_coal =
-		    titan_ge_tx_coal(TITAN_GE_TX_COAL, port_num);
-	}
-
-	err = titan_ge_mdio_read(port_num, TITAN_GE_MDIO_PHY_STATUS, &phy_reg);
-	if (err == TITAN_GE_MDIO_ERROR) {
-		printk(KERN_ERR
-		       "Could not read PHY control register 0x11 \n");
-		return TITAN_ERROR;
-	}
-	if (!(phy_reg & 0x0400)) {
-		netif_carrier_off(netdev);
-		netif_stop_queue(netdev);
-		return TITAN_ERROR;
-	} else {
-		netif_carrier_on(netdev);
-		netif_start_queue(netdev);
-	}
-
-	return TITAN_OK;
-}
-
-/*
- * Queue the packet for Tx. Currently no support for zero copy,
- * checksum offload and Scatter Gather. The chip does support
- * Scatter Gather only. But, that wont help here since zero copy
- * requires support for Tx checksumming also.
- */
-int titan_ge_start_xmit(struct sk_buff *skb, struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned long flags;
-	struct net_device_stats *stats;
-//printk("titan_ge_start_xmit\n");
-
-	stats = &titan_ge_eth->stats;
-	spin_lock_irqsave(&titan_ge_eth->lock, flags);
-
-	if ((TITAN_GE_TX_QUEUE - titan_ge_eth->tx_ring_skbs) <=
-	    (skb_shinfo(skb)->nr_frags + 1)) {
-		netif_stop_queue(netdev);
-		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-		printk(KERN_ERR "Tx OOD \n");
-		return 1;
-	}
-
-	titan_ge_tx_queue(titan_ge_eth, skb);
-	titan_ge_eth->tx_ring_skbs++;
-
-	if (TITAN_GE_TX_QUEUE <= (titan_ge_eth->tx_ring_skbs + 4)) {
-		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-		titan_ge_free_tx_queue(titan_ge_eth);
-		spin_lock_irqsave(&titan_ge_eth->lock, flags);
-	}
-
-	stats->tx_bytes += skb->len;
-	stats->tx_packets++;
-
-	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-
-	netdev->trans_start = jiffies;
-
-	return 0;
-}
-
-/*
- * Actually does the Rx. Rx side checksumming supported.
- */
-static int titan_ge_rx(struct net_device *netdev, int port_num,
-			titan_ge_port_info * titan_ge_port,
-		       titan_ge_packet * packet)
-{
-	int rx_curr_desc, rx_used_desc;
-	volatile titan_ge_rx_desc *rx_desc;
-
-	rx_curr_desc = titan_ge_port->rx_curr_desc_q;
-	rx_used_desc = titan_ge_port->rx_used_desc_q;
-
-	if (((rx_curr_desc + 1) % TITAN_GE_RX_QUEUE) == rx_used_desc)
-		return TITAN_ERROR;
-
-	rx_desc = &(titan_ge_port->rx_desc_area[rx_curr_desc]);
-
-	if (rx_desc->cmd_sts & TITAN_GE_RX_BUFFER_OWNED)
-		return TITAN_ERROR;
-
-	packet->skb = titan_ge_port->rx_skb[rx_curr_desc];
-	packet->len = (rx_desc->cmd_sts & 0x7fff);
-
-	/*
-	 * At this point, we dont know if the checksumming
-	 * actually helps relieve CPU. So, keep it for
-	 * port 0 only
-	 */
-	packet->checksum = ntohs((rx_desc->buffer & 0xffff0000) >> 16);
-	packet->cmd_sts = rx_desc->cmd_sts;
-
-	titan_ge_port->rx_curr_desc_q = (rx_curr_desc + 1) % TITAN_GE_RX_QUEUE;
-
-	/* Prefetch the next descriptor */
-	prefetch((const void *)
-	       &titan_ge_port->rx_desc_area[titan_ge_port->rx_curr_desc_q + 1]);
-
-	return TITAN_OK;
-}
-
-/*
- * Free the Tx queue of the used SKBs
- */
-static int titan_ge_free_tx_queue(titan_ge_port_info *titan_ge_eth)
-{
-	unsigned long flags;
-
-	/* Take the lock */
-	spin_lock_irqsave(&(titan_ge_eth->lock), flags);
-
-	while (titan_ge_return_tx_desc(titan_ge_eth, titan_ge_eth->port_num) == 0)
-		if (titan_ge_eth->tx_ring_skbs != 1)
-			titan_ge_eth->tx_ring_skbs--;
-
-	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-
-	return TITAN_OK;
-}
-
-/*
- * Threshold beyond which we do the cleaning of
- * Tx queue and new allocation for the Rx
- * queue
- */
-#define	TX_THRESHOLD	4
-#define	RX_THRESHOLD	10
-
-/*
- * Receive the packets and send it to the kernel.
- */
-static int titan_ge_receive_queue(struct net_device *netdev, unsigned int max)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	titan_ge_packet packet;
-	struct net_device_stats *stats;
-	struct sk_buff *skb;
-	unsigned long received_packets = 0;
-	unsigned int ack;
-
-	stats = &titan_ge_eth->stats;
-
-	while ((--max)
-	       && (titan_ge_rx(netdev, port_num, titan_ge_eth, &packet) == TITAN_OK)) {
-		skb = (struct sk_buff *) packet.skb;
-
-		titan_ge_eth->rx_ring_skbs--;
-
-		if (--titan_ge_eth->rx_work_limit < 0)
-			break;
-		received_packets++;
-
-		stats->rx_packets++;
-		stats->rx_bytes += packet.len;
-
-		if ((packet.cmd_sts & TITAN_GE_RX_PERR) ||
-			(packet.cmd_sts & TITAN_GE_RX_OVERFLOW_ERROR) ||
-			(packet.cmd_sts & TITAN_GE_RX_TRUNC) ||
-			(packet.cmd_sts & TITAN_GE_RX_CRC_ERROR)) {
-				stats->rx_dropped++;
-				dev_kfree_skb_any(skb);
-
-				continue;
-		}
-		/*
-		 * Either support fast path or slow path. Decision
-		 * making can really slow down the performance. The
-		 * idea is to cut down the number of checks and improve
-		 * the fastpath.
-		 */
-
-		skb_put(skb, packet.len - 2);
-
-		/*
-		 * Increment data pointer by two since thats where
-		 * the MAC starts
-		 */
-		skb_reserve(skb, 2);
-		skb->protocol = eth_type_trans(skb, netdev);
-		netif_receive_skb(skb);
-
-		if (titan_ge_eth->rx_threshold > RX_THRESHOLD) {
-			ack = titan_ge_rx_task(netdev, titan_ge_eth);
-			TITAN_GE_WRITE((0x5048 + (port_num << 8)), ack);
-			titan_ge_eth->rx_threshold = 0;
-		} else
-			titan_ge_eth->rx_threshold++;
-
-		if (titan_ge_eth->tx_threshold > TX_THRESHOLD) {
-			titan_ge_eth->tx_threshold = 0;
-			titan_ge_free_tx_queue(titan_ge_eth);
-		}
-		else
-			titan_ge_eth->tx_threshold++;
-
-	}
-	return received_packets;
-}
-
-
-/*
- * Enable the Rx side interrupts
- */
-static void titan_ge_enable_int(unsigned int port_num,
-			titan_ge_port_info *titan_ge_eth,
-			struct net_device *netdev)
-{
-	unsigned long reg_data = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
-
-	if (port_num == 0)
-		reg_data |= 0x3;
-	if (port_num == 1)
-		reg_data |= 0x300;
-	if (port_num == 2)
-		reg_data |= 0x30000;
-
-	/* Re-enable interrupts */
-	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, reg_data);
-}
-
-/*
- * Main function to handle the polling for Rx side NAPI.
- * Receive interrupts have been disabled at this point.
- * The poll schedules the transmit followed by receive.
- */
-static int titan_ge_poll(struct net_device *netdev, int *budget)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	int port_num = titan_ge_eth->port_num;
-	int work_done = 0;
-	unsigned long flags, status;
-
-	titan_ge_eth->rx_work_limit = *budget;
-	if (titan_ge_eth->rx_work_limit > netdev->quota)
-		titan_ge_eth->rx_work_limit = netdev->quota;
-
-	do {
-		/* Do the transmit cleaning work here */
-		titan_ge_free_tx_queue(titan_ge_eth);
-
-		/* Ack the Rx interrupts */
-		if (port_num == 0)
-			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x3);
-		if (port_num == 1)
-			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x300);
-		if (port_num == 2)
-			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x30000);
-
-		work_done += titan_ge_receive_queue(netdev, 0);
-
-		/* Out of quota and there is work to be done */
-		if (titan_ge_eth->rx_work_limit < 0)
-			goto not_done;
-
-		/* Receive alloc_skb could lead to OOM */
-		if (oom_flag == 1) {
-			oom_flag = 0;
-			goto oom;
-		}
-
-		status = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_A);
-	} while (status & 0x30300);
-
-	/* If we are here, then no more interrupts to process */
-	goto done;
-
-not_done:
-	*budget -= work_done;
-	netdev->quota -= work_done;
-	return 1;
-
-oom:
-	printk(KERN_ERR "OOM \n");
-	netif_rx_complete(netdev);
-	return 0;
-
-done:
-	/*
-	 * No more packets on the poll list. Turn the interrupts
-	 * back on and we should be able to catch the new
-	 * packets in the interrupt handler
-	 */
-	if (!work_done)
-		work_done = 1;
-
-	*budget -= work_done;
-	netdev->quota -= work_done;
-
-	spin_lock_irqsave(&titan_ge_eth->lock, flags);
-
-	/* Remove us from the poll list */
-	netif_rx_complete(netdev);
-
-	/* Re-enable interrupts */
-	titan_ge_enable_int(port_num, titan_ge_eth, netdev);
-
-	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-
-	return 0;
-}
-
-/*
- * Close the network device
- */
-int titan_ge_stop(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-
-	spin_lock_irq(&(titan_ge_eth->lock));
-	titan_ge_eth_stop(netdev);
-	free_irq(netdev->irq, netdev);
-	spin_unlock_irq(&titan_ge_eth->lock);
-
-	return TITAN_OK;
-}
-
-/*
- * Free the Tx ring
- */
-static void titan_ge_free_tx_rings(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	unsigned int curr;
-	unsigned long reg_data;
-
-	/* Stop the Tx DMA */
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG +
-				(port_num << 8));
-	reg_data |= 0xc0000000;
-	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG +
-			(port_num << 8)), reg_data);
-
-	/* Disable the TMAC */
-	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 +
-				(port_num << 12));
-	reg_data &= ~(0x00000001);
-	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
-			(port_num << 12)), reg_data);
-
-	for (curr = 0;
-	     (titan_ge_eth->tx_ring_skbs) && (curr < TITAN_GE_TX_QUEUE);
-	     curr++) {
-		if (titan_ge_eth->tx_skb[curr]) {
-			dev_kfree_skb(titan_ge_eth->tx_skb[curr]);
-			titan_ge_eth->tx_ring_skbs--;
-		}
-	}
-
-	if (titan_ge_eth->tx_ring_skbs != 0)
-		printk
-		    ("%s: Error on Tx descriptor free - could not free %d"
-		     " descriptors\n", netdev->name,
-		     titan_ge_eth->tx_ring_skbs);
-
-#ifndef TITAN_RX_RING_IN_SRAM
-	dma_free_coherent(&titan_ge_device[port_num]->dev,
-			  titan_ge_eth->tx_desc_area_size,
-			  (void *) titan_ge_eth->tx_desc_area,
-			  titan_ge_eth->tx_dma);
-#endif
-}
-
-/*
- * Free the Rx ring
- */
-static void titan_ge_free_rx_rings(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	unsigned int curr;
-	unsigned long reg_data;
-
-	/* Stop the Rx DMA */
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG +
-				(port_num << 8));
-	reg_data |= 0x000c0000;
-	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG +
-			(port_num << 8)), reg_data);
-
-	/* Disable the RMAC */
-	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 +
-				(port_num << 12));
-	reg_data &= ~(0x00000001);
-	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 +
-			(port_num << 12)), reg_data);
-
-	for (curr = 0;
-	     titan_ge_eth->rx_ring_skbs && (curr < TITAN_GE_RX_QUEUE);
-	     curr++) {
-		if (titan_ge_eth->rx_skb[curr]) {
-			dev_kfree_skb(titan_ge_eth->rx_skb[curr]);
-			titan_ge_eth->rx_ring_skbs--;
-		}
-	}
-
-	if (titan_ge_eth->rx_ring_skbs != 0)
-		printk(KERN_ERR
-		       "%s: Error in freeing Rx Ring. %d skb's still"
-		       " stuck in RX Ring - ignoring them\n", netdev->name,
-		       titan_ge_eth->rx_ring_skbs);
-
-#ifndef TITAN_RX_RING_IN_SRAM
-	dma_free_coherent(&titan_ge_device[port_num]->dev,
-			  titan_ge_eth->rx_desc_area_size,
-			  (void *) titan_ge_eth->rx_desc_area,
-			  titan_ge_eth->rx_dma);
-#endif
-}
-
-/*
- * Actually does the stop of the Ethernet device
- */
-static void titan_ge_eth_stop(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-
-	netif_stop_queue(netdev);
-
-	titan_ge_port_reset(titan_ge_eth->port_num);
-
-	titan_ge_free_tx_rings(netdev);
-	titan_ge_free_rx_rings(netdev);
-
-	/* Disable the Tx and Rx Interrupts for all channels */
-	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, 0x0);
-}
-
-/*
- * Update the MAC address. Note that we have to write the
- * address in three station registers, 16 bits each. And this
- * has to be done for TMAC and RMAC
- */
-static void titan_ge_update_mac_address(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	u8 p_addr[6];
-
-	memcpy(titan_ge_eth->port_mac_addr, netdev->dev_addr, 6);
-	memcpy(p_addr, netdev->dev_addr, 6);
-
-	/* Update the Address Filtering Match tables */
-	titan_ge_update_afx(titan_ge_eth);
-
-	printk("Station MAC : %d %d %d %d %d %d  \n",
-		p_addr[5], p_addr[4], p_addr[3],
-		p_addr[2], p_addr[1], p_addr[0]);
-
-	/* Set the MAC address here for TMAC and RMAC */
-	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_HI + (port_num << 12)),
-		       ((p_addr[5] << 8) | p_addr[4]));
-	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_MID + (port_num << 12)),
-		       ((p_addr[3] << 8) | p_addr[2]));
-	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_LOW + (port_num << 12)),
-		       ((p_addr[1] << 8) | p_addr[0]));
-
-	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_HI + (port_num << 12)),
-		       ((p_addr[5] << 8) | p_addr[4]));
-	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_MID + (port_num << 12)),
-		       ((p_addr[3] << 8) | p_addr[2]));
-	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_LOW + (port_num << 12)),
-		       ((p_addr[1] << 8) | p_addr[0]));
-}
-
-/*
- * Set the MAC address of the Ethernet device
- */
-static int titan_ge_set_mac_address(struct net_device *dev, void *addr)
-{
-	titan_ge_port_info *tp = netdev_priv(dev);
-	struct sockaddr *sa = addr;
-
-	memcpy(dev->dev_addr, sa->sa_data, dev->addr_len);
-
-	spin_lock_irq(&tp->lock);
-	titan_ge_update_mac_address(dev);
-	spin_unlock_irq(&tp->lock);
-
-	return 0;
-}
-
-/*
- * Get the Ethernet device stats
- */
-static struct net_device_stats *titan_ge_get_stats(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-
-	return &titan_ge_eth->stats;
-}
-
-/*
- * Initialize the Rx descriptor ring for the Titan Ge
- */
-static int titan_ge_init_rx_desc_ring(titan_ge_port_info * titan_eth_port,
-				      int rx_desc_num,
-				      int rx_buff_size,
-				      unsigned long rx_desc_base_addr,
-				      unsigned long rx_buff_base_addr,
-				      unsigned long rx_dma)
-{
-	volatile titan_ge_rx_desc *rx_desc;
-	unsigned long buffer_addr;
-	int index;
-	unsigned long titan_ge_rx_desc_bus = rx_dma;
-
-	buffer_addr = rx_buff_base_addr;
-	rx_desc = (titan_ge_rx_desc *) rx_desc_base_addr;
-
-	/* Check alignment */
-	if (rx_buff_base_addr & 0xF)
-		return 0;
-
-	/* Check Rx buffer size */
-	if ((rx_buff_size < 8) || (rx_buff_size > TITAN_GE_MAX_RX_BUFFER))
-		return 0;
-
-	/* 64-bit alignment
-	if ((rx_buff_base_addr + rx_buff_size) & 0x7)
-		return 0; */
-
-	/* Initialize the Rx desc ring */
-	for (index = 0; index < rx_desc_num; index++) {
-		titan_ge_rx_desc_bus += sizeof(titan_ge_rx_desc);
-		rx_desc[index].cmd_sts = 0;
-		rx_desc[index].buffer_addr = buffer_addr;
-		titan_eth_port->rx_skb[index] = NULL;
-		buffer_addr += rx_buff_size;
-	}
-
-	titan_eth_port->rx_curr_desc_q = 0;
-	titan_eth_port->rx_used_desc_q = 0;
-
-	titan_eth_port->rx_desc_area = (titan_ge_rx_desc *) rx_desc_base_addr;
-	titan_eth_port->rx_desc_area_size =
-	    rx_desc_num * sizeof(titan_ge_rx_desc);
-
-	titan_eth_port->rx_dma = rx_dma;
-
-	return TITAN_OK;
-}
-
-/*
- * Initialize the Tx descriptor ring. Descriptors in the SRAM
- */
-static int titan_ge_init_tx_desc_ring(titan_ge_port_info * titan_ge_port,
-				      int tx_desc_num,
-				      unsigned long tx_desc_base_addr,
-				      unsigned long tx_dma)
-{
-	titan_ge_tx_desc *tx_desc;
-	int index;
-	unsigned long titan_ge_tx_desc_bus = tx_dma;
-
-	if (tx_desc_base_addr & 0xF)
-		return 0;
-
-	tx_desc = (titan_ge_tx_desc *) tx_desc_base_addr;
-
-	for (index = 0; index < tx_desc_num; index++) {
-		titan_ge_port->tx_dma_array[index] =
-		    (dma_addr_t) titan_ge_tx_desc_bus;
-		titan_ge_tx_desc_bus += sizeof(titan_ge_tx_desc);
-		tx_desc[index].cmd_sts = 0x0000;
-		tx_desc[index].buffer_len = 0;
-		tx_desc[index].buffer_addr = 0x00000000;
-		titan_ge_port->tx_skb[index] = NULL;
-	}
-
-	titan_ge_port->tx_curr_desc_q = 0;
-	titan_ge_port->tx_used_desc_q = 0;
-
-	titan_ge_port->tx_desc_area = (titan_ge_tx_desc *) tx_desc_base_addr;
-	titan_ge_port->tx_desc_area_size =
-	    tx_desc_num * sizeof(titan_ge_tx_desc);
-
-	titan_ge_port->tx_dma = tx_dma;
-	return TITAN_OK;
-}
-
-/*
- * Initialize the device as an Ethernet device
- */
-static int __init titan_ge_probe(struct device *device)
-{
-	titan_ge_port_info *titan_ge_eth;
-	struct net_device *netdev;
-	int port = to_platform_device(device)->id;
-	int err;
-
-	netdev = alloc_etherdev(sizeof(titan_ge_port_info));
-	if (!netdev) {
-		err = -ENODEV;
-		goto out;
-	}
-
-	netdev->open = titan_ge_open;
-	netdev->stop = titan_ge_stop;
-	netdev->hard_start_xmit = titan_ge_start_xmit;
-	netdev->get_stats = titan_ge_get_stats;
-	netdev->set_multicast_list = titan_ge_set_multi;
-	netdev->set_mac_address = titan_ge_set_mac_address;
-
-	/* Tx timeout */
-	netdev->tx_timeout = titan_ge_tx_timeout;
-	netdev->watchdog_timeo = 2 * HZ;
-
-	/* Set these to very high values */
-	netdev->poll = titan_ge_poll;
-	netdev->weight = 64;
-
-	netdev->tx_queue_len = TITAN_GE_TX_QUEUE;
-	netif_carrier_off(netdev);
-	netdev->base_addr = 0;
-
-	netdev->change_mtu = titan_ge_change_mtu;
-
-	titan_ge_eth = netdev_priv(netdev);
-	/* Allocation of memory for the driver structures */
-
-	titan_ge_eth->port_num = port;
-
-	/* Configure the Tx timeout handler */
-	INIT_WORK(&titan_ge_eth->tx_timeout_task,
-		  (void (*)(void *)) titan_ge_tx_timeout_task, netdev);
-
-	spin_lock_init(&titan_ge_eth->lock);
-
-	/* set MAC addresses */
-	memcpy(netdev->dev_addr, titan_ge_mac_addr_base, 6);
-	netdev->dev_addr[5] += port;
-
-	err = register_netdev(netdev);
-
-	if (err)
-		goto out_free_netdev;
-
-	printk(KERN_NOTICE
-	       "%s: port %d with MAC address %02x:%02x:%02x:%02x:%02x:%02x\n",
-	       netdev->name, port, netdev->dev_addr[0],
-	       netdev->dev_addr[1], netdev->dev_addr[2],
-	       netdev->dev_addr[3], netdev->dev_addr[4],
-	       netdev->dev_addr[5]);
-
-	printk(KERN_NOTICE "Rx NAPI supported, Tx Coalescing ON \n");
-
-	return 0;
-
-out_free_netdev:
-	kfree(netdev);
-
-out:
-	return err;
-}
-
-static void __devexit titan_device_remove(struct device *device)
-{
-}
-
-/*
- * Reset the Ethernet port
- */
-static void titan_ge_port_reset(unsigned int port_num)
-{
-	unsigned int reg_data;
-
-	/* Stop the Tx port activity */
-	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 +
-				(port_num << 12));
-	reg_data &= ~(0x0001);
-	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
-			(port_num << 12)), reg_data);
-
-	/* Stop the Rx port activity */
-	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 +
-				(port_num << 12));
-	reg_data &= ~(0x0001);
-	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 +
-			(port_num << 12)), reg_data);
-
-	return;
-}
-
-/*
- * Return the Tx desc after use by the XDMA
- */
-static int titan_ge_return_tx_desc(titan_ge_port_info * titan_ge_eth, int port)
-{
-	int tx_desc_used;
-	struct sk_buff *skb;
-
-	tx_desc_used = titan_ge_eth->tx_used_desc_q;
-
-	/* return right away */
-	if (tx_desc_used == titan_ge_eth->tx_curr_desc_q)
-		return TITAN_ERROR;
-
-	/* Now the critical stuff */
-	skb = titan_ge_eth->tx_skb[tx_desc_used];
-
-	dev_kfree_skb_any(skb);
-
-	titan_ge_eth->tx_skb[tx_desc_used] = NULL;
-	titan_ge_eth->tx_used_desc_q =
-	    (tx_desc_used + 1) % TITAN_GE_TX_QUEUE;
-
-	return 0;
-}
-
-/*
- * Coalescing for the Tx path
- */
-static unsigned long titan_ge_tx_coal(unsigned long delay, int port)
-{
-	unsigned long rx_delay;
-
-	rx_delay = TITAN_GE_READ(TITAN_GE_INT_COALESCING);
-	delay = (delay << 16) | rx_delay;
-
-	TITAN_GE_WRITE(TITAN_GE_INT_COALESCING, delay);
-	TITAN_GE_WRITE(0x5038, delay);
-
-	return delay;
-}
-
-static struct device_driver titan_soc_driver = {
-	.name   = titan_string,
-	.bus    = &platform_bus_type,
-	.probe  = titan_ge_probe,
-	.remove = __devexit_p(titan_device_remove),
-};
-
-static void titan_platform_release (struct device *device)
-{
-	struct platform_device *pldev;
-
-	/* free device */
-	pldev = to_platform_device (device);
-	kfree (pldev);
-}
-
-/*
- * Register the Titan GE with the kernel
- */
-static int __init titan_ge_init_module(void)
-{
-	struct platform_device *pldev;
-	unsigned int version, device;
-	int i;
-
-	printk(KERN_NOTICE
-	       "PMC-Sierra TITAN 10/100/1000 Ethernet Driver \n");
-
-	titan_ge_base = (unsigned long) ioremap(TITAN_GE_BASE, TITAN_GE_SIZE);
-	if (!titan_ge_base) {
-		printk("Mapping Titan GE failed\n");
-		goto out;
-	}
-
-	device = TITAN_GE_READ(TITAN_GE_DEVICE_ID);
-	version = (device & 0x000f0000) >> 16;
-	device &= 0x0000ffff;
-
-	printk(KERN_NOTICE "Device Id : %x,  Version : %x \n", device, version);
-
-#ifdef TITAN_RX_RING_IN_SRAM
-	titan_ge_sram = (unsigned long) ioremap(TITAN_SRAM_BASE,
-						TITAN_SRAM_SIZE);
-	if (!titan_ge_sram) {
-		printk("Mapping Titan SRAM failed\n");
-		goto out_unmap_ge;
-	}
-#endif
-
-	if (driver_register(&titan_soc_driver)) {
-		printk(KERN_ERR "Driver registration failed\n");
-		goto out_unmap_sram;
-	}
-
-	for (i = 0; i < 3; i++) {
-		titan_ge_device[i] = NULL;
-
-		if (!(pldev = kmalloc (sizeof (*pldev), GFP_KERNEL)))
-			continue;
-
-		memset (pldev, 0, sizeof (*pldev));
-		pldev->name		= titan_string;
-		pldev->id		= i;
-		pldev->dev.release	= titan_platform_release;
-		titan_ge_device[i]	= pldev;
-
-		if (platform_device_register (pldev)) {
-			kfree (pldev);
-			titan_ge_device[i] = NULL;
-			continue;
-		}
-
-		if (!pldev->dev.driver) {
-			/*
-			 * The driver was not bound to this device, there was
-			 * no hardware at this address. Unregister it, as the
-			 * release fuction will take care of freeing the
-			 * allocated structure
-			 */
-			titan_ge_device[i] = NULL;
-			platform_device_unregister (pldev);
-		}
-	}
-
-	return 0;
-
-out_unmap_sram:
-	iounmap((void *)titan_ge_sram);
-
-out_unmap_ge:
-	iounmap((void *)titan_ge_base);
-
-out:
-	return -ENOMEM;
-}
-
-/*
- * Unregister the Titan GE from the kernel
- */
-static void __exit titan_ge_cleanup_module(void)
-{
-	int i;
-
-	driver_unregister(&titan_soc_driver);
-
-	for (i = 0; i < 3; i++) {
-		if (titan_ge_device[i]) {
-			platform_device_unregister (titan_ge_device[i]);
-			titan_ge_device[i] = NULL;
-		}
-	}
-
-	iounmap((void *)titan_ge_sram);
-	iounmap((void *)titan_ge_base);
-}
-
-MODULE_AUTHOR("Manish Lachwani <lachwani@pmc-sierra.com>");
-MODULE_DESCRIPTION("Titan GE Ethernet driver");
-MODULE_LICENSE("GPL");
-
-module_init(titan_ge_init_module);
-module_exit(titan_ge_cleanup_module);
diff -Naur linux-3.3-rc2/drivers/net/ethernet/pmc-sierra/titan_ge.h wm8505-3.3rc2/drivers/net/ethernet/pmc-sierra/titan_ge.h
--- linux-3.3-rc2/drivers/net/ethernet/pmc-sierra/titan_ge.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/net/ethernet/pmc-sierra/titan_ge.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,415 +0,0 @@
-#ifndef _TITAN_GE_H_
-#define _TITAN_GE_H_
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/spinlock.h>
-#include <asm/byteorder.h>
-
-/*
- * These functions should be later moved to a more generic location since there
- * will be others accessing it also
- */
-
-/*
- * This is the way it works: LKB5 Base is at 0x0128. TITAN_BASE is defined in
- * include/asm/titan_dep.h. TITAN_GE_BASE is the value in the TITAN_GE_LKB5
- * register.
- */
-
-#define	TITAN_GE_BASE	0xfe000000UL
-#define	TITAN_GE_SIZE	0x10000UL
-
-extern unsigned long titan_ge_base;
-
-#define	TITAN_GE_WRITE(offset, data) \
-		*(volatile u32 *)(titan_ge_base + (offset)) = (data)
-
-#define TITAN_GE_READ(offset) *(volatile u32 *)(titan_ge_base + (offset))
-
-#ifndef msec_delay
-#define msec_delay(x)   do { if(in_interrupt()) { \
-				/* Don't mdelay in interrupt context! */ \
-				BUG(); \
-			} else { \
-				set_current_state(TASK_UNINTERRUPTIBLE); \
-				schedule_timeout((x * HZ)/1000); \
-			} } while(0)
-#endif
-
-#define TITAN_GE_PORT_0
-
-#define	TITAN_SRAM_BASE		((OCD_READ(RM9000x2_OCD_LKB13) & ~1) << 4)
-#define	TITAN_SRAM_SIZE		0x2000UL
-
-/*
- * We may need these constants
- */
-#define TITAN_BIT0    0x00000001
-#define TITAN_BIT1    0x00000002
-#define TITAN_BIT2    0x00000004
-#define TITAN_BIT3    0x00000008
-#define TITAN_BIT4    0x00000010
-#define TITAN_BIT5    0x00000020
-#define TITAN_BIT6    0x00000040
-#define TITAN_BIT7    0x00000080
-#define TITAN_BIT8    0x00000100
-#define TITAN_BIT9    0x00000200
-#define TITAN_BIT10   0x00000400
-#define TITAN_BIT11   0x00000800
-#define TITAN_BIT12   0x00001000
-#define TITAN_BIT13   0x00002000
-#define TITAN_BIT14   0x00004000
-#define TITAN_BIT15   0x00008000
-#define TITAN_BIT16   0x00010000
-#define TITAN_BIT17   0x00020000
-#define TITAN_BIT18   0x00040000
-#define TITAN_BIT19   0x00080000
-#define TITAN_BIT20   0x00100000
-#define TITAN_BIT21   0x00200000
-#define TITAN_BIT22   0x00400000
-#define TITAN_BIT23   0x00800000
-#define TITAN_BIT24   0x01000000
-#define TITAN_BIT25   0x02000000
-#define TITAN_BIT26   0x04000000
-#define TITAN_BIT27   0x08000000
-#define TITAN_BIT28   0x10000000
-#define TITAN_BIT29   0x20000000
-#define TITAN_BIT30   0x40000000
-#define TITAN_BIT31   0x80000000
-
-/* Flow Control */
-#define	TITAN_GE_FC_NONE	0x0
-#define	TITAN_GE_FC_FULL	0x1
-#define	TITAN_GE_FC_TX_PAUSE	0x2
-#define	TITAN_GE_FC_RX_PAUSE	0x3
-
-/* Duplex Settings */
-#define	TITAN_GE_FULL_DUPLEX	0x1
-#define	TITAN_GE_HALF_DUPLEX	0x2
-
-/* Speed settings */
-#define	TITAN_GE_SPEED_1000	0x1
-#define	TITAN_GE_SPEED_100	0x2
-#define	TITAN_GE_SPEED_10	0x3
-
-/* Debugging info only */
-#undef TITAN_DEBUG
-
-/* Keep the rings in the Titan's SSRAM */
-#define TITAN_RX_RING_IN_SRAM
-
-#ifdef CONFIG_64BIT
-#define	TITAN_GE_IE_MASK	0xfffffffffb001b64
-#define	TITAN_GE_IE_STATUS	0xfffffffffb001b60
-#else
-#define	TITAN_GE_IE_MASK	0xfb001b64
-#define	TITAN_GE_IE_STATUS	0xfb001b60
-#endif
-
-/* Support for Jumbo Frames */
-#undef TITAN_GE_JUMBO_FRAMES
-
-/* Rx buffer size */
-#ifdef TITAN_GE_JUMBO_FRAMES
-#define	TITAN_GE_JUMBO_BUFSIZE	9080
-#else
-#define	TITAN_GE_STD_BUFSIZE	1580
-#endif
-
-/*
- * Tx and Rx Interrupt Coalescing parameter. These values are
- * for 1 Ghz processor. Rx coalescing can be taken care of
- * by NAPI. NAPI is adaptive and hence useful. Tx coalescing
- * is not adaptive. Hence, these values need to be adjusted
- * based on load, CPU speed etc.
- */
-#define	TITAN_GE_RX_COAL	150
-#define	TITAN_GE_TX_COAL	300
-
-#if defined(__BIG_ENDIAN)
-
-/* Define the Rx descriptor */
-typedef struct eth_rx_desc {
-	u32     reserved;	/* Unused 		*/
-	u32     buffer_addr;	/* CPU buffer address 	*/
-	u32	cmd_sts;	/* Command and Status	*/
-	u32	buffer;		/* XDMA buffer address	*/
-} titan_ge_rx_desc;
-
-/* Define the Tx descriptor */
-typedef struct eth_tx_desc {
-	u16     cmd_sts;	/* Command, Status and Buffer count */
-	u16	buffer_len;	/* Length of the buffer	*/
-	u32     buffer_addr;	/* Physical address of the buffer */
-} titan_ge_tx_desc;
-
-#elif defined(__LITTLE_ENDIAN)
-
-/* Define the Rx descriptor */
-typedef struct eth_rx_desc {
-	u32	buffer_addr;	/* CPU buffer address   */
-	u32	reserved;	/* Unused               */
-	u32	buffer;		/* XDMA buffer address  */
-	u32	cmd_sts;	/* Command and Status   */
-} titan_ge_rx_desc;
-
-/* Define the Tx descriptor */
-typedef struct eth_tx_desc {
-	u32     buffer_addr;	/* Physical address of the buffer */
-	u16     buffer_len;     /* Length of the buffer */
-	u16     cmd_sts;        /* Command, Status and Buffer count */
-} titan_ge_tx_desc;
-#endif
-
-/* Default Tx Queue Size */
-#define	TITAN_GE_TX_QUEUE	128
-#define TITAN_TX_RING_BYTES	(TITAN_GE_TX_QUEUE * sizeof(struct eth_tx_desc))
-
-/* Default Rx Queue Size */
-#define	TITAN_GE_RX_QUEUE	64
-#define TITAN_RX_RING_BYTES	(TITAN_GE_RX_QUEUE * sizeof(struct eth_rx_desc))
-
-/* Packet Structure */
-typedef struct _pkt_info {
-	unsigned int           len;
-	unsigned int            cmd_sts;
-	unsigned int            buffer;
-	struct sk_buff          *skb;
-	unsigned int		checksum;
-} titan_ge_packet;
-
-
-#define	PHYS_CNT	3
-
-/* Titan Port specific data structure */
-typedef struct _eth_port_ctrl {
-	unsigned int		port_num;
-	u8			port_mac_addr[6];
-
-	/* Rx descriptor pointers */
-	int 			rx_curr_desc_q, rx_used_desc_q;
-
-	/* Tx descriptor pointers */
-	int 			tx_curr_desc_q, tx_used_desc_q;
-
-	/* Rx descriptor area */
-	volatile titan_ge_rx_desc	*rx_desc_area;
-	unsigned int			rx_desc_area_size;
-	struct sk_buff*			rx_skb[TITAN_GE_RX_QUEUE];
-
-	/* Tx Descriptor area */
-	volatile titan_ge_tx_desc	*tx_desc_area;
-	unsigned int                    tx_desc_area_size;
-	struct sk_buff*                 tx_skb[TITAN_GE_TX_QUEUE];
-
-	/* Timeout task */
-	struct work_struct		tx_timeout_task;
-
-	/* DMA structures and handles */
-	dma_addr_t			tx_dma;
-	dma_addr_t			rx_dma;
-	dma_addr_t			tx_dma_array[TITAN_GE_TX_QUEUE];
-
-	/* Device lock */
-	spinlock_t			lock;
-
-	unsigned int			tx_ring_skbs;
-	unsigned int			rx_ring_size;
-	unsigned int			tx_ring_size;
-	unsigned int			rx_ring_skbs;
-
-	struct net_device_stats		stats;
-
-	/* Tx and Rx coalescing */
-	unsigned long			rx_int_coal;
-	unsigned long			tx_int_coal;
-
-	/* Threshold for replenishing the Rx and Tx rings */
-	unsigned int			tx_threshold;
-	unsigned int			rx_threshold;
-
-	/* NAPI work limit */
-	unsigned int			rx_work_limit;
-} titan_ge_port_info;
-
-/* Titan specific constants */
-#define	TITAN_ETH_PORT_IRQ		3
-
-/* Max Rx buffer */
-#define	TITAN_GE_MAX_RX_BUFFER		65536
-
-/* Tx and Rx Error */
-#define	TITAN_GE_ERROR
-
-/* Rx Descriptor Command and Status */
-
-#define	TITAN_GE_RX_CRC_ERROR		TITAN_BIT27	/* crc error */
-#define	TITAN_GE_RX_OVERFLOW_ERROR	TITAN_BIT15	/* overflow */
-#define TITAN_GE_RX_BUFFER_OWNED	TITAN_BIT21	/* buffer ownership */
-#define	TITAN_GE_RX_STP			TITAN_BIT31	/* start of packet */
-#define	TITAN_GE_RX_BAM			TITAN_BIT30	/* broadcast address match */
-#define TITAN_GE_RX_PAM			TITAN_BIT28	/* physical address match */
-#define TITAN_GE_RX_LAFM		TITAN_BIT29	/* logical address filter match */
-#define TITAN_GE_RX_VLAN		TITAN_BIT26	/* virtual lans */
-#define TITAN_GE_RX_PERR		TITAN_BIT19	/* packet error */
-#define TITAN_GE_RX_TRUNC		TITAN_BIT20	/* packet size greater than 32 buffers */
-
-/* Tx Descriptor Command */
-#define	TITAN_GE_TX_BUFFER_OWNED	TITAN_BIT5	/* buffer ownership */
-#define	TITAN_GE_TX_ENABLE_INTERRUPT	TITAN_BIT15	/* Interrupt Enable */
-
-/* Return Status */
-#define	TITAN_OK	0x1	/* Good Status */
-#define	TITAN_ERROR	0x2	/* Error Status */
-
-/* MIB specific register offset */
-#define TITAN_GE_MSTATX_STATS_BASE_LOW       0x0800  /* MSTATX COUNTL[15:0] */
-#define TITAN_GE_MSTATX_STATS_BASE_MID       0x0804  /* MSTATX COUNTM[15:0] */
-#define TITAN_GE_MSTATX_STATS_BASE_HI        0x0808  /* MSTATX COUNTH[7:0] */
-#define TITAN_GE_MSTATX_CONTROL              0x0828  /* MSTATX Control */
-#define TITAN_GE_MSTATX_VARIABLE_SELECT      0x082C  /* MSTATX Variable Select */
-
-/* MIB counter offsets, add to the TITAN_GE_MSTATX_STATS_BASE_XXX */
-#define TITAN_GE_MSTATX_RXFRAMESOK                   0x0040
-#define TITAN_GE_MSTATX_RXOCTETSOK                   0x0050
-#define TITAN_GE_MSTATX_RXFRAMES                     0x0060
-#define TITAN_GE_MSTATX_RXOCTETS                     0x0070
-#define TITAN_GE_MSTATX_RXUNICASTFRAMESOK            0x0080
-#define TITAN_GE_MSTATX_RXBROADCASTFRAMESOK          0x0090
-#define TITAN_GE_MSTATX_RXMULTICASTFRAMESOK          0x00A0
-#define TITAN_GE_MSTATX_RXTAGGEDFRAMESOK             0x00B0
-#define TITAN_GE_MSTATX_RXMACPAUSECONTROLFRAMESOK    0x00C0
-#define TITAN_GE_MSTATX_RXMACCONTROLFRAMESOK         0x00D0
-#define TITAN_GE_MSTATX_RXFCSERROR                   0x00E0
-#define TITAN_GE_MSTATX_RXALIGNMENTERROR             0x00F0
-#define TITAN_GE_MSTATX_RXSYMBOLERROR                0x0100
-#define TITAN_GE_MSTATX_RXLAYER1ERROR                0x0110
-#define TITAN_GE_MSTATX_RXINRANGELENGTHERROR         0x0120
-#define TITAN_GE_MSTATX_RXLONGLENGTHERROR            0x0130
-#define TITAN_GE_MSTATX_RXLONGLENGTHCRCERROR         0x0140
-#define TITAN_GE_MSTATX_RXSHORTLENGTHERROR           0x0150
-#define TITAN_GE_MSTATX_RXSHORTLLENGTHCRCERROR       0x0160
-#define TITAN_GE_MSTATX_RXFRAMES64OCTETS             0x0170
-#define TITAN_GE_MSTATX_RXFRAMES65TO127OCTETS        0x0180
-#define TITAN_GE_MSTATX_RXFRAMES128TO255OCTETS       0x0190
-#define TITAN_GE_MSTATX_RXFRAMES256TO511OCTETS       0x01A0
-#define TITAN_GE_MSTATX_RXFRAMES512TO1023OCTETS      0x01B0
-#define TITAN_GE_MSTATX_RXFRAMES1024TO1518OCTETS     0x01C0
-#define TITAN_GE_MSTATX_RXFRAMES1519TOMAXSIZE        0x01D0
-#define TITAN_GE_MSTATX_RXSTATIONADDRESSFILTERED     0x01E0
-#define TITAN_GE_MSTATX_RXVARIABLE                   0x01F0
-#define TITAN_GE_MSTATX_GENERICADDRESSFILTERED       0x0200
-#define TITAN_GE_MSTATX_UNICASTFILTERED              0x0210
-#define TITAN_GE_MSTATX_MULTICASTFILTERED            0x0220
-#define TITAN_GE_MSTATX_BROADCASTFILTERED            0x0230
-#define TITAN_GE_MSTATX_HASHFILTERED                 0x0240
-#define TITAN_GE_MSTATX_TXFRAMESOK                   0x0250
-#define TITAN_GE_MSTATX_TXOCTETSOK                   0x0260
-#define TITAN_GE_MSTATX_TXOCTETS                     0x0270
-#define TITAN_GE_MSTATX_TXTAGGEDFRAMESOK             0x0280
-#define TITAN_GE_MSTATX_TXMACPAUSECONTROLFRAMESOK    0x0290
-#define TITAN_GE_MSTATX_TXFCSERROR                   0x02A0
-#define TITAN_GE_MSTATX_TXSHORTLENGTHERROR           0x02B0
-#define TITAN_GE_MSTATX_TXLONGLENGTHERROR            0x02C0
-#define TITAN_GE_MSTATX_TXSYSTEMERROR                0x02D0
-#define TITAN_GE_MSTATX_TXMACERROR                   0x02E0
-#define TITAN_GE_MSTATX_TXCARRIERSENSEERROR          0x02F0
-#define TITAN_GE_MSTATX_TXSQETESTERROR               0x0300
-#define TITAN_GE_MSTATX_TXUNICASTFRAMESOK            0x0310
-#define TITAN_GE_MSTATX_TXBROADCASTFRAMESOK          0x0320
-#define TITAN_GE_MSTATX_TXMULTICASTFRAMESOK          0x0330
-#define TITAN_GE_MSTATX_TXUNICASTFRAMESATTEMPTED     0x0340
-#define TITAN_GE_MSTATX_TXBROADCASTFRAMESATTEMPTED   0x0350
-#define TITAN_GE_MSTATX_TXMULTICASTFRAMESATTEMPTED   0x0360
-#define TITAN_GE_MSTATX_TXFRAMES64OCTETS             0x0370
-#define TITAN_GE_MSTATX_TXFRAMES65TO127OCTETS        0x0380
-#define TITAN_GE_MSTATX_TXFRAMES128TO255OCTETS       0x0390
-#define TITAN_GE_MSTATX_TXFRAMES256TO511OCTETS       0x03A0
-#define TITAN_GE_MSTATX_TXFRAMES512TO1023OCTETS      0x03B0
-#define TITAN_GE_MSTATX_TXFRAMES1024TO1518OCTETS     0x03C0
-#define TITAN_GE_MSTATX_TXFRAMES1519TOMAXSIZE        0x03D0
-#define TITAN_GE_MSTATX_TXVARIABLE                   0x03E0
-#define TITAN_GE_MSTATX_RXSYSTEMERROR                0x03F0
-#define TITAN_GE_MSTATX_SINGLECOLLISION              0x0400
-#define TITAN_GE_MSTATX_MULTIPLECOLLISION            0x0410
-#define TITAN_GE_MSTATX_DEFERREDXMISSIONS            0x0420
-#define TITAN_GE_MSTATX_LATECOLLISIONS               0x0430
-#define TITAN_GE_MSTATX_ABORTEDDUETOXSCOLLS          0x0440
-
-/* Interrupt specific defines */
-#define TITAN_GE_DEVICE_ID         0x0000  /* Device ID */
-#define TITAN_GE_RESET             0x0004  /* Reset reg */
-#define TITAN_GE_TSB_CTRL_0        0x000C  /* TSB Control reg 0 */
-#define TITAN_GE_TSB_CTRL_1        0x0010  /* TSB Control reg 1 */
-#define TITAN_GE_INTR_GRP0_STATUS  0x0040  /* General Interrupt Group 0 Status */
-#define TITAN_GE_INTR_XDMA_CORE_A  0x0048  /* XDMA Channel Interrupt Status, Core A*/
-#define TITAN_GE_INTR_XDMA_CORE_B  0x004C  /* XDMA Channel Interrupt Status, Core B*/
-#define	TITAN_GE_INTR_XDMA_IE	   0x0058  /* XDMA Channel Interrupt Enable */
-#define TITAN_GE_SDQPF_ECC_INTR    0x480C  /* SDQPF ECC Interrupt Status */
-#define TITAN_GE_SDQPF_RXFIFO_CTL  0x4828  /* SDQPF RxFifo Control and Interrupt Enb*/
-#define TITAN_GE_SDQPF_RXFIFO_INTR 0x482C  /* SDQPF RxFifo Interrupt Status */
-#define TITAN_GE_SDQPF_TXFIFO_CTL  0x4928  /* SDQPF TxFifo Control and Interrupt Enb*/
-#define TITAN_GE_SDQPF_TXFIFO_INTR 0x492C  /* SDQPF TxFifo Interrupt Status */
-#define	TITAN_GE_SDQPF_RXFIFO_0	   0x4840  /* SDQPF RxFIFO Enable */
-#define	TITAN_GE_SDQPF_TXFIFO_0	   0x4940  /* SDQPF TxFIFO Enable */
-#define TITAN_GE_XDMA_CONFIG       0x5000  /* XDMA Global Configuration */
-#define TITAN_GE_XDMA_INTR_SUMMARY 0x5010  /* XDMA Interrupt Summary */
-#define TITAN_GE_XDMA_BUFADDRPRE   0x5018  /* XDMA Buffer Address Prefix */
-#define TITAN_GE_XDMA_DESCADDRPRE  0x501C  /* XDMA Descriptor Address Prefix */
-#define TITAN_GE_XDMA_PORTWEIGHT   0x502C  /* XDMA Port Weight Configuration */
-
-/* Rx MAC defines */
-#define TITAN_GE_RMAC_CONFIG_1               0x1200  /* RMAC Configuration 1 */
-#define TITAN_GE_RMAC_CONFIG_2               0x1204  /* RMAC Configuration 2 */
-#define TITAN_GE_RMAC_MAX_FRAME_LEN          0x1208  /* RMAC Max Frame Length */
-#define TITAN_GE_RMAC_STATION_HI             0x120C  /* Rx Station Address High */
-#define TITAN_GE_RMAC_STATION_MID            0x1210  /* Rx Station Address Middle */
-#define TITAN_GE_RMAC_STATION_LOW            0x1214  /* Rx Station Address Low */
-#define TITAN_GE_RMAC_LINK_CONFIG            0x1218  /* RMAC Link Configuration */
-
-/* Tx MAC defines */
-#define TITAN_GE_TMAC_CONFIG_1               0x1240  /* TMAC Configuration 1 */
-#define TITAN_GE_TMAC_CONFIG_2               0x1244  /* TMAC Configuration 2 */
-#define TITAN_GE_TMAC_IPG                    0x1248  /* TMAC Inter-Packet Gap */
-#define TITAN_GE_TMAC_STATION_HI             0x124C  /* Tx Station Address High */
-#define TITAN_GE_TMAC_STATION_MID            0x1250  /* Tx Station Address Middle */
-#define TITAN_GE_TMAC_STATION_LOW            0x1254  /* Tx Station Address Low */
-#define TITAN_GE_TMAC_MAX_FRAME_LEN          0x1258  /* TMAC Max Frame Length */
-#define TITAN_GE_TMAC_MIN_FRAME_LEN          0x125C  /* TMAC Min Frame Length */
-#define TITAN_GE_TMAC_PAUSE_FRAME_TIME       0x1260  /* TMAC Pause Frame Time */
-#define TITAN_GE_TMAC_PAUSE_FRAME_INTERVAL   0x1264  /* TMAC Pause Frame Interval */
-
-/* GMII register */
-#define TITAN_GE_GMII_INTERRUPT_STATUS       0x1348  /* GMII Interrupt Status */
-#define TITAN_GE_GMII_CONFIG_GENERAL         0x134C  /* GMII Configuration General */
-#define TITAN_GE_GMII_CONFIG_MODE            0x1350  /* GMII Configuration Mode */
-
-/* Tx and Rx XDMA defines */
-#define	TITAN_GE_INT_COALESCING		     0x5030 /* Interrupt Coalescing */
-#define	TITAN_GE_CHANNEL0_CONFIG	     0x5040 /* Channel 0 XDMA config */
-#define	TITAN_GE_CHANNEL0_INTERRUPT	     0x504c /* Channel 0 Interrupt Status */
-#define	TITAN_GE_GDI_INTERRUPT_ENABLE        0x5050 /* IE for the GDI Errors */
-#define	TITAN_GE_CHANNEL0_PACKET	     0x5060 /* Channel 0 Packet count */
-#define	TITAN_GE_CHANNEL0_BYTE		     0x5064 /* Channel 0 Byte count */
-#define	TITAN_GE_CHANNEL0_TX_DESC	     0x5054 /* Channel 0 Tx first desc */
-#define	TITAN_GE_CHANNEL0_RX_DESC	     0x5058 /* Channel 0 Rx first desc */
-
-/* AFX (Address Filter Exact) register offsets for Slice 0 */
-#define TITAN_GE_AFX_EXACT_MATCH_LOW         0x1100  /* AFX Exact Match Address Low*/
-#define TITAN_GE_AFX_EXACT_MATCH_MID         0x1104  /* AFX Exact Match Address Mid*/
-#define TITAN_GE_AFX_EXACT_MATCH_HIGH        0x1108  /* AFX Exact Match Address Hi */
-#define TITAN_GE_AFX_EXACT_MATCH_VID         0x110C  /* AFX Exact Match VID */
-#define TITAN_GE_AFX_MULTICAST_HASH_LOW      0x1110  /* AFX Multicast HASH Low */
-#define TITAN_GE_AFX_MULTICAST_HASH_MIDLOW   0x1114  /* AFX Multicast HASH MidLow */
-#define TITAN_GE_AFX_MULTICAST_HASH_MIDHI    0x1118  /* AFX Multicast HASH MidHi */
-#define TITAN_GE_AFX_MULTICAST_HASH_HI       0x111C  /* AFX Multicast HASH Hi */
-#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_0     0x1120  /* AFX Address Filter Ctrl 0 */
-#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_1     0x1124  /* AFX Address Filter Ctrl 1 */
-#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_2     0x1128  /* AFX Address Filter Ctrl 2 */
-
-/* Traffic Groomer block */
-#define        TITAN_GE_TRTG_CONFIG	     0x1000  /* TRTG Config */
-
-#endif 				/* _TITAN_GE_H_ */
-
diff -Naur linux-3.3-rc2/drivers/net/ethernet/pmc-sierra/titan_mdio.c wm8505-3.3rc2/drivers/net/ethernet/pmc-sierra/titan_mdio.c
--- linux-3.3-rc2/drivers/net/ethernet/pmc-sierra/titan_mdio.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/net/ethernet/pmc-sierra/titan_mdio.c	1969-12-31 17:00:00.000000000 -0700
@@ -1,217 +0,0 @@
-/*
- * drivers/net/titan_mdio.c - Driver for Titan ethernet ports
- *
- * Copyright (C) 2003 PMC-Sierra Inc.
- * Author : Manish Lachwani (lachwani@pmc-sierra.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- *
- * Management Data IO (MDIO) driver for the Titan GMII. Interacts with the Marvel PHY
- * on the Titan. No support for the TBI as yet.
- *
- */
-
-#include	"titan_mdio.h"
-
-#define MDIO_DEBUG
-
-/*
- * Local constants
- */
-#define MAX_CLKA            1023
-#define MAX_PHY_DEV         31
-#define MAX_PHY_REG         31
-#define WRITEADDRS_OPCODE   0x0
-#define	READ_OPCODE	    0x2
-#define WRITE_OPCODE        0x1
-#define MAX_MDIO_POLL       100
-
-/*
- * Titan MDIO and SCMB registers
- */
-#define TITAN_GE_SCMB_CONTROL                0x01c0  /* SCMB Control */
-#define TITAN_GE_SCMB_CLKA	             0x01c4  /* SCMB Clock A */
-#define TITAN_GE_MDIO_COMMAND                0x01d0  /* MDIO Command */
-#define TITAN_GE_MDIO_DEVICE_PORT_ADDRESS    0x01d4  /* MDIO Device and Port addrs */
-#define TITAN_GE_MDIO_DATA                   0x01d8  /* MDIO Data */
-#define TITAN_GE_MDIO_INTERRUPTS             0x01dC  /* MDIO Interrupts */
-
-/*
- * Function to poll the MDIO
- */
-static int titan_ge_mdio_poll(void)
-{
-	int	i, val;
-
-	for (i = 0; i < MAX_MDIO_POLL; i++) {
-		val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
-
-		if (!(val & 0x8000))
-			return TITAN_GE_MDIO_GOOD;
-	}
-
-	return TITAN_GE_MDIO_ERROR;
-}
-
-
-/*
- * Initialize and configure the MDIO
- */
-int titan_ge_mdio_setup(titan_ge_mdio_config *titan_mdio)
-{
-	unsigned long	val;
-
-	/* Reset the SCMB and program into MDIO mode*/
-	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CONTROL, 0x9000);
-	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CONTROL, 0x1000);
-
-	/* CLK A */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_SCMB_CLKA);
-	val = ( (val & ~(0x03ff)) | (titan_mdio->clka & 0x03ff));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CLKA, val);
-
-	/* Preamble Suppresion */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
-	val = ( (val & ~(0x0001)) | (titan_mdio->mdio_spre & 0x0001));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
-
-	/* MDIO mode */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
-	val = ( (val & ~(0x4000)) | (titan_mdio->mdio_mode & 0x4000));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
-
-	return TITAN_GE_MDIO_GOOD;
-}
-
-/*
- * Set the PHY address in indirect mode
- */
-int titan_ge_mdio_inaddrs(int dev_addr, int reg_addr)
-{
-	volatile unsigned long	val;
-
-	/* Setup the PHY device */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
-	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
-	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
-
-	/* Write the new address */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
-	val = ( (val & ~(0x0300)) | ( (WRITEADDRS_OPCODE << 8) & 0x0300));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
-
-	return TITAN_GE_MDIO_GOOD;
-}
-
-/*
- * Read the MDIO register. This is what the individual parametes mean:
- *
- * dev_addr : PHY ID
- * reg_addr : register offset
- *
- * See the spec for the Titan MAC. We operate in the Direct Mode.
- */
-
-#define MAX_RETRIES	2
-
-int titan_ge_mdio_read(int dev_addr, int reg_addr, unsigned int *pdata)
-{
-	volatile unsigned long	val;
-	int retries = 0;
-
-	/* Setup the PHY device */
-
-again:
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
-	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
-	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
-	val |= 0x4000;
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
-
-	udelay(30);
-
-	/* Issue the read command */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
-	val = ( (val & ~(0x0300)) | ( (READ_OPCODE << 8) & 0x0300));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
-
-	udelay(30);
-
-	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
-		return TITAN_GE_MDIO_ERROR;
-
-	*pdata = (unsigned int)TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DATA);
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_INTERRUPTS);
-
-	udelay(30);
-
-	if (val & 0x2) {
-		if (retries == MAX_RETRIES)
-			return TITAN_GE_MDIO_ERROR;
-		else {
-			retries++;
-			goto again;
-		}
-	}
-
-	return TITAN_GE_MDIO_GOOD;
-}
-
-/*
- * Write to the MDIO register
- *
- * dev_addr : PHY ID
- * reg_addr : register that needs to be written to
- *
- */
-int titan_ge_mdio_write(int dev_addr, int reg_addr, unsigned int data)
-{
-	volatile unsigned long	val;
-
-	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
-		return TITAN_GE_MDIO_ERROR;
-
-	/* Setup the PHY device */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
-	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
-	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
-	val |= 0x4000;
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
-
-	udelay(30);
-
-	/* Setup the data to write */
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DATA, data);
-
-	udelay(30);
-
-	/* Issue the write command */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
-	val = ( (val & ~(0x0300)) | ( (WRITE_OPCODE << 8) & 0x0300));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
-
-	udelay(30);
-
-	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
-		return TITAN_GE_MDIO_ERROR;
-
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_INTERRUPTS);
-	if (val & 0x2)
-		return TITAN_GE_MDIO_ERROR;
-
-	return TITAN_GE_MDIO_GOOD;
-}
-
diff -Naur linux-3.3-rc2/drivers/net/ethernet/pmc-sierra/titan_mdio.h wm8505-3.3rc2/drivers/net/ethernet/pmc-sierra/titan_mdio.h
--- linux-3.3-rc2/drivers/net/ethernet/pmc-sierra/titan_mdio.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/net/ethernet/pmc-sierra/titan_mdio.h	1969-12-31 17:00:00.000000000 -0700
@@ -1,56 +0,0 @@
-/*
- * MDIO used to interact with the PHY when using GMII/MII
- */
-#ifndef _TITAN_MDIO_H
-#define _TITAN_MDIO_H
-
-#include <linux/netdevice.h>
-#include <linux/workqueue.h>
-#include <linux/delay.h>
-#include "titan_ge.h"
-
-
-#define	TITAN_GE_MDIO_ERROR	(-9000)
-#define	TITAN_GE_MDIO_GOOD	0
-
-#define	TITAN_GE_MDIO_BASE		titan_ge_base
-
-#define	TITAN_GE_MDIO_READ(offset)	\
-	*(volatile u32 *)(titan_ge_base + (offset))
-
-#define	TITAN_GE_MDIO_WRITE(offset, data)	\
-	*(volatile u32 *)(titan_ge_base + (offset)) = (data)
-
-
-/* GMII specific registers */
-#define	TITAN_GE_MARVEL_PHY_ID		0x00
-#define	TITAN_PHY_AUTONEG_ADV		0x04
-#define	TITAN_PHY_LP_ABILITY		0x05
-#define	TITAN_GE_MDIO_MII_CTRL		0x09
-#define	TITAN_GE_MDIO_MII_EXTENDED	0x0f
-#define	TITAN_GE_MDIO_PHY_CTRL		0x10
-#define	TITAN_GE_MDIO_PHY_STATUS	0x11
-#define	TITAN_GE_MDIO_PHY_IE		0x12
-#define	TITAN_GE_MDIO_PHY_IS		0x13
-#define	TITAN_GE_MDIO_PHY_LED		0x18
-#define	TITAN_GE_MDIO_PHY_LED_OVER	0x19
-#define	PHY_ANEG_TIME_WAIT		45	/* 45 seconds wait time */
-
-/*
- * MDIO Config Structure
- */
-typedef struct {
-	unsigned int		clka;
-	int			mdio_spre;
-	int			mdio_mode;
-} titan_ge_mdio_config;
-
-/*
- * Function Prototypes
- */
-int titan_ge_mdio_setup(titan_ge_mdio_config *);
-int titan_ge_mdio_inaddrs(int, int);
-int titan_ge_mdio_read(int, int, unsigned int *);
-int titan_ge_mdio_write(int, int, unsigned int);
-
-#endif /* _TITAN_MDIO_H */
diff -Naur linux-3.3-rc2/drivers/net/ethernet/via/Kconfig wm8505-3.3rc2/drivers/net/ethernet/via/Kconfig
--- linux-3.3-rc2/drivers/net/ethernet/via/Kconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/net/ethernet/via/Kconfig	2012-02-06 12:27:43.000000000 -0700
@@ -5,7 +5,7 @@
 config NET_VENDOR_VIA
 	bool "VIA devices"
 	default y
-	depends on PCI
+	depends on PCI || ARCH_VT8500
 	---help---
 	  If you have a network (Ethernet) card belonging to this class, say Y
 	  and read the Ethernet-HOWTO, available from
@@ -20,7 +20,7 @@
 
 config VIA_RHINE
 	tristate "VIA Rhine support"
-	depends on PCI
+	depends on PCI || ARCH_VT8500
 	select CRC32
 	select NET_CORE
 	select MII
@@ -45,7 +45,7 @@
 
 config VIA_VELOCITY
 	tristate "VIA Velocity support"
-	depends on PCI
+	depends on PCI || ARCH_VT8500
 	select CRC32
 	select CRC_CCITT
 	select NET_CORE
diff -Naur linux-3.3-rc2/drivers/net/ethernet/via/via-rhine.c wm8505-3.3rc2/drivers/net/ethernet/via/via-rhine.c
--- linux-3.3-rc2/drivers/net/ethernet/via/via-rhine.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/net/ethernet/via/via-rhine.c	2012-02-06 12:27:43.000000000 -0700
@@ -94,6 +94,7 @@
 #include <linux/ioport.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
+#include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -441,6 +442,7 @@
 	dma_addr_t tx_bufs_dma;
 
 	struct pci_dev *pdev;
+	u8 is_management_adapter;
 	long pioaddr;
 	struct net_device *dev;
 	struct napi_struct napi;
@@ -863,11 +865,6 @@
 	void __iomem *ioaddr;
 	int io_size, phy_id;
 	const char *name;
-#ifdef USE_MMIO
-	int bar = 1;
-#else
-	int bar = 0;
-#endif
 
 /* when built into the kernel, we only print version if device is found */
 #ifndef MODULE
@@ -937,13 +934,14 @@
 	rp->quirks = quirks;
 	rp->pioaddr = pioaddr;
 	rp->pdev = pdev;
+	rp->is_management_adapter = pdev->revision >= VT6105M ? 1 : 0;
 	rp->msg_enable = netif_msg_init(debug, RHINE_MSG_DEFAULT);
 
 	rc = pci_request_regions(pdev, DRV_NAME);
 	if (rc)
 		goto err_out_free_netdev;
 
-	ioaddr = pci_iomap(pdev, bar, io_size);
+	ioaddr = ioremap_nocache(memaddr, io_size);
 	if (!ioaddr) {
 		rc = -EIO;
 		dev_err(&pdev->dev,
@@ -1017,7 +1015,7 @@
 	if (rp->quirks & rqRhineI)
 		dev->features |= NETIF_F_SG|NETIF_F_HW_CSUM;
 
-	if (pdev->revision >= VT6105M)
+	if (rp->is_management_adapter)
 		dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX |
 		NETIF_F_HW_VLAN_FILTER;
 
@@ -1065,7 +1063,7 @@
 	return 0;
 
 err_out_unmap:
-	pci_iounmap(pdev, ioaddr);
+	iounmap(ioaddr);
 err_out_free_res:
 	pci_release_regions(pdev);
 err_out_free_netdev:
@@ -1074,26 +1072,164 @@
 	return rc;
 }
 
+static int __devinit rhine_init_one_platform(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	struct rhine_private *rp;
+	struct resource *res;
+	void __iomem *ioaddr;
+	int ret = 0;
+	int phy_id = 1;
+	int i;
+
+	dev = alloc_etherdev(sizeof(struct rhine_private));
+	if (!dev) {
+		ret = -ENOMEM;
+		dev_err(&pdev->dev, "alloc_etherdev failed\n");
+		goto err_out;
+	}
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	rp = netdev_priv(dev);
+	rp->dev = dev;
+	rp->quirks = rqWOL | rqForceReset;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!request_mem_region(res->start, resource_size(res), pdev->name)) {
+		ret = -ENOMEM;
+		dev_err(&pdev->dev, "failed to request memory\n");
+		goto err_out_free_netdev;
+	}
+
+	ioaddr = ioremap_nocache(res->start, resource_size(res));
+	if (!ioaddr) {
+		ret = -EIO;
+		dev_err(&pdev->dev,
+			"ioremap failed for platform device");
+		goto err_out_free_res;
+	}
+
+	dev->base_addr = (unsigned long)ioaddr;
+	rp->base = ioaddr;
+
+	/* Get chip registers into a sane state */
+	rhine_power_init(dev);
+	rhine_hw_init(dev, (long)ioaddr);
+
+	for (i = 0; i < 6; i++)
+		dev->dev_addr[i] = ioread8(ioaddr + StationAddr + i);
+
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		/* Report it and use a random ethernet address instead */
+		netdev_err(dev, "Invalid MAC address: %pM\n", dev->dev_addr);
+		random_ether_addr(dev->dev_addr);
+		netdev_info(dev, "Using random MAC address: %pM\n",
+			    dev->dev_addr);
+	}
+	memcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);
+
+	/* For Rhine-I/II, phy_id is loaded from EEPROM */
+	if (!phy_id)
+		phy_id = ioread8(ioaddr + 0x6C);
+
+	dev->irq = platform_get_irq(pdev, 0);
+	if (!dev->irq) {
+		ret = -EINVAL;
+		dev_err(&pdev->dev, "failed to get platform irq\n");
+		goto err_out_unmap;
+	}
+
+	spin_lock_init(&rp->lock);
+	INIT_WORK(&rp->reset_task, rhine_reset_task);
+
+	rp->mii_if.dev = dev;
+	rp->mii_if.mdio_read = mdio_read;
+	rp->mii_if.mdio_write = mdio_write;
+	rp->mii_if.phy_id_mask = 0x1f;
+	rp->mii_if.reg_num_mask = 0x1f;
+
+	/* The chip-specific entries in the device structure. */
+	dev->netdev_ops = &rhine_netdev_ops;
+	dev->ethtool_ops = &netdev_ethtool_ops,
+	dev->watchdog_timeo = TX_TIMEOUT;
+
+	netif_napi_add(dev, &rp->napi, rhine_napipoll, 64);
+
+	if (rp->quirks & rqRhineI)
+		dev->features |= NETIF_F_SG|NETIF_F_HW_CSUM;
+
+	if (rp->is_management_adapter)
+		dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX |
+		NETIF_F_HW_VLAN_FILTER;
+
+	/* dev->name not defined before register_netdev()! */
+	ret = register_netdev(dev);
+	if (ret)
+		goto err_out_unmap;
+
+	netdev_info(dev, "VIA Rhine platform device at 0x%lx, %pM, IRQ %d\n",
+		    (unsigned long)res->start,
+		    dev->dev_addr, dev->irq);
+
+	{
+		u16 mii_cmd;
+		int mii_status = mdio_read(dev, phy_id, 1);
+		mii_cmd = mdio_read(dev, phy_id, MII_BMCR) & ~BMCR_ISOLATE;
+		mdio_write(dev, phy_id, MII_BMCR, mii_cmd);
+		if (mii_status != 0xffff && mii_status != 0x0000) {
+			rp->mii_if.advertising = mdio_read(dev, phy_id, 4);
+			netdev_info(dev,
+				    "MII PHY found at address %d, status 0x%04x advertising %04x Link %04x\n",
+				    phy_id,
+				    mii_status, rp->mii_if.advertising,
+				    mdio_read(dev, phy_id, 5));
+
+			/* set IFF_RUNNING */
+			if (mii_status & BMSR_LSTATUS)
+				netif_carrier_on(dev);
+			else
+				netif_carrier_off(dev);
+
+		}
+	}
+	rp->mii_if.phy_id = phy_id;
+	if (debug > 1 && avoid_D3)
+		netdev_info(dev, "No D3 power state at shutdown\n");
+
+	return 0;
+
+err_out_unmap:
+	iounmap(ioaddr);
+err_out_free_res:
+	release_mem_region(res->start, resource_size(res));
+err_out_free_netdev:
+	free_netdev(dev);
+err_out:
+	return ret;
+}
+
 static int alloc_ring(struct net_device* dev)
 {
 	struct rhine_private *rp = netdev_priv(dev);
 	void *ring;
 	dma_addr_t ring_dma;
 
-	ring = pci_alloc_consistent(rp->pdev,
+	ring = dma_alloc_coherent(dev->dev.parent,
 				    RX_RING_SIZE * sizeof(struct rx_desc) +
 				    TX_RING_SIZE * sizeof(struct tx_desc),
-				    &ring_dma);
+				    &ring_dma, GFP_ATOMIC);
 	if (!ring) {
 		netdev_err(dev, "Could not allocate DMA memory\n");
 		return -ENOMEM;
 	}
 	if (rp->quirks & rqRhineI) {
-		rp->tx_bufs = pci_alloc_consistent(rp->pdev,
+		rp->tx_bufs = dma_alloc_coherent(dev->dev.parent,
 						   PKT_BUF_SZ * TX_RING_SIZE,
-						   &rp->tx_bufs_dma);
+						   &rp->tx_bufs_dma,
+						   GFP_ATOMIC
+						);
 		if (rp->tx_bufs == NULL) {
-			pci_free_consistent(rp->pdev,
+			dma_free_coherent(dev->dev.parent,
 				    RX_RING_SIZE * sizeof(struct rx_desc) +
 				    TX_RING_SIZE * sizeof(struct tx_desc),
 				    ring, ring_dma);
@@ -1113,14 +1249,14 @@
 {
 	struct rhine_private *rp = netdev_priv(dev);
 
-	pci_free_consistent(rp->pdev,
+	dma_free_coherent(dev->dev.parent,
 			    RX_RING_SIZE * sizeof(struct rx_desc) +
 			    TX_RING_SIZE * sizeof(struct tx_desc),
 			    rp->rx_ring, rp->rx_ring_dma);
 	rp->tx_ring = NULL;
 
 	if (rp->tx_bufs)
-		pci_free_consistent(rp->pdev, PKT_BUF_SZ * TX_RING_SIZE,
+		dma_free_coherent(dev->dev.parent, PKT_BUF_SZ * TX_RING_SIZE,
 				    rp->tx_bufs, rp->tx_bufs_dma);
 
 	rp->tx_bufs = NULL;
@@ -1159,8 +1295,8 @@
 		skb->dev = dev;                 /* Mark as being used by this device. */
 
 		rp->rx_skbuff_dma[i] =
-			pci_map_single(rp->pdev, skb->data, rp->rx_buf_sz,
-				       PCI_DMA_FROMDEVICE);
+			dma_map_single(dev->dev.parent, skb->data, rp->rx_buf_sz,
+				       DMA_FROM_DEVICE);
 
 		rp->rx_ring[i].addr = cpu_to_le32(rp->rx_skbuff_dma[i]);
 		rp->rx_ring[i].rx_status = cpu_to_le32(DescOwn);
@@ -1178,9 +1314,9 @@
 		rp->rx_ring[i].rx_status = 0;
 		rp->rx_ring[i].addr = cpu_to_le32(0xBADF00D0); /* An invalid address. */
 		if (rp->rx_skbuff[i]) {
-			pci_unmap_single(rp->pdev,
+			dma_unmap_single(dev->dev.parent,
 					 rp->rx_skbuff_dma[i],
-					 rp->rx_buf_sz, PCI_DMA_FROMDEVICE);
+					 rp->rx_buf_sz, DMA_FROM_DEVICE);
 			dev_kfree_skb(rp->rx_skbuff[i]);
 		}
 		rp->rx_skbuff[i] = NULL;
@@ -1219,10 +1355,10 @@
 		rp->tx_ring[i].addr = cpu_to_le32(0xBADF00D0); /* An invalid address. */
 		if (rp->tx_skbuff[i]) {
 			if (rp->tx_skbuff_dma[i]) {
-				pci_unmap_single(rp->pdev,
+				dma_unmap_single(dev->dev.parent,
 						 rp->tx_skbuff_dma[i],
 						 rp->tx_skbuff[i]->len,
-						 PCI_DMA_TODEVICE);
+						 DMA_TO_DEVICE);
 			}
 			dev_kfree_skb(rp->tx_skbuff[i]);
 		}
@@ -1450,7 +1586,7 @@
 
 	rhine_set_rx_mode(dev);
 
-	if (rp->pdev->revision >= VT6105M)
+	if (rp->is_management_adapter)
 		rhine_init_cam_filter(dev);
 
 	napi_enable(&rp->napi);
@@ -1562,16 +1698,16 @@
 	void __iomem *ioaddr = rp->base;
 	int rc;
 
-	rc = request_irq(rp->pdev->irq, rhine_interrupt, IRQF_SHARED, dev->name,
+	rc = request_irq(dev->irq, rhine_interrupt, IRQF_SHARED, dev->name,
 			dev);
 	if (rc)
 		return rc;
 
-	netif_dbg(rp, ifup, dev, "%s() irq %d\n", __func__, rp->pdev->irq);
+	netif_dbg(rp, ifup, dev, "%s() irq %d\n", __func__, dev->irq);
 
 	rc = alloc_ring(dev);
 	if (rc) {
-		free_irq(rp->pdev->irq, dev);
+		free_irq(dev->irq, dev);
 		return rc;
 	}
 	alloc_rbufs(dev);
@@ -1675,8 +1811,8 @@
 						       rp->tx_bufs));
 	} else {
 		rp->tx_skbuff_dma[entry] =
-			pci_map_single(rp->pdev, skb->data, skb->len,
-				       PCI_DMA_TODEVICE);
+			dma_map_single(dev->dev.parent, skb->data, skb->len,
+				       DMA_TO_DEVICE);
 		rp->tx_ring[entry].addr = cpu_to_le32(rp->tx_skbuff_dma[entry]);
 	}
 
@@ -1797,10 +1933,10 @@
 		}
 		/* Free the original skb. */
 		if (rp->tx_skbuff_dma[entry]) {
-			pci_unmap_single(rp->pdev,
+			dma_unmap_single(dev->dev.parent,
 					 rp->tx_skbuff_dma[entry],
 					 rp->tx_skbuff[entry]->len,
-					 PCI_DMA_TODEVICE);
+					 DMA_TO_DEVICE);
 		}
 		dev_kfree_skb_irq(rp->tx_skbuff[entry]);
 		rp->tx_skbuff[entry] = NULL;
@@ -1890,19 +2026,19 @@
 			if (pkt_len < rx_copybreak)
 				skb = netdev_alloc_skb_ip_align(dev, pkt_len);
 			if (skb) {
-				pci_dma_sync_single_for_cpu(rp->pdev,
+				dma_sync_single_for_cpu(dev->dev.parent,
 							    rp->rx_skbuff_dma[entry],
 							    rp->rx_buf_sz,
-							    PCI_DMA_FROMDEVICE);
+							    DMA_FROM_DEVICE);
 
 				skb_copy_to_linear_data(skb,
 						 rp->rx_skbuff[entry]->data,
 						 pkt_len);
 				skb_put(skb, pkt_len);
-				pci_dma_sync_single_for_device(rp->pdev,
+				dma_sync_single_for_device(dev->dev.parent,
 							       rp->rx_skbuff_dma[entry],
 							       rp->rx_buf_sz,
-							       PCI_DMA_FROMDEVICE);
+							       DMA_FROM_DEVICE);
 			} else {
 				skb = rp->rx_skbuff[entry];
 				if (skb == NULL) {
@@ -1911,10 +2047,10 @@
 				}
 				rp->rx_skbuff[entry] = NULL;
 				skb_put(skb, pkt_len);
-				pci_unmap_single(rp->pdev,
+				dma_unmap_single(dev->dev.parent,
 						 rp->rx_skbuff_dma[entry],
 						 rp->rx_buf_sz,
-						 PCI_DMA_FROMDEVICE);
+						 DMA_FROM_DEVICE);
 			}
 
 			if (unlikely(desc_length & DescTag))
@@ -1943,9 +2079,9 @@
 				break;	/* Better luck next round. */
 			skb->dev = dev;	/* Mark as being used by this device. */
 			rp->rx_skbuff_dma[entry] =
-				pci_map_single(rp->pdev, skb->data,
+				dma_map_single(dev->dev.parent, skb->data,
 					       rp->rx_buf_sz,
-					       PCI_DMA_FROMDEVICE);
+					       DMA_FROM_DEVICE);
 			rp->rx_ring[entry].addr = cpu_to_le32(rp->rx_skbuff_dma[entry]);
 		}
 		rp->rx_ring[entry].rx_status = cpu_to_le32(DescOwn);
@@ -2050,7 +2186,7 @@
 		/* Too many to match, or accept all multicasts. */
 		iowrite32(0xffffffff, ioaddr + MulticastFilter0);
 		iowrite32(0xffffffff, ioaddr + MulticastFilter1);
-	} else if (rp->pdev->revision >= VT6105M) {
+	} else if (rp->is_management_adapter) {
 		int i = 0;
 		u32 mCAMmask = 0;	/* 32 mCAMs (6105M and better) */
 		netdev_for_each_mc_addr(ha, dev) {
@@ -2072,7 +2208,7 @@
 		iowrite32(mc_filter[1], ioaddr + MulticastFilter1);
 	}
 	/* enable/disable VLAN receive filtering */
-	if (rp->pdev->revision >= VT6105M) {
+	if (rp->is_management_adapter) {
 		if (dev->flags & IFF_PROMISC)
 			BYTE_REG_BITS_OFF(BCR1_VIDFR, ioaddr + PCIBusConfig1);
 		else
@@ -2224,7 +2360,7 @@
 	/* Stop the chip's Tx and Rx processes. */
 	iowrite16(CmdStop, ioaddr + ChipCmd);
 
-	free_irq(rp->pdev->irq, dev);
+	free_irq(dev->irq, dev);
 	free_rbufs(dev);
 	free_tbufs(dev);
 	free_ring(dev);
@@ -2240,7 +2376,7 @@
 
 	unregister_netdev(dev);
 
-	pci_iounmap(pdev, rp->base);
+	iounmap(rp->base);
 	pci_release_regions(pdev);
 
 	free_netdev(dev);
@@ -2248,6 +2384,22 @@
 	pci_set_drvdata(pdev, NULL);
 }
 
+static int __devexit rhine_remove_one_platform(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct rhine_private *rp = netdev_priv(dev);
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	unregister_netdev(dev);
+	iounmap(rp->base);
+	release_mem_region(res->start, resource_size(res));
+
+	free_netdev(dev);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
 static void rhine_shutdown (struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata(pdev);
@@ -2365,6 +2517,14 @@
 	.driver.pm	= RHINE_PM_OPS,
 };
 
+static struct platform_driver rhine_platform_driver = {
+	.probe		= rhine_init_one_platform,
+	.remove		= __devexit_p(rhine_remove_one_platform),
+	.driver		= {
+		.name	= DRV_NAME,
+	}
+};
+
 static struct dmi_system_id __initdata rhine_dmi_table[] = {
 	{
 		.ident = "EPIA-M",
@@ -2385,6 +2545,8 @@
 
 static int __init rhine_init(void)
 {
+	int ret = 0;
+
 /* when a module, this is printed whether or not devices are found in probe */
 #ifdef MODULE
 	pr_info("%s\n", version);
@@ -2397,13 +2559,18 @@
 	else if (avoid_D3)
 		pr_info("avoid_D3 set\n");
 
-	return pci_register_driver(&rhine_driver);
+	ret = platform_driver_register(&rhine_platform_driver);
+	if (!ret)
+		ret = pci_register_driver(&rhine_driver);
+
+	return ret;
 }
 
 
 static void __exit rhine_cleanup(void)
 {
 	pci_unregister_driver(&rhine_driver);
+	platform_driver_unregister(&rhine_platform_driver);
 }
 
 
diff -Naur linux-3.3-rc2/drivers/net/ethernet/via/via-velocity.c wm8505-3.3rc2/drivers/net/ethernet/via/via-velocity.c
--- linux-3.3-rc2/drivers/net/ethernet/via/via-velocity.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/net/ethernet/via/via-velocity.c	2012-02-06 12:27:43.000000000 -0700
@@ -76,6 +76,9 @@
 #include <linux/udp.h>
 #include <linux/crc-ccitt.h>
 #include <linux/crc32.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
 
 #include "via-velocity.h"
 
@@ -83,6 +86,15 @@
 static int velocity_nics;
 static int msglevel = MSG_LEVEL_INFO;
 
+void velocity_set_power_state(struct velocity_info *vptr, char state)
+{
+	struct mac_regs __iomem *regs = vptr->mac_regs;
+	if (vptr->bustype == BUS_PCI)
+		pci_set_power_state(vptr->pdev.pcidev, state);
+	else
+		writeb(state, (&regs->PAR[0]) + 0x154);
+}
+
 /**
  *	mac_get_cam_mask	-	Read a CAM mask
  *	@regs: register block for this velocity
@@ -385,27 +397,42 @@
 }
 
 /**
- *	velocity_remove1	-	device unplug
- *	@pdev: PCI device being removed
+ *	velocity_remove_(pci|platform)	-	device unplug
+ *	@pdev: device being removed
  *
  *	Device unload callback. Called on an unplug or on module
  *	unload for each active device that is present. Disconnects
  *	the device from the network layer and frees all the resources
  */
-static void __devexit velocity_remove1(struct pci_dev *pdev)
+static void __devexit velocity_remove1(struct net_device *dev)
 {
-	struct net_device *dev = pci_get_drvdata(pdev);
 	struct velocity_info *vptr = netdev_priv(dev);
 
 	unregister_netdev(dev);
 	iounmap(vptr->mac_regs);
-	pci_release_regions(pdev);
-	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
 	free_netdev(dev);
 
 	velocity_nics--;
 }
+#ifdef CONFIG_PCI
+static void __devexit velocity_remove_pci(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+
+	velocity_remove1(dev);
+	pci_release_regions(pdev);
+	pci_set_drvdata(pdev, NULL);
+	pci_disable_device(pdev);
+}
+#endif
+static int __devexit velocity_remove_platform(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+
+	velocity_remove1(dev);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
 
 /**
  *	velocity_set_int_opt	-	parser for integer options
@@ -1347,9 +1374,13 @@
 		velocity_soft_reset(vptr);
 		mdelay(5);
 
+#ifndef CONFIG_ARCH_VT8500
+		/* this causes a hang on VT8500 machines;
+		 * perhaps there is no EEPROM */
 		mac_eeprom_reload(regs);
 		for (i = 0; i < 6; i++)
 			writeb(vptr->dev->dev_addr[i], &(regs->PAR[i]));
+#endif
 
 		/*
 		 *	clear Pre_ACPI bit.
@@ -1454,21 +1485,23 @@
 	struct velocity_opt *opt = &vptr->options;
 	const unsigned int rx_ring_size = opt->numrx * sizeof(struct rx_desc);
 	const unsigned int tx_ring_size = opt->numtx * sizeof(struct tx_desc);
-	struct pci_dev *pdev = vptr->pdev;
+	struct device *bdev = vptr->bdev;
 	dma_addr_t pool_dma;
 	void *pool;
 	unsigned int i;
+	unsigned int psize;
 
 	/*
 	 * Allocate all RD/TD rings a single pool.
 	 *
-	 * pci_alloc_consistent() fulfills the requirement for 64 bytes
+	 * dma_alloc_coherent() fulfills the requirement for 64 bytes
 	 * alignment
 	 */
-	pool = pci_alloc_consistent(pdev, tx_ring_size * vptr->tx.numq +
-				    rx_ring_size, &pool_dma);
+	psize = tx_ring_size * vptr->tx.numq + rx_ring_size;
+
+	pool = dma_alloc_coherent(bdev, psize, &pool_dma, GFP_ATOMIC);
 	if (!pool) {
-		dev_err(&pdev->dev, "%s : DMA memory allocation failed.\n",
+		dev_err(bdev, "%s : DMA memory allocation failed.\n",
 			vptr->dev->name);
 		return -ENOMEM;
 	}
@@ -1519,8 +1552,8 @@
 	 */
 	skb_reserve(rd_info->skb,
 			64 - ((unsigned long) rd_info->skb->data & 63));
-	rd_info->skb_dma = pci_map_single(vptr->pdev, rd_info->skb->data,
-					vptr->rx.buf_sz, PCI_DMA_FROMDEVICE);
+	rd_info->skb_dma = dma_map_single(vptr->bdev, rd_info->skb->data,
+					vptr->rx.buf_sz, DMA_FROM_DEVICE);
 
 	/*
 	 *	Fill in the descriptor to match
@@ -1583,8 +1616,8 @@
 
 		if (!rd_info->skb)
 			continue;
-		pci_unmap_single(vptr->pdev, rd_info->skb_dma, vptr->rx.buf_sz,
-				 PCI_DMA_FROMDEVICE);
+		dma_unmap_single(vptr->bdev, rd_info->skb_dma,
+				vptr->rx.buf_sz, DMA_FROM_DEVICE);
 		rd_info->skb_dma = 0;
 
 		dev_kfree_skb(rd_info->skb);
@@ -1665,7 +1698,7 @@
 	const int size = vptr->options.numrx * sizeof(struct rx_desc) +
 		vptr->options.numtx * sizeof(struct tx_desc) * vptr->tx.numq;
 
-	pci_free_consistent(vptr->pdev, size, vptr->rx.ring, vptr->rx.pool_dma);
+	dma_free_coherent(vptr->bdev, size, vptr->rx.ring, vptr->rx.pool_dma);
 }
 
 static int velocity_init_rings(struct velocity_info *vptr, int mtu)
@@ -1722,8 +1755,8 @@
 				pktlen = max_t(size_t, pktlen,
 						td->td_buf[i].size & ~TD_QUEUE);
 
-			pci_unmap_single(vptr->pdev, tdinfo->skb_dma[i],
-					le16_to_cpu(pktlen), PCI_DMA_TODEVICE);
+			dma_unmap_single(vptr->bdev, tdinfo->skb_dma[i],
+					le16_to_cpu(pktlen), DMA_TO_DEVICE);
 		}
 	}
 	dev_kfree_skb_irq(skb);
@@ -1745,8 +1778,10 @@
 	if (td_info->skb) {
 		for (i = 0; i < td_info->nskb_dma; i++) {
 			if (td_info->skb_dma[i]) {
-				pci_unmap_single(vptr->pdev, td_info->skb_dma[i],
-					td_info->skb->len, PCI_DMA_TODEVICE);
+				dma_unmap_single(vptr->bdev,
+						 td_info->skb_dma[i],
+						 td_info->skb->len,
+						 DMA_TO_DEVICE);
 				td_info->skb_dma[i] = 0;
 			}
 		}
@@ -2024,7 +2059,8 @@
  */
 static int velocity_receive_frame(struct velocity_info *vptr, int idx)
 {
-	void (*pci_action)(struct pci_dev *, dma_addr_t, size_t, int);
+	void (*action)(struct device *, dma_addr_t, size_t,
+		       enum dma_data_direction);
 	struct net_device_stats *stats = &vptr->dev->stats;
 	struct velocity_rd_info *rd_info = &(vptr->rx.info[idx]);
 	struct rx_desc *rd = &(vptr->rx.ring[idx]);
@@ -2042,8 +2078,8 @@
 
 	skb = rd_info->skb;
 
-	pci_dma_sync_single_for_cpu(vptr->pdev, rd_info->skb_dma,
-				    vptr->rx.buf_sz, PCI_DMA_FROMDEVICE);
+	dma_sync_single_for_cpu(vptr->bdev, rd_info->skb_dma,
+				    vptr->rx.buf_sz, DMA_FROM_DEVICE);
 
 	/*
 	 *	Drop frame not meeting IEEE 802.3
@@ -2056,18 +2092,18 @@
 		}
 	}
 
-	pci_action = pci_dma_sync_single_for_device;
+	action = dma_sync_single_for_device;
 
 	velocity_rx_csum(rd, skb);
 
 	if (velocity_rx_copy(&skb, pkt_len, vptr) < 0) {
 		velocity_iph_realign(vptr, skb, pkt_len);
-		pci_action = pci_unmap_single;
+		action = dma_unmap_single;
 		rd_info->skb = NULL;
 	}
 
-	pci_action(vptr->pdev, rd_info->skb_dma, vptr->rx.buf_sz,
-		   PCI_DMA_FROMDEVICE);
+	action(vptr->bdev, rd_info->skb_dma, vptr->rx.buf_sz,
+		   DMA_FROM_DEVICE);
 
 	skb_put(skb, pkt_len - 4);
 	skb->protocol = eth_type_trans(skb, vptr->dev);
@@ -2202,7 +2238,10 @@
 		__napi_schedule(&vptr->napi);
 	}
 
-	if (isr_status & (~(ISR_PRXI | ISR_PPRXI | ISR_PTXI | ISR_PPTXI)))
+	/* ISR0 seems to flag along with ISR_PRXI on VT8500 machines,
+	* spamming the error routine */
+	if (isr_status & (~(ISR_ISR3 | ISR_ISR2 | ISR_ISR1 | ISR_ISR0 |
+			ISR_PRXI | ISR_PPRXI | ISR_PTXI | ISR_PPTXI)))
 		velocity_error(vptr, isr_status);
 
 	spin_unlock(&vptr->lock);
@@ -2230,15 +2269,15 @@
 		goto out;
 
 	/* Ensure chip is running */
-	pci_set_power_state(vptr->pdev, PCI_D0);
+	velocity_set_power_state(vptr, PCI_D0);
 
 	velocity_init_registers(vptr, VELOCITY_INIT_COLD);
 
-	ret = request_irq(vptr->pdev->irq, velocity_intr, IRQF_SHARED,
+	ret = request_irq(dev->irq, velocity_intr, IRQF_SHARED,
 			  dev->name, dev);
 	if (ret < 0) {
 		/* Power down the chip */
-		pci_set_power_state(vptr->pdev, PCI_D3hot);
+		velocity_set_power_state(vptr, PCI_D3hot);
 		velocity_free_rings(vptr);
 		goto out;
 	}
@@ -2271,6 +2310,12 @@
 	mac_clear_isr(regs);
 }
 
+void velocity_shutdown_platform(struct platform_device *pdev)
+{
+	struct velocity_info *vptr = netdev_priv(platform_get_drvdata(pdev));
+	velocity_shutdown(vptr);
+}
+
 /**
  *	velocity_change_mtu	-	MTU change callback
  *	@dev: network device
@@ -2310,7 +2355,7 @@
 		}
 
 		tmp_vptr->dev = dev;
-		tmp_vptr->pdev = vptr->pdev;
+		tmp_vptr->bdev = vptr->bdev;
 		tmp_vptr->options = vptr->options;
 		tmp_vptr->tx.numq = vptr->tx.numq;
 
@@ -2410,7 +2455,7 @@
 	   saving then we need to bring the device back up to talk to it */
 
 	if (!netif_running(dev))
-		pci_set_power_state(vptr->pdev, PCI_D0);
+		velocity_set_power_state(vptr, PCI_D0);
 
 	switch (cmd) {
 	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
@@ -2423,7 +2468,7 @@
 		ret = -EOPNOTSUPP;
 	}
 	if (!netif_running(dev))
-		pci_set_power_state(vptr->pdev, PCI_D3hot);
+		velocity_set_power_state(vptr, PCI_D3hot);
 
 
 	return ret;
@@ -2492,7 +2537,7 @@
 		free_irq(dev->irq, dev);
 
 	/* Power down the chip */
-	pci_set_power_state(vptr->pdev, PCI_D3hot);
+	velocity_set_power_state(vptr, PCI_D3hot);
 
 	velocity_free_rings(vptr);
 
@@ -2548,7 +2593,8 @@
 	 *	add it to the transmit ring.
 	 */
 	tdinfo->skb = skb;
-	tdinfo->skb_dma[0] = pci_map_single(vptr->pdev, skb->data, pktlen, PCI_DMA_TODEVICE);
+	tdinfo->skb_dma[0] = dma_map_single(vptr->bdev, skb->data, pktlen,
+					    DMA_TO_DEVICE);
 	td_ptr->tdesc0.len = cpu_to_le16(pktlen);
 	td_ptr->td_buf[0].pa_low = cpu_to_le32(tdinfo->skb_dma[0]);
 	td_ptr->td_buf[0].pa_high = 0;
@@ -2558,7 +2604,7 @@
 	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 		const skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 
-		tdinfo->skb_dma[i + 1] = skb_frag_dma_map(&vptr->pdev->dev,
+		tdinfo->skb_dma[i + 1] = skb_frag_dma_map(vptr->bdev,
 							  frag, 0,
 							  skb_frag_size(frag),
 							  DMA_TO_DEVICE);
@@ -2623,20 +2669,29 @@
 
 /**
  *	velocity_init_info	-	init private data
- *	@pdev: PCI device
+ *	@pdev: PCI/platform device's dev entry
  *	@vptr: Velocity info
  *	@info: Board type
+ *	@bustype: bus type
  *
  *	Set up the initial velocity_info struct for the device that has been
  *	discovered.
  */
-static void __devinit velocity_init_info(struct pci_dev *pdev,
+static void __devinit velocity_init_info(void *pdev,
 					 struct velocity_info *vptr,
-					 const struct velocity_info_tbl *info)
+					 const struct velocity_info_tbl *info,
+					 enum velocity_bus_type bustype)
 {
 	memset(vptr, 0, sizeof(struct velocity_info));
 
-	vptr->pdev = pdev;
+	if (bustype == BUS_PCI) {
+		vptr->pdev.pcidev = (struct pci_dev *)pdev;
+		vptr->bdev = &vptr->pdev.pcidev->dev;
+	} else {
+		vptr->pdev.platdev = (struct platform_device *)pdev;
+		vptr->bdev = &vptr->pdev.platdev->dev;
+	}
+	vptr->bustype = bustype;
 	vptr->chip_id = info->chip_id;
 	vptr->tx.numq = info->txqueue;
 	vptr->multicast_limit = MCAM_SIZE;
@@ -2644,40 +2699,47 @@
 }
 
 /**
- *	velocity_get_pci_info	-	retrieve PCI info for device
+ *	velocity_get_config_info	-	retrieve bus info for device
  *	@vptr: velocity device
- *	@pdev: PCI device it matches
  *
  *	Retrieve the PCI configuration space data that interests us from
- *	the kernel PCI layer
+ *	the kernel PCI layer, or the equivalent data from the platform device
  */
-static int __devinit velocity_get_pci_info(struct velocity_info *vptr, struct pci_dev *pdev)
+static int __devinit velocity_get_config_info(struct velocity_info *vptr)
 {
-	vptr->rev_id = pdev->revision;
+	struct pci_dev *pcidev;
+	struct platform_device *platdev;
+	if (vptr->bustype == BUS_PCI) {
+		pcidev = vptr->pdev.pcidev;
+		vptr->rev_id = pcidev->revision;
+		pci_set_master(pcidev);
 
-	pci_set_master(pdev);
+		vptr->ioaddr = pci_resource_start(pcidev, 0);
+		vptr->memaddr = pci_resource_start(pcidev, 1);
 
-	vptr->ioaddr = pci_resource_start(pdev, 0);
-	vptr->memaddr = pci_resource_start(pdev, 1);
-
-	if (!(pci_resource_flags(pdev, 0) & IORESOURCE_IO)) {
-		dev_err(&pdev->dev,
+		if (!(pci_resource_flags(pcidev, 0) & IORESOURCE_IO)) {
+			dev_err(vptr->bdev,
 			   "region #0 is not an I/O resource, aborting.\n");
 		return -EINVAL;
 	}
 
-	if ((pci_resource_flags(pdev, 1) & IORESOURCE_IO)) {
-		dev_err(&pdev->dev,
+		if ((pci_resource_flags(pcidev, 1) & IORESOURCE_IO)) {
+			dev_err(vptr->bdev,
 			   "region #1 is an I/O resource, aborting.\n");
 		return -EINVAL;
 	}
 
-	if (pci_resource_len(pdev, 1) < VELOCITY_IO_SIZE) {
-		dev_err(&pdev->dev, "region #1 is too small.\n");
+		if (pci_resource_len(pcidev, 1) < VELOCITY_IO_SIZE) {
+			dev_err(vptr->bdev, "region #1 is too small.\n");
 		return -EINVAL;
 	}
-	vptr->pdev = pdev;
-
+	} else if (vptr->bustype == BUS_PLATFORM) {
+		platdev = vptr->pdev.platdev;
+		vptr->ioaddr = platdev->resource[0].start;
+		vptr->memaddr = vptr->ioaddr;
+	} else {
+		return 1;
+	}
 	return 0;
 }
 
@@ -2706,41 +2768,56 @@
 
 /**
  *	velocity_found1		-	set up discovered velocity card
- *	@pdev: PCI device
- *	@ent: PCI device table entry that matched
+ *	@pdev: device
+ *	@info: velocity_info_tbl appropriate to device
+ *	@bustype: what kind of bus it was found on
  *
  *	Configure a discovered adapter from scratch. Return a negative
  *	errno error code on failure paths.
  */
-static int __devinit velocity_found1(struct pci_dev *pdev, const struct pci_device_id *ent)
+
+static int __devinit velocity_found1(void *pdev,
+				     const struct velocity_info_tbl *info,
+				     enum velocity_bus_type bustype)
 {
 	static int first = 1;
 	struct net_device *dev;
 	int i;
 	const char *drv_string;
-	const struct velocity_info_tbl *info = &chip_info_table[ent->driver_data];
 	struct velocity_info *vptr;
 	struct mac_regs __iomem *regs;
 	int ret = -ENOMEM;
+	struct device *bdev;
+	int pci = (bustype == BUS_PCI) ? 1 : 0;
+	struct pci_dev *pcidev;
+	struct platform_device *platdev;
+
+	if (pci) {
+		pcidev = pdev;
+		bdev = &pcidev->dev;
+	} else {
+		platdev = pdev;
+		bdev = &platdev->dev;
+	}
 
 	/* FIXME: this driver, like almost all other ethernet drivers,
 	 * can support more than MAX_UNITS.
 	 */
 	if (velocity_nics >= MAX_UNITS) {
-		dev_notice(&pdev->dev, "already found %d NICs.\n",
+		dev_notice(bdev, "already found %d NICs.\n",
 			   velocity_nics);
 		return -ENODEV;
 	}
 
 	dev = alloc_etherdev(sizeof(struct velocity_info));
 	if (!dev) {
-		dev_err(&pdev->dev, "allocate net device failed.\n");
+		dev_err(bdev, "allocate net device failed.\n");
 		goto out;
 	}
 
 	/* Chain it all together */
 
-	SET_NETDEV_DEV(dev, &pdev->dev);
+	SET_NETDEV_DEV(dev, bdev);
 	vptr = netdev_priv(dev);
 
 
@@ -2752,27 +2829,40 @@
 		first = 0;
 	}
 
-	velocity_init_info(pdev, vptr, info);
+	velocity_init_info(pdev, vptr, info, bustype);
 
 	vptr->dev = dev;
 
-	ret = pci_enable_device(pdev);
+	if (pci) {
+		ret = pci_enable_device(pcidev);
 	if (ret < 0)
 		goto err_free_dev;
 
-	dev->irq = pdev->irq;
+		dev->irq = pcidev->irq;
+	} else {
+		for (i = 0; i < platdev->num_resources; i++) {
+			if (platdev->resource[i].flags == IORESOURCE_IRQ) {
+				dev->irq = platdev->resource[i].start;
+				break;
+			}
+		}
+		if (i >= platdev->num_resources)
+			goto err_disable;
+	}
 
-	ret = velocity_get_pci_info(vptr, pdev);
+	ret = velocity_get_config_info(vptr);
 	if (ret < 0) {
 		/* error message already printed */
 		goto err_disable;
 	}
 
-	ret = pci_request_regions(pdev, VELOCITY_NAME);
+	if (pci) {
+		ret = pci_request_regions(pcidev, VELOCITY_NAME);
 	if (ret < 0) {
-		dev_err(&pdev->dev, "No PCI resources.\n");
+			dev_err(bdev, "No PCI resources.\n");
 		goto err_disable;
 	}
+	}
 
 	regs = ioremap(vptr->memaddr, VELOCITY_IO_SIZE);
 	if (regs == NULL) {
@@ -2781,6 +2871,8 @@
 	}
 
 	vptr->mac_regs = regs;
+	if (!pci)
+		vptr->rev_id = readb((&regs->PAR[0]) + 0x8);
 
 	mac_wol_reset(regs);
 
@@ -2790,7 +2882,7 @@
 		dev->dev_addr[i] = readb(&regs->PAR[i]);
 
 
-	drv_string = dev_driver_string(&pdev->dev);
+	drv_string = dev_driver_string(bdev);
 
 	velocity_get_options(&vptr->options, velocity_nics, drv_string);
 
@@ -2811,7 +2903,6 @@
 
 	vptr->phy_id = MII_GET_PHY_ID(vptr->mac_regs);
 
-	dev->irq = pdev->irq;
 	dev->netdev_ops = &velocity_netdev_ops;
 	dev->ethtool_ops = &velocity_ethtool_ops;
 	netif_napi_add(dev, &vptr->napi, velocity_poll, VELOCITY_NAPI_WEIGHT);
@@ -2830,11 +2921,15 @@
 	}
 
 	velocity_print_info(vptr);
-	pci_set_drvdata(pdev, dev);
+
+	if (pci)
+		pci_set_drvdata(pcidev, dev);
+	else
+		platform_set_drvdata(platdev, dev);
 
 	/* and leave the chip powered down */
 
-	pci_set_power_state(pdev, PCI_D3hot);
+	velocity_set_power_state(vptr, PCI_D3hot);
 	velocity_nics++;
 out:
 	return ret;
@@ -2850,7 +2945,23 @@
 	goto out;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PCI
+static int __devinit velocity_probe_pci(struct pci_dev *pdev,
+					const struct pci_device_id *ent)
+{
+	const struct velocity_info_tbl *info =
+					&chip_info_table[ent->driver_data];
+
+	return velocity_found1(pdev, info, BUS_PCI);
+}
+#endif
+static int __devinit velocity_probe_platform(struct platform_device *pdev)
+{
+	const struct velocity_info_tbl *info = &chip_info_table[0];
+
+	return velocity_found1(pdev, info, BUS_PLATFORM);
+}
+
 /**
  *	wol_calc_crc		-	WOL CRC
  *	@pattern: data pattern
@@ -3007,11 +3118,24 @@
 
 }
 
-static int velocity_suspend(struct pci_dev *pdev, pm_message_t state)
+static int velocity_suspend(void *pdev, pm_message_t state,
+			    enum velocity_bus_type bustype)
 {
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct velocity_info *vptr = netdev_priv(dev);
+	struct net_device *dev;
+	struct velocity_info *vptr;
 	unsigned long flags;
+	int pci = (bustype == BUS_PCI) ? 1 : 0;
+	struct pci_dev *pcidev;
+	struct platform_device *platdev;
+	if (pci) {
+		pcidev = pdev;
+		dev = pci_get_drvdata(pcidev);
+	} else {
+		platdev = pdev;
+		dev = platform_get_drvdata(platdev);
+	}
+
+	vptr = netdev_priv(dev);
 
 	if (!netif_running(vptr->dev))
 		return 0;
@@ -3019,25 +3143,41 @@
 	netif_device_detach(vptr->dev);
 
 	spin_lock_irqsave(&vptr->lock, flags);
-	pci_save_state(pdev);
+
+	if (pci)
+		pci_save_state(pcidev);
 
 	if (vptr->flags & VELOCITY_FLAGS_WOL_ENABLED) {
 		velocity_get_ip(vptr);
 		velocity_save_context(vptr, &vptr->context);
 		velocity_shutdown(vptr);
 		velocity_set_wol(vptr);
-		pci_enable_wake(pdev, PCI_D3hot, 1);
-		pci_set_power_state(pdev, PCI_D3hot);
+		if (pci)
+			pci_enable_wake(pcidev, PCI_D3hot, 1);
+		velocity_set_power_state(vptr, PCI_D3hot);
 	} else {
 		velocity_save_context(vptr, &vptr->context);
 		velocity_shutdown(vptr);
-		pci_disable_device(pdev);
-		pci_set_power_state(pdev, pci_choose_state(pdev, state));
+		if (pci)
+			pci_disable_device(pcidev);
+		velocity_set_power_state(vptr,
+					 vel_choose_state(vptr->bdev, state));
 	}
 
 	spin_unlock_irqrestore(&vptr->lock, flags);
 	return 0;
 }
+#ifdef CONFIG_PCI
+static int velocity_suspend_pci(struct pci_dev *pdev, pm_message_t state)
+{
+	return velocity_suspend(pdev, state, BUS_PCI);
+}
+#endif
+static int velocity_suspend_platform(struct platform_device *pdev,
+				     pm_message_t state)
+{
+	return velocity_suspend(pdev, state, BUS_PLATFORM);
+}
 
 /**
  *	velocity_restore_context	-	restore registers
@@ -3074,19 +3214,33 @@
 		writeb(*((u8 *) (context->mac_reg + i)), ptr + i);
 }
 
-static int velocity_resume(struct pci_dev *pdev)
+static int velocity_resume(void *pdev, enum velocity_bus_type bustype)
 {
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct velocity_info *vptr = netdev_priv(dev);
+	struct net_device *dev;
+	struct velocity_info *vptr;
 	unsigned long flags;
 	int i;
+	int pci = (bustype == BUS_PCI) ? 1 : 0;
+	struct pci_dev *pcidev;
+	struct platform_device *platdev;
+
+	if (pci) {
+		pcidev = pdev;
+		dev = pci_get_drvdata(pcidev);
+	} else {
+		platdev = pdev;
+		dev = platform_get_drvdata(platdev);
+	}
+	vptr = netdev_priv(dev);
 
 	if (!netif_running(vptr->dev))
 		return 0;
 
-	pci_set_power_state(pdev, PCI_D0);
-	pci_enable_wake(pdev, 0, 0);
-	pci_restore_state(pdev);
+	velocity_set_power_state(vptr, PCI_D0);
+	if (pci) {
+		pci_enable_wake(pcidev, 0, 0);
+		pci_restore_state(pcidev);
+	}
 
 	mac_wol_reset(vptr->mac_regs);
 
@@ -3108,23 +3262,50 @@
 
 	return 0;
 }
+#ifdef CONFIG_PCI
+static int velocity_resume_pci(struct pci_dev *pdev)
+{
+	return velocity_resume(pdev, BUS_PCI);
+}
 #endif
 
+static int velocity_resume_platform(struct platform_device *pdev)
+{
+	return velocity_resume(pdev, BUS_PLATFORM);
+}
+
 /*
  *	Definition for our device driver. The PCI layer interface
  *	uses this to handle all our card discover and plugging
  */
+#ifdef CONFIG_PCI
 static struct pci_driver velocity_driver = {
 	.name		= VELOCITY_NAME,
 	.id_table	= velocity_id_table,
-	.probe		= velocity_found1,
-	.remove		= __devexit_p(velocity_remove1),
+	.probe		= velocity_probe_pci,
+	.remove		= __devexit_p(velocity_remove_pci),
 #ifdef CONFIG_PM
-	.suspend	= velocity_suspend,
-	.resume		= velocity_resume,
+	.suspend	= velocity_suspend_pci,
+	.resume		= velocity_resume_pci,
 #endif
 };
+#endif
+
+static struct platform_driver velocity_driver = {
+	.probe		= velocity_probe_platform,
+	.remove		= __devexit_p(velocity_remove_platform),
+	.shutdown	= velocity_shutdown_platform,
+#ifdef CONFIG_PM
+	  .suspend	= velocity_suspend_platform,
+	  .resume	= velocity_resume_platform,
+#endif
+	.driver = {
+		.name	= "velocity",
+		.owner	= THIS_MODULE,
+	}
+};
 
+MODULE_ALIAS("platform:velocity");
 
 /**
  *	velocity_ethtool_up	-	pre hook for ethtool
@@ -3137,7 +3318,7 @@
 {
 	struct velocity_info *vptr = netdev_priv(dev);
 	if (!netif_running(dev))
-		pci_set_power_state(vptr->pdev, PCI_D0);
+		velocity_set_power_state(vptr, PCI_D0);
 	return 0;
 }
 
@@ -3152,7 +3333,7 @@
 {
 	struct velocity_info *vptr = netdev_priv(dev);
 	if (!netif_running(dev))
-		pci_set_power_state(vptr->pdev, PCI_D3hot);
+		velocity_set_power_state(vptr, PCI_D3hot);
 }
 
 static int velocity_get_settings(struct net_device *dev,
@@ -3272,9 +3453,12 @@
 static void velocity_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
 {
 	struct velocity_info *vptr = netdev_priv(dev);
-	strlcpy(info->driver, VELOCITY_NAME, sizeof(info->driver));
-	strlcpy(info->version, VELOCITY_VERSION, sizeof(info->version));
-	strlcpy(info->bus_info, pci_name(vptr->pdev), sizeof(info->bus_info));
+	if (vptr->bustype == BUS_PCI)
+		strcpy(info->bus_info, pci_name(vptr->pdev.pcidev));
+	else
+		strcpy(info->bus_info, "platform");
+	strcpy(info->driver, VELOCITY_NAME);
+	strcpy(info->version, VELOCITY_VERSION);
 }
 
 static void velocity_ethtool_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
@@ -3567,9 +3751,14 @@
 	int ret;
 
 	velocity_register_notifier();
+#ifdef CONFIG_PCI
 	ret = pci_register_driver(&velocity_driver);
 	if (ret < 0)
 		velocity_unregister_notifier();
+#endif
+	ret = platform_driver_register(&velocity_driver);
+	if (ret < 0)
+		velocity_unregister_notifier();
 	return ret;
 }
 
@@ -3584,7 +3773,10 @@
 static void __exit velocity_cleanup_module(void)
 {
 	velocity_unregister_notifier();
+#ifdef CONFIG_PCI
 	pci_unregister_driver(&velocity_driver);
+#endif
+	platform_driver_unregister(&velocity_driver);
 }
 
 module_init(velocity_init_module);
diff -Naur linux-3.3-rc2/drivers/net/ethernet/via/via-velocity.h wm8505-3.3rc2/drivers/net/ethernet/via/via-velocity.h
--- linux-3.3-rc2/drivers/net/ethernet/via/via-velocity.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/net/ethernet/via/via-velocity.h	2012-02-06 12:27:43.000000000 -0700
@@ -1433,9 +1433,38 @@
 
 #define GET_RD_BY_IDX(vptr, idx)   (vptr->rd_ring[idx])
 
+static inline char vel_choose_state(struct device *dev, pm_message_t state)
+{
+	switch (state.event) {
+	case PM_EVENT_ON:
+		return PCI_D0;
+	case PM_EVENT_FREEZE:
+	case PM_EVENT_PRETHAW:
+		/* REVISIT both freeze and pre-thaw "should" use D0 */
+	case PM_EVENT_SUSPEND:
+	case PM_EVENT_HIBERNATE:
+		return PCI_D3hot;
+	default:
+		dev_info(dev, "unrecognized suspend event %d\n",
+			state.event);
+		BUG();
+	}
+	return PCI_D0;
+}
+
+enum velocity_bus_type {
+	BUS_PCI,
+	BUS_PLATFORM
+};
+
 struct velocity_info {
-	struct pci_dev *pdev;
+	union {
+		struct pci_dev *pcidev;
+		struct platform_device *platdev;
+	} pdev;
+	struct device *bdev;
 	struct net_device *dev;
+	enum velocity_bus_type bustype;
 
 	unsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
 	u8 ip_addr[4];
@@ -1575,5 +1604,4 @@
 	writew(vptr->options.numrx, &regs->RBRDU);
 }
 
-
 #endif
diff -Naur linux-3.3-rc2/drivers/rtc/rtc-vt8500.c wm8505-3.3rc2/drivers/rtc/rtc-vt8500.c
--- linux-3.3-rc2/drivers/rtc/rtc-vt8500.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/rtc/rtc-vt8500.c	2012-02-06 12:27:43.000000000 -0700
@@ -118,7 +118,7 @@
 	tm->tm_min = bcd2bin((time & TIME_MIN_MASK) >> TIME_MIN_S);
 	tm->tm_hour = bcd2bin((time & TIME_HOUR_MASK) >> TIME_HOUR_S);
 	tm->tm_mday = bcd2bin(date & DATE_DAY_MASK);
-	tm->tm_mon = bcd2bin((date & DATE_MONTH_MASK) >> DATE_MONTH_S);
+	tm->tm_mon = bcd2bin((date & DATE_MONTH_MASK) >> DATE_MONTH_S) - 1;
 	tm->tm_year = bcd2bin((date & DATE_YEAR_MASK) >> DATE_YEAR_S)
 			+ ((date >> DATE_CENTURY_S) & 1 ? 200 : 100);
 	tm->tm_wday = (time & TIME_DOW_MASK) >> TIME_DOW_S;
@@ -137,7 +137,7 @@
 	}
 
 	writel((bin2bcd(tm->tm_year - 100) << DATE_YEAR_S)
-		| (bin2bcd(tm->tm_mon) << DATE_MONTH_S)
+		| (bin2bcd(tm->tm_mon + 1) << DATE_MONTH_S)
 		| (bin2bcd(tm->tm_mday)),
 		vt8500_rtc->regbase + VT8500_RTC_DS);
 	writel((bin2bcd(tm->tm_wday) << TIME_DOW_S)
diff -Naur linux-3.3-rc2/drivers/staging/media/go7007/go7007-usb.c wm8505-3.3rc2/drivers/staging/media/go7007/go7007-usb.c
--- linux-3.3-rc2/drivers/staging/media/go7007/go7007-usb.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/staging/media/go7007/go7007-usb.c	2012-02-06 12:27:43.000000000 -0700
@@ -1279,3 +1279,4 @@
 };
 
 module_usb_driver(go7007_usb_driver);
+MODULE_LICENSE("GPL v2");
diff -Naur linux-3.3-rc2/drivers/tty/vt/vt_ioctl.c wm8505-3.3rc2/drivers/tty/vt/vt_ioctl.c
--- linux-3.3-rc2/drivers/tty/vt/vt_ioctl.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/tty/vt/vt_ioctl.c	2012-02-06 12:27:43.000000000 -0700
@@ -1463,7 +1463,6 @@
 	if (!perm && op->op != KD_FONT_OP_GET)
 		return -EPERM;
 	op->data = compat_ptr(((struct compat_console_font_op *)op)->data);
-	op->flags |= KD_FONT_FLAG_OLD;
 	i = con_font_op(vc, op);
 	if (i)
 		return i;
diff -Naur linux-3.3-rc2/drivers/usb/host/Kconfig wm8505-3.3rc2/drivers/usb/host/Kconfig
--- linux-3.3-rc2/drivers/usb/host/Kconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/usb/host/Kconfig	2012-02-06 12:27:43.000000000 -0700
@@ -411,7 +411,7 @@
 
 config USB_UHCI_HCD
 	tristate "UHCI HCD (most Intel and VIA) support"
-	depends on USB && (PCI || SPARC_LEON)
+	depends on USB && (PCI || SPARC_LEON || ARCH_VT8500)
 	---help---
 	  The Universal Host Controller Interface is a standard by Intel for
 	  accessing the USB hardware in the PC (which is also called the USB
@@ -429,7 +429,7 @@
 config USB_UHCI_SUPPORT_NON_PCI_HC
 	bool
 	depends on USB_UHCI_HCD
-	default y if SPARC_LEON
+	default y if (SPARC_LEON || ARCH_VT8500)
 
 config USB_UHCI_BIG_ENDIAN_MMIO
 	bool
diff -Naur linux-3.3-rc2/drivers/usb/host/uhci-hcd.c wm8505-3.3rc2/drivers/usb/host/uhci-hcd.c
--- linux-3.3-rc2/drivers/usb/host/uhci-hcd.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/usb/host/uhci-hcd.c	2012-02-06 12:27:43.000000000 -0700
@@ -844,6 +844,12 @@
 #define PLATFORM_DRIVER		uhci_grlib_driver
 #endif
 
+#ifdef CONFIG_ARCH_VT8500
+#include "uhci-vt8500.c"
+#define PLATFORM_DRIVER		uhci_vt8500_driver
+#endif
+
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER)
 #error "missing bus glue for uhci-hcd"
 #endif
diff -Naur linux-3.3-rc2/drivers/usb/host/uhci-vt8500.c wm8505-3.3rc2/drivers/usb/host/uhci-vt8500.c
--- linux-3.3-rc2/drivers/usb/host/uhci-vt8500.c	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/drivers/usb/host/uhci-vt8500.c	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,149 @@
+/*
+ * UHCI HCD (Host Controller Driver) for VT8500/WM8505/WM8650
+ *
+ * Copyright (c) 2011 Tony Prisk <linux@prisktech.co.nz>
+ *
+ * This file is based on uhci-grlib.c
+ */
+
+#include <linux/platform_device.h>
+
+static int uhci_vt8500_init(struct usb_hcd *hcd)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+
+	uhci->rh_numports = uhci_count_ports(hcd);
+
+	/* Set up pointers to to generic functions */
+	uhci->reset_hc = uhci_generic_reset_hc;
+	uhci->check_and_reset_hc = uhci_generic_check_and_reset_hc;
+
+	/* No special actions need to be taken for the functions below */
+	uhci->configure_hc = NULL;
+	uhci->resume_detect_interrupts_are_broken = NULL;
+	uhci->global_suspend_mode_is_broken = NULL;
+
+	/* Reset if the controller isn't already safely quiescent. */
+	check_and_reset_hc(uhci);
+	return 0;
+}
+
+static const struct hc_driver uhci_vt8500_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"WonderMedia UHCI Host Controller",
+	.hcd_priv_size =	sizeof(struct uhci_hcd),
+
+	/* Generic hardware linkage */
+	.irq =			uhci_irq,
+	.flags =		HCD_MEMORY | HCD_USB11,
+
+	/* Basic lifecycle operations */
+	.reset =		uhci_vt8500_init,
+	.start =		uhci_start,
+#ifdef CONFIG_PM
+	.pci_suspend =		NULL,
+	.pci_resume =		NULL,
+	.bus_suspend =		uhci_rh_suspend,
+	.bus_resume =		uhci_rh_resume,
+#endif
+	.stop =			uhci_stop,
+
+	.urb_enqueue =		uhci_urb_enqueue,
+	.urb_dequeue =		uhci_urb_dequeue,
+
+	.endpoint_disable =	uhci_hcd_endpoint_disable,
+	.get_frame_number =	uhci_hcd_get_frame_number,
+
+	.hub_status_data =	uhci_hub_status_data,
+	.hub_control =		uhci_hub_control,
+};
+
+
+static int __devinit uhci_hcd_vt8500_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	struct uhci_hcd	*uhci;
+	struct resource *res;
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	hcd = usb_create_hcd(&uhci_vt8500_hc_driver, &pdev->dev,
+			pdev->name);
+	if (!hcd)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = resource_size(res);
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		printk(KERN_ERR "%s: request_mem_region failed\n", __FILE__);
+		ret = -EBUSY;
+		goto err_rmr;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		printk(KERN_ERR "%s: ioremap failed\n", __FILE__);
+		ret = -ENOMEM;
+		goto err_irq;
+	}
+
+	uhci = hcd_to_uhci(hcd);
+
+	uhci->regs = hcd->regs;
+
+	ret = usb_add_hcd(hcd, pdev->resource[1].start, IRQF_DISABLED | IRQF_SHARED);
+	if (ret)
+		goto err_uhci;
+
+	return 0;
+
+err_uhci:
+	iounmap(hcd->regs);
+err_irq:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err_rmr:
+	usb_put_hcd(hcd);
+
+	return ret;
+}
+
+static int uhci_hcd_vt8500_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+/* Make sure the controller is quiescent and that we're not using it
+ * any more.  This is mainly for the benefit of programs which, like kexec,
+ * expect the hardware to be idle: not doing DMA or generating IRQs.
+ *
+ * This routine may be called in a damaged or failing kernel.  Hence we
+ * do not acquire the spinlock before shutting down the controller.
+ */
+static void uhci_hcd_vt8500_shutdown(struct platform_device *op)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(&op->dev);
+
+	uhci_hc_died(hcd_to_uhci(hcd));
+}
+
+static struct platform_driver uhci_vt8500_driver = {
+	.probe		= uhci_hcd_vt8500_probe,
+	.remove		= uhci_hcd_vt8500_remove,
+	.shutdown	= uhci_hcd_vt8500_shutdown,
+	.driver = {
+		.name = "vt8500-uhci",
+		.owner = THIS_MODULE,
+	},
+};
diff -Naur linux-3.3-rc2/drivers/video/wm8505fb.c wm8505-3.3rc2/drivers/video/wm8505fb.c
--- linux-3.3-rc2/drivers/video/wm8505fb.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/drivers/video/wm8505fb.c	2012-02-06 12:27:43.000000000 -0700
@@ -59,8 +59,8 @@
 	writel(fbi->fb.fix.smem_start, fbi->regbase + WMT_GOVR_FBADDR);
 	writel(fbi->fb.fix.smem_start, fbi->regbase + WMT_GOVR_FBADDR1);
 
-	/* Set in-memory picture format to RGB 32bpp */
-	writel(0x1c,		       fbi->regbase + WMT_GOVR_COLORSPACE);
+	/* Set in-memory picture format to RGB */
+	writel(0x31c,		       fbi->regbase + WMT_GOVR_COLORSPACE);
 	writel(1,		       fbi->regbase + WMT_GOVR_COLORSPACE1);
 
 	/* Virtual buffer size */
@@ -127,6 +127,18 @@
 		info->var.blue.msb_right = 0;
 		info->fix.visual = FB_VISUAL_TRUECOLOR;
 		info->fix.line_length = info->var.xres_virtual << 2;
+	} else if (info->var.bits_per_pixel == 16) {
+		info->var.red.offset = 11;
+		info->var.red.length = 5;
+		info->var.red.msb_right = 0;
+		info->var.green.offset = 5;
+		info->var.green.length = 6;
+		info->var.green.msb_right = 0;
+		info->var.blue.offset = 0;
+		info->var.blue.length = 5;
+		info->var.blue.msb_right = 0;
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+		info->fix.line_length = info->var.xres_virtual << 1;
 	}
 
 	wm8505fb_set_timing(info);
diff -Naur linux-3.3-rc2/fs/ceph/caps.c wm8505-3.3rc2/fs/ceph/caps.c
--- linux-3.3-rc2/fs/ceph/caps.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/fs/ceph/caps.c	2012-02-06 12:27:43.000000000 -0700
@@ -641,10 +641,10 @@
 	unsigned long ttl;
 	u32 gen;
 
-	spin_lock(&cap->session->s_cap_lock);
+	spin_lock(&cap->session->s_gen_ttl_lock);
 	gen = cap->session->s_cap_gen;
 	ttl = cap->session->s_cap_ttl;
-	spin_unlock(&cap->session->s_cap_lock);
+	spin_unlock(&cap->session->s_gen_ttl_lock);
 
 	if (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {
 		dout("__cap_is_valid %p cap %p issued %s "
diff -Naur linux-3.3-rc2/fs/ceph/dir.c wm8505-3.3rc2/fs/ceph/dir.c
--- linux-3.3-rc2/fs/ceph/dir.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/fs/ceph/dir.c	2012-02-06 12:27:43.000000000 -0700
@@ -975,10 +975,10 @@
 	di = ceph_dentry(dentry);
 	if (di->lease_session) {
 		s = di->lease_session;
-		spin_lock(&s->s_cap_lock);
+		spin_lock(&s->s_gen_ttl_lock);
 		gen = s->s_cap_gen;
 		ttl = s->s_cap_ttl;
-		spin_unlock(&s->s_cap_lock);
+		spin_unlock(&s->s_gen_ttl_lock);
 
 		if (di->lease_gen == gen &&
 		    time_before(jiffies, dentry->d_time) &&
diff -Naur linux-3.3-rc2/fs/ceph/mds_client.c wm8505-3.3rc2/fs/ceph/mds_client.c
--- linux-3.3-rc2/fs/ceph/mds_client.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/fs/ceph/mds_client.c	2012-02-06 12:27:43.000000000 -0700
@@ -262,6 +262,7 @@
 	/* trace */
 	ceph_decode_32_safe(&p, end, len, bad);
 	if (len > 0) {
+		ceph_decode_need(&p, end, len, bad);
 		err = parse_reply_info_trace(&p, p+len, info, features);
 		if (err < 0)
 			goto out_bad;
@@ -270,6 +271,7 @@
 	/* extra */
 	ceph_decode_32_safe(&p, end, len, bad);
 	if (len > 0) {
+		ceph_decode_need(&p, end, len, bad);
 		err = parse_reply_info_extra(&p, p+len, info, features);
 		if (err < 0)
 			goto out_bad;
@@ -398,9 +400,11 @@
 	s->s_con.peer_name.type = CEPH_ENTITY_TYPE_MDS;
 	s->s_con.peer_name.num = cpu_to_le64(mds);
 
-	spin_lock_init(&s->s_cap_lock);
+	spin_lock_init(&s->s_gen_ttl_lock);
 	s->s_cap_gen = 0;
 	s->s_cap_ttl = 0;
+
+	spin_lock_init(&s->s_cap_lock);
 	s->s_renew_requested = 0;
 	s->s_renew_seq = 0;
 	INIT_LIST_HEAD(&s->s_caps);
@@ -2326,10 +2330,10 @@
 	case CEPH_SESSION_STALE:
 		pr_info("mds%d caps went stale, renewing\n",
 			session->s_mds);
-		spin_lock(&session->s_cap_lock);
+		spin_lock(&session->s_gen_ttl_lock);
 		session->s_cap_gen++;
 		session->s_cap_ttl = 0;
-		spin_unlock(&session->s_cap_lock);
+		spin_unlock(&session->s_gen_ttl_lock);
 		send_renew_caps(mdsc, session);
 		break;
 
diff -Naur linux-3.3-rc2/fs/ceph/mds_client.h wm8505-3.3rc2/fs/ceph/mds_client.h
--- linux-3.3-rc2/fs/ceph/mds_client.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/fs/ceph/mds_client.h	2012-02-06 12:27:43.000000000 -0700
@@ -117,10 +117,13 @@
 	void             *s_authorizer_buf, *s_authorizer_reply_buf;
 	size_t            s_authorizer_buf_len, s_authorizer_reply_buf_len;
 
-	/* protected by s_cap_lock */
-	spinlock_t        s_cap_lock;
+	/* protected by s_gen_ttl_lock */
+	spinlock_t        s_gen_ttl_lock;
 	u32               s_cap_gen;  /* inc each time we get mds stale msg */
 	unsigned long     s_cap_ttl;  /* when session caps expire */
+
+	/* protected by s_cap_lock */
+	spinlock_t        s_cap_lock;
 	struct list_head  s_caps;     /* all caps issued by this session */
 	int               s_nr_caps, s_trim_caps;
 	int               s_num_cap_releases;
diff -Naur linux-3.3-rc2/fs/ceph/xattr.c wm8505-3.3rc2/fs/ceph/xattr.c
--- linux-3.3-rc2/fs/ceph/xattr.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/fs/ceph/xattr.c	2012-02-06 12:27:43.000000000 -0700
@@ -111,8 +111,10 @@
 }
 
 static struct ceph_vxattr_cb ceph_file_vxattrs[] = {
+	{ true, "ceph.file.layout", ceph_vxattrcb_layout},
+	/* The following extended attribute name is deprecated */
 	{ true, "ceph.layout", ceph_vxattrcb_layout},
-	{ NULL, NULL }
+	{ true, NULL, NULL }
 };
 
 static struct ceph_vxattr_cb *ceph_inode_vxattrs(struct inode *inode)
diff -Naur linux-3.3-rc2/fs/jffs2/erase.c wm8505-3.3rc2/fs/jffs2/erase.c
--- linux-3.3-rc2/fs/jffs2/erase.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/fs/jffs2/erase.c	2012-02-06 12:27:43.000000000 -0700
@@ -335,7 +335,7 @@
 	void *ebuf;
 	uint32_t ofs;
 	size_t retlen;
-	int ret = -EIO;
+	int ret;
 	unsigned long *wordebuf;
 
 	ret = mtd_point(c->mtd, jeb->offset, c->sector_size, &retlen,
diff -Naur linux-3.3-rc2/fs/logfs/dev_mtd.c wm8505-3.3rc2/fs/logfs/dev_mtd.c
--- linux-3.3-rc2/fs/logfs/dev_mtd.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/fs/logfs/dev_mtd.c	2012-02-06 12:27:43.000000000 -0700
@@ -152,9 +152,6 @@
 	filler_t *filler = logfs_mtd_readpage;
 	struct mtd_info *mtd = super->s_mtd;
 
-	if (!mtd_can_have_bb(mtd))
-		return NULL;
-
 	*ofs = 0;
 	while (mtd_block_isbad(mtd, *ofs)) {
 		*ofs += mtd->erasesize;
@@ -172,9 +169,6 @@
 	filler_t *filler = logfs_mtd_readpage;
 	struct mtd_info *mtd = super->s_mtd;
 
-	if (!mtd_can_have_bb(mtd))
-		return NULL;
-
 	*ofs = mtd->size - mtd->erasesize;
 	while (mtd_block_isbad(mtd, *ofs)) {
 		*ofs -= mtd->erasesize;
diff -Naur linux-3.3-rc2/fs/proc/base.c wm8505-3.3rc2/fs/proc/base.c
--- linux-3.3-rc2/fs/proc/base.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/fs/proc/base.c	2012-02-06 12:27:43.000000000 -0700
@@ -198,26 +198,6 @@
 	return result;
 }
 
-static struct mm_struct *mm_access(struct task_struct *task, unsigned int mode)
-{
-	struct mm_struct *mm;
-	int err;
-
-	err =  mutex_lock_killable(&task->signal->cred_guard_mutex);
-	if (err)
-		return ERR_PTR(err);
-
-	mm = get_task_mm(task);
-	if (mm && mm != current->mm &&
-			!ptrace_may_access(task, mode)) {
-		mmput(mm);
-		mm = ERR_PTR(-EACCES);
-	}
-	mutex_unlock(&task->signal->cred_guard_mutex);
-
-	return mm;
-}
-
 struct mm_struct *mm_for_maps(struct task_struct *task)
 {
 	return mm_access(task, PTRACE_MODE_READ);
@@ -711,6 +691,13 @@
 	if (IS_ERR(mm))
 		return PTR_ERR(mm);
 
+	if (mm) {
+		/* ensure this mm_struct can't be freed */
+		atomic_inc(&mm->mm_count);
+		/* but do not pin its memory */
+		mmput(mm);
+	}
+
 	/* OK to pass negative loff_t, we can catch out-of-range */
 	file->f_mode |= FMODE_UNSIGNED_OFFSET;
 	file->private_data = mm;
@@ -718,57 +705,13 @@
 	return 0;
 }
 
-static ssize_t mem_read(struct file * file, char __user * buf,
-			size_t count, loff_t *ppos)
+static ssize_t mem_rw(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos, int write)
 {
-	int ret;
-	char *page;
-	unsigned long src = *ppos;
 	struct mm_struct *mm = file->private_data;
-
-	if (!mm)
-		return 0;
-
-	page = (char *)__get_free_page(GFP_TEMPORARY);
-	if (!page)
-		return -ENOMEM;
-
-	ret = 0;
- 
-	while (count > 0) {
-		int this_len, retval;
-
-		this_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;
-		retval = access_remote_vm(mm, src, page, this_len, 0);
-		if (!retval) {
-			if (!ret)
-				ret = -EIO;
-			break;
-		}
-
-		if (copy_to_user(buf, page, retval)) {
-			ret = -EFAULT;
-			break;
-		}
- 
-		ret += retval;
-		src += retval;
-		buf += retval;
-		count -= retval;
-	}
-	*ppos = src;
-
-	free_page((unsigned long) page);
-	return ret;
-}
-
-static ssize_t mem_write(struct file * file, const char __user *buf,
-			 size_t count, loff_t *ppos)
-{
-	int copied;
+	unsigned long addr = *ppos;
+	ssize_t copied;
 	char *page;
-	unsigned long dst = *ppos;
-	struct mm_struct *mm = file->private_data;
 
 	if (!mm)
 		return 0;
@@ -778,31 +721,54 @@
 		return -ENOMEM;
 
 	copied = 0;
+	if (!atomic_inc_not_zero(&mm->mm_users))
+		goto free;
+
 	while (count > 0) {
-		int this_len, retval;
+		int this_len = min_t(int, count, PAGE_SIZE);
 
-		this_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;
-		if (copy_from_user(page, buf, this_len)) {
+		if (write && copy_from_user(page, buf, this_len)) {
 			copied = -EFAULT;
 			break;
 		}
-		retval = access_remote_vm(mm, dst, page, this_len, 1);
-		if (!retval) {
+
+		this_len = access_remote_vm(mm, addr, page, this_len, write);
+		if (!this_len) {
 			if (!copied)
 				copied = -EIO;
 			break;
 		}
-		copied += retval;
-		buf += retval;
-		dst += retval;
-		count -= retval;			
+
+		if (!write && copy_to_user(buf, page, this_len)) {
+			copied = -EFAULT;
+			break;
+		}
+
+		buf += this_len;
+		addr += this_len;
+		copied += this_len;
+		count -= this_len;
 	}
-	*ppos = dst;
+	*ppos = addr;
 
+	mmput(mm);
+free:
 	free_page((unsigned long) page);
 	return copied;
 }
 
+static ssize_t mem_read(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	return mem_rw(file, buf, count, ppos, 0);
+}
+
+static ssize_t mem_write(struct file *file, const char __user *buf,
+			 size_t count, loff_t *ppos)
+{
+	return mem_rw(file, (char __user*)buf, count, ppos, 1);
+}
+
 loff_t mem_lseek(struct file *file, loff_t offset, int orig)
 {
 	switch (orig) {
@@ -822,8 +788,8 @@
 static int mem_release(struct inode *inode, struct file *file)
 {
 	struct mm_struct *mm = file->private_data;
-
-	mmput(mm);
+	if (mm)
+		mmdrop(mm);
 	return 0;
 }
 
diff -Naur linux-3.3-rc2/include/linux/gpio_keys.h wm8505-3.3rc2/include/linux/gpio_keys.h
--- linux-3.3-rc2/include/linux/gpio_keys.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/include/linux/gpio_keys.h	2012-02-06 12:27:43.000000000 -0700
@@ -1,6 +1,8 @@
 #ifndef _GPIO_KEYS_H
 #define _GPIO_KEYS_H
 
+struct device;
+
 struct gpio_keys_button {
 	/* Configuration parameters */
 	unsigned int code;	/* input event code (KEY_*, SW_*) */
diff -Naur linux-3.3-rc2/include/linux/mpi.h wm8505-3.3rc2/include/linux/mpi.h
--- linux-3.3-rc2/include/linux/mpi.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/include/linux/mpi.h	2012-02-06 12:27:43.000000000 -0700
@@ -57,8 +57,6 @@
 
 typedef struct gcry_mpi *MPI;
 
-#define MPI_NULL NULL
-
 #define mpi_get_nlimbs(a)     ((a)->nlimbs)
 #define mpi_is_neg(a)	      ((a)->sign)
 
diff -Naur linux-3.3-rc2/include/linux/mtd/mtd.h wm8505-3.3rc2/include/linux/mtd/mtd.h
--- linux-3.3-rc2/include/linux/mtd/mtd.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/include/linux/mtd/mtd.h	2012-02-06 12:27:43.000000000 -0700
@@ -427,9 +427,7 @@
 
 static inline int mtd_suspend(struct mtd_info *mtd)
 {
-	if (!mtd->suspend)
-		return -EOPNOTSUPP;
-	return mtd->suspend(mtd);
+	return mtd->suspend ? mtd->suspend(mtd) : 0;
 }
 
 static inline void mtd_resume(struct mtd_info *mtd)
@@ -489,7 +487,7 @@
 
 static inline int mtd_can_have_bb(const struct mtd_info *mtd)
 {
-	return 0;
+	return !!mtd->block_isbad;
 }
 
 	/* Kernel-side ioctl definitions */
diff -Naur linux-3.3-rc2/include/linux/perf_event.h wm8505-3.3rc2/include/linux/perf_event.h
--- linux-3.3-rc2/include/linux/perf_event.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/include/linux/perf_event.h	2012-02-06 12:27:43.000000000 -0700
@@ -587,6 +587,7 @@
 	u64				sample_period;
 	u64				last_period;
 	local64_t			period_left;
+	u64                             interrupts_seq;
 	u64				interrupts;
 
 	u64				freq_time_stamp;
diff -Naur linux-3.3-rc2/include/linux/pm_qos.h wm8505-3.3rc2/include/linux/pm_qos.h
--- linux-3.3-rc2/include/linux/pm_qos.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/include/linux/pm_qos.h	2012-02-06 12:27:43.000000000 -0700
@@ -110,7 +110,19 @@
 			{ return; }
 
 static inline int pm_qos_request(int pm_qos_class)
-			{ return 0; }
+{
+	switch (pm_qos_class) {
+	case PM_QOS_CPU_DMA_LATENCY:
+		return PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE;
+	case PM_QOS_NETWORK_LATENCY:
+		return PM_QOS_NETWORK_LAT_DEFAULT_VALUE;
+	case PM_QOS_NETWORK_THROUGHPUT:
+		return PM_QOS_NETWORK_THROUGHPUT_DEFAULT_VALUE;
+	default:
+		return PM_QOS_DEFAULT_VALUE;
+	}
+}
+
 static inline int pm_qos_add_notifier(int pm_qos_class,
 				      struct notifier_block *notifier)
 			{ return 0; }
diff -Naur linux-3.3-rc2/include/linux/sched.h wm8505-3.3rc2/include/linux/sched.h
--- linux-3.3-rc2/include/linux/sched.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/include/linux/sched.h	2012-02-06 12:27:43.000000000 -0700
@@ -2259,6 +2259,12 @@
 extern void mmput(struct mm_struct *);
 /* Grab a reference to a task's mm, if it is not already going away */
 extern struct mm_struct *get_task_mm(struct task_struct *task);
+/*
+ * Grab a reference to a task's mm, if it is not already going away
+ * and ptrace_may_access with the mode parameter passed to it
+ * succeeds.
+ */
+extern struct mm_struct *mm_access(struct task_struct *task, unsigned int mode);
 /* Remove the current tasks stale references to the old mm_struct */
 extern void mm_release(struct task_struct *, struct mm_struct *);
 /* Allocate a new mm structure and copy contents from tsk->mm */
diff -Naur linux-3.3-rc2/include/linux/sh_dma.h wm8505-3.3rc2/include/linux/sh_dma.h
--- linux-3.3-rc2/include/linux/sh_dma.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/include/linux/sh_dma.h	2012-02-06 12:27:43.000000000 -0700
@@ -70,6 +70,7 @@
 	unsigned int needs_tend_set:1;
 	unsigned int no_dmars:1;
 	unsigned int chclr_present:1;
+	unsigned int slave_only:1;
 };
 
 /* DMA register */
diff -Naur linux-3.3-rc2/include/sound/core.h wm8505-3.3rc2/include/sound/core.h
--- linux-3.3-rc2/include/sound/core.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/include/sound/core.h	2012-02-06 12:27:43.000000000 -0700
@@ -417,6 +417,7 @@
 #define gameport_get_port_data(gp) (gp)->port_data
 #endif
 
+#ifdef CONFIG_PCI
 /* PCI quirk list helper */
 struct snd_pci_quirk {
 	unsigned short subvendor;	/* PCI subvendor ID */
@@ -456,5 +457,6 @@
 const struct snd_pci_quirk *
 snd_pci_quirk_lookup_id(u16 vendor, u16 device,
 			const struct snd_pci_quirk *list);
+#endif
 
 #endif /* __SOUND_CORE_H */
diff -Naur linux-3.3-rc2/kernel/events/core.c wm8505-3.3rc2/kernel/events/core.c
--- linux-3.3-rc2/kernel/events/core.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/kernel/events/core.c	2012-02-06 12:27:43.000000000 -0700
@@ -2300,6 +2300,9 @@
 	return div64_u64(dividend, divisor);
 }
 
+static DEFINE_PER_CPU(int, perf_throttled_count);
+static DEFINE_PER_CPU(u64, perf_throttled_seq);
+
 static void perf_adjust_period(struct perf_event *event, u64 nsec, u64 count)
 {
 	struct hw_perf_event *hwc = &event->hw;
@@ -2325,16 +2328,29 @@
 	}
 }
 
-static void perf_ctx_adjust_freq(struct perf_event_context *ctx, u64 period)
+/*
+ * combine freq adjustment with unthrottling to avoid two passes over the
+ * events. At the same time, make sure, having freq events does not change
+ * the rate of unthrottling as that would introduce bias.
+ */
+static void perf_adjust_freq_unthr_context(struct perf_event_context *ctx,
+					   int needs_unthr)
 {
 	struct perf_event *event;
 	struct hw_perf_event *hwc;
-	u64 interrupts, now;
+	u64 now, period = TICK_NSEC;
 	s64 delta;
 
-	if (!ctx->nr_freq)
+	/*
+	 * only need to iterate over all events iff:
+	 * - context have events in frequency mode (needs freq adjust)
+	 * - there are events to unthrottle on this cpu
+	 */
+	if (!(ctx->nr_freq || needs_unthr))
 		return;
 
+	raw_spin_lock(&ctx->lock);
+
 	list_for_each_entry_rcu(event, &ctx->event_list, event_entry) {
 		if (event->state != PERF_EVENT_STATE_ACTIVE)
 			continue;
@@ -2344,13 +2360,8 @@
 
 		hwc = &event->hw;
 
-		interrupts = hwc->interrupts;
-		hwc->interrupts = 0;
-
-		/*
-		 * unthrottle events on the tick
-		 */
-		if (interrupts == MAX_INTERRUPTS) {
+		if (needs_unthr && hwc->interrupts == MAX_INTERRUPTS) {
+			hwc->interrupts = 0;
 			perf_log_throttle(event, 1);
 			event->pmu->start(event, 0);
 		}
@@ -2358,14 +2369,26 @@
 		if (!event->attr.freq || !event->attr.sample_freq)
 			continue;
 
-		event->pmu->read(event);
+		/*
+		 * stop the event and update event->count
+		 */
+		event->pmu->stop(event, PERF_EF_UPDATE);
+
 		now = local64_read(&event->count);
 		delta = now - hwc->freq_count_stamp;
 		hwc->freq_count_stamp = now;
 
+		/*
+		 * restart the event
+		 * reload only if value has changed
+		 */
 		if (delta > 0)
 			perf_adjust_period(event, period, delta);
+
+		event->pmu->start(event, delta > 0 ? PERF_EF_RELOAD : 0);
 	}
+
+	raw_spin_unlock(&ctx->lock);
 }
 
 /*
@@ -2388,16 +2411,13 @@
  */
 static void perf_rotate_context(struct perf_cpu_context *cpuctx)
 {
-	u64 interval = (u64)cpuctx->jiffies_interval * TICK_NSEC;
 	struct perf_event_context *ctx = NULL;
-	int rotate = 0, remove = 1, freq = 0;
+	int rotate = 0, remove = 1;
 
 	if (cpuctx->ctx.nr_events) {
 		remove = 0;
 		if (cpuctx->ctx.nr_events != cpuctx->ctx.nr_active)
 			rotate = 1;
-		if (cpuctx->ctx.nr_freq)
-			freq = 1;
 	}
 
 	ctx = cpuctx->task_ctx;
@@ -2405,37 +2425,26 @@
 		remove = 0;
 		if (ctx->nr_events != ctx->nr_active)
 			rotate = 1;
-		if (ctx->nr_freq)
-			freq = 1;
 	}
 
-	if (!rotate && !freq)
+	if (!rotate)
 		goto done;
 
 	perf_ctx_lock(cpuctx, cpuctx->task_ctx);
 	perf_pmu_disable(cpuctx->ctx.pmu);
 
-	if (freq) {
-		perf_ctx_adjust_freq(&cpuctx->ctx, interval);
-		if (ctx)
-			perf_ctx_adjust_freq(ctx, interval);
-	}
-
-	if (rotate) {
-		cpu_ctx_sched_out(cpuctx, EVENT_FLEXIBLE);
-		if (ctx)
-			ctx_sched_out(ctx, cpuctx, EVENT_FLEXIBLE);
-
-		rotate_ctx(&cpuctx->ctx);
-		if (ctx)
-			rotate_ctx(ctx);
+	cpu_ctx_sched_out(cpuctx, EVENT_FLEXIBLE);
+	if (ctx)
+		ctx_sched_out(ctx, cpuctx, EVENT_FLEXIBLE);
+
+	rotate_ctx(&cpuctx->ctx);
+	if (ctx)
+		rotate_ctx(ctx);
 
-		perf_event_sched_in(cpuctx, ctx, current);
-	}
+	perf_event_sched_in(cpuctx, ctx, current);
 
 	perf_pmu_enable(cpuctx->ctx.pmu);
 	perf_ctx_unlock(cpuctx, cpuctx->task_ctx);
-
 done:
 	if (remove)
 		list_del_init(&cpuctx->rotation_list);
@@ -2445,10 +2454,22 @@
 {
 	struct list_head *head = &__get_cpu_var(rotation_list);
 	struct perf_cpu_context *cpuctx, *tmp;
+	struct perf_event_context *ctx;
+	int throttled;
 
 	WARN_ON(!irqs_disabled());
 
+	__this_cpu_inc(perf_throttled_seq);
+	throttled = __this_cpu_xchg(perf_throttled_count, 0);
+
 	list_for_each_entry_safe(cpuctx, tmp, head, rotation_list) {
+		ctx = &cpuctx->ctx;
+		perf_adjust_freq_unthr_context(ctx, throttled);
+
+		ctx = cpuctx->task_ctx;
+		if (ctx)
+			perf_adjust_freq_unthr_context(ctx, throttled);
+
 		if (cpuctx->jiffies_interval == 1 ||
 				!(jiffies % cpuctx->jiffies_interval))
 			perf_rotate_context(cpuctx);
@@ -4509,6 +4530,7 @@
 {
 	int events = atomic_read(&event->event_limit);
 	struct hw_perf_event *hwc = &event->hw;
+	u64 seq;
 	int ret = 0;
 
 	/*
@@ -4518,14 +4540,20 @@
 	if (unlikely(!is_sampling_event(event)))
 		return 0;
 
-	if (unlikely(hwc->interrupts >= max_samples_per_tick)) {
-		if (throttle) {
+	seq = __this_cpu_read(perf_throttled_seq);
+	if (seq != hwc->interrupts_seq) {
+		hwc->interrupts_seq = seq;
+		hwc->interrupts = 1;
+	} else {
+		hwc->interrupts++;
+		if (unlikely(throttle
+			     && hwc->interrupts >= max_samples_per_tick)) {
+			__this_cpu_inc(perf_throttled_count);
 			hwc->interrupts = MAX_INTERRUPTS;
 			perf_log_throttle(event, 0);
 			ret = 1;
 		}
-	} else
-		hwc->interrupts++;
+	}
 
 	if (event->attr.freq) {
 		u64 now = perf_clock();
diff -Naur linux-3.3-rc2/kernel/exit.c wm8505-3.3rc2/kernel/exit.c
--- linux-3.3-rc2/kernel/exit.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/kernel/exit.c	2012-02-06 12:27:43.000000000 -0700
@@ -1038,6 +1038,22 @@
 	if (tsk->nr_dirtied)
 		__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);
 	exit_rcu();
+
+	/*
+	 * The setting of TASK_RUNNING by try_to_wake_up() may be delayed
+	 * when the following two conditions become true.
+	 *   - There is race condition of mmap_sem (It is acquired by
+	 *     exit_mm()), and
+	 *   - SMI occurs before setting TASK_RUNINNG.
+	 *     (or hypervisor of virtual machine switches to other guest)
+	 *  As a result, we may become TASK_RUNNING after becoming TASK_DEAD
+	 *
+	 * To avoid it, we have to wait for releasing tsk->pi_lock which
+	 * is held by try_to_wake_up()
+	 */
+	smp_mb();
+	raw_spin_unlock_wait(&tsk->pi_lock);
+
 	/* causes final put_task_struct in finish_task_switch(). */
 	tsk->state = TASK_DEAD;
 	tsk->flags |= PF_NOFREEZE;	/* tell freezer to ignore us */
diff -Naur linux-3.3-rc2/kernel/fork.c wm8505-3.3rc2/kernel/fork.c
--- linux-3.3-rc2/kernel/fork.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/kernel/fork.c	2012-02-06 12:27:43.000000000 -0700
@@ -647,6 +647,26 @@
 }
 EXPORT_SYMBOL_GPL(get_task_mm);
 
+struct mm_struct *mm_access(struct task_struct *task, unsigned int mode)
+{
+	struct mm_struct *mm;
+	int err;
+
+	err =  mutex_lock_killable(&task->signal->cred_guard_mutex);
+	if (err)
+		return ERR_PTR(err);
+
+	mm = get_task_mm(task);
+	if (mm && mm != current->mm &&
+			!ptrace_may_access(task, mode)) {
+		mmput(mm);
+		mm = ERR_PTR(-EACCES);
+	}
+	mutex_unlock(&task->signal->cred_guard_mutex);
+
+	return mm;
+}
+
 /* Please note the differences between mmput and mm_release.
  * mmput is called whenever we stop holding onto a mm_struct,
  * error success whatever.
diff -Naur linux-3.3-rc2/kernel/kprobes.c wm8505-3.3rc2/kernel/kprobes.c
--- linux-3.3-rc2/kernel/kprobes.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/kernel/kprobes.c	2012-02-06 12:27:43.000000000 -0700
@@ -1673,8 +1673,12 @@
 		ri->rp = rp;
 		ri->task = current;
 
-		if (rp->entry_handler && rp->entry_handler(ri, regs))
+		if (rp->entry_handler && rp->entry_handler(ri, regs)) {
+			raw_spin_lock_irqsave(&rp->lock, flags);
+			hlist_add_head(&ri->hlist, &rp->free_instances);
+			raw_spin_unlock_irqrestore(&rp->lock, flags);
 			return 0;
+		}
 
 		arch_prepare_kretprobe(ri, regs);
 
diff -Naur linux-3.3-rc2/kernel/power/power.h wm8505-3.3rc2/kernel/power/power.h
--- linux-3.3-rc2/kernel/power/power.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/kernel/power/power.h	2012-02-06 12:27:43.000000000 -0700
@@ -231,8 +231,28 @@
 #ifdef CONFIG_SUSPEND_FREEZER
 static inline int suspend_freeze_processes(void)
 {
-	int error = freeze_processes();
-	return error ? : freeze_kernel_threads();
+	int error;
+
+	error = freeze_processes();
+
+	/*
+	 * freeze_processes() automatically thaws every task if freezing
+	 * fails. So we need not do anything extra upon error.
+	 */
+	if (error)
+		goto Finish;
+
+	error = freeze_kernel_threads();
+
+	/*
+	 * freeze_kernel_threads() thaws only kernel threads upon freezing
+	 * failure. So we have to thaw the userspace tasks ourselves.
+	 */
+	if (error)
+		thaw_processes();
+
+ Finish:
+	return error;
 }
 
 static inline void suspend_thaw_processes(void)
diff -Naur linux-3.3-rc2/kernel/power/process.c wm8505-3.3rc2/kernel/power/process.c
--- linux-3.3-rc2/kernel/power/process.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/kernel/power/process.c	2012-02-06 12:27:43.000000000 -0700
@@ -143,7 +143,10 @@
 /**
  * freeze_kernel_threads - Make freezable kernel threads go to the refrigerator.
  *
- * On success, returns 0.  On failure, -errno and system is fully thawed.
+ * On success, returns 0.  On failure, -errno and only the kernel threads are
+ * thawed, so as to give a chance to the caller to do additional cleanups
+ * (if any) before thawing the userspace tasks. So, it is the responsibility
+ * of the caller to thaw the userspace tasks, when the time is right.
  */
 int freeze_kernel_threads(void)
 {
@@ -159,7 +162,7 @@
 	BUG_ON(in_atomic());
 
 	if (error)
-		thaw_processes();
+		thaw_kernel_threads();
 	return error;
 }
 
diff -Naur linux-3.3-rc2/kernel/power/user.c wm8505-3.3rc2/kernel/power/user.c
--- linux-3.3-rc2/kernel/power/user.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/kernel/power/user.c	2012-02-06 12:27:43.000000000 -0700
@@ -249,13 +249,15 @@
 		}
 		pm_restore_gfp_mask();
 		error = hibernation_snapshot(data->platform_support);
-		if (!error) {
+		if (error) {
+			thaw_kernel_threads();
+		} else {
 			error = put_user(in_suspend, (int __user *)arg);
 			if (!error && !freezer_test_done)
 				data->ready = 1;
 			if (freezer_test_done) {
 				freezer_test_done = false;
-				thaw_processes();
+				thaw_kernel_threads();
 			}
 		}
 		break;
diff -Naur linux-3.3-rc2/kernel/sched/core.c wm8505-3.3rc2/kernel/sched/core.c
--- linux-3.3-rc2/kernel/sched/core.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/kernel/sched/core.c	2012-02-06 12:27:43.000000000 -0700
@@ -74,6 +74,7 @@
 
 #include <asm/tlb.h>
 #include <asm/irq_regs.h>
+#include <asm/mutex.h>
 #ifdef CONFIG_PARAVIRT
 #include <asm/paravirt.h>
 #endif
@@ -723,9 +724,6 @@
 	p->sched_class->dequeue_task(rq, p, flags);
 }
 
-/*
- * activate_task - move a task to the runqueue.
- */
 void activate_task(struct rq *rq, struct task_struct *p, int flags)
 {
 	if (task_contributes_to_load(p))
@@ -734,9 +732,6 @@
 	enqueue_task(rq, p, flags);
 }
 
-/*
- * deactivate_task - remove a task from the runqueue.
- */
 void deactivate_task(struct rq *rq, struct task_struct *p, int flags)
 {
 	if (task_contributes_to_load(p))
@@ -4134,7 +4129,7 @@
 	on_rq = p->on_rq;
 	running = task_current(rq, p);
 	if (on_rq)
-		deactivate_task(rq, p, 0);
+		dequeue_task(rq, p, 0);
 	if (running)
 		p->sched_class->put_prev_task(rq, p);
 
@@ -4147,7 +4142,7 @@
 	if (running)
 		p->sched_class->set_curr_task(rq);
 	if (on_rq)
-		activate_task(rq, p, 0);
+		enqueue_task(rq, p, 0);
 
 	check_class_changed(rq, p, prev_class, oldprio);
 	task_rq_unlock(rq, p, &flags);
@@ -4998,9 +4993,9 @@
 	 * placed properly.
 	 */
 	if (p->on_rq) {
-		deactivate_task(rq_src, p, 0);
+		dequeue_task(rq_src, p, 0);
 		set_task_cpu(p, dest_cpu);
-		activate_task(rq_dest, p, 0);
+		enqueue_task(rq_dest, p, 0);
 		check_preempt_curr(rq_dest, p, 0);
 	}
 done:
@@ -7032,10 +7027,10 @@
 
 	on_rq = p->on_rq;
 	if (on_rq)
-		deactivate_task(rq, p, 0);
+		dequeue_task(rq, p, 0);
 	__setscheduler(rq, p, SCHED_NORMAL, 0);
 	if (on_rq) {
-		activate_task(rq, p, 0);
+		enqueue_task(rq, p, 0);
 		resched_task(rq->curr);
 	}
 
diff -Naur linux-3.3-rc2/kernel/sched/fair.c wm8505-3.3rc2/kernel/sched/fair.c
--- linux-3.3-rc2/kernel/sched/fair.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/kernel/sched/fair.c	2012-02-06 12:27:43.000000000 -0700
@@ -4866,6 +4866,15 @@
 	return;
 }
 
+static inline void clear_nohz_tick_stopped(int cpu)
+{
+	if (unlikely(test_bit(NOHZ_TICK_STOPPED, nohz_flags(cpu)))) {
+		cpumask_clear_cpu(cpu, nohz.idle_cpus_mask);
+		atomic_dec(&nohz.nr_cpus);
+		clear_bit(NOHZ_TICK_STOPPED, nohz_flags(cpu));
+	}
+}
+
 static inline void set_cpu_sd_state_busy(void)
 {
 	struct sched_domain *sd;
@@ -4904,6 +4913,12 @@
 {
 	int cpu = smp_processor_id();
 
+	/*
+	 * If this cpu is going down, then nothing needs to be done.
+	 */
+	if (!cpu_active(cpu))
+		return;
+
 	if (stop_tick) {
 		if (test_bit(NOHZ_TICK_STOPPED, nohz_flags(cpu)))
 			return;
@@ -4914,6 +4929,18 @@
 	}
 	return;
 }
+
+static int __cpuinit sched_ilb_notifier(struct notifier_block *nfb,
+					unsigned long action, void *hcpu)
+{
+	switch (action & ~CPU_TASKS_FROZEN) {
+	case CPU_DYING:
+		clear_nohz_tick_stopped(smp_processor_id());
+		return NOTIFY_OK;
+	default:
+		return NOTIFY_DONE;
+	}
+}
 #endif
 
 static DEFINE_SPINLOCK(balancing);
@@ -5070,11 +5097,7 @@
 	* busy tick after returning from idle, we will update the busy stats.
 	*/
 	set_cpu_sd_state_busy();
-	if (unlikely(test_bit(NOHZ_TICK_STOPPED, nohz_flags(cpu)))) {
-		clear_bit(NOHZ_TICK_STOPPED, nohz_flags(cpu));
-		cpumask_clear_cpu(cpu, nohz.idle_cpus_mask);
-		atomic_dec(&nohz.nr_cpus);
-	}
+	clear_nohz_tick_stopped(cpu);
 
 	/*
 	 * None are in tickless mode and hence no need for NOHZ idle load
@@ -5590,6 +5613,7 @@
 
 #ifdef CONFIG_NO_HZ
 	zalloc_cpumask_var(&nohz.idle_cpus_mask, GFP_NOWAIT);
+	cpu_notifier(sched_ilb_notifier, 0);
 #endif
 #endif /* SMP */
 
diff -Naur linux-3.3-rc2/kernel/sched/rt.c wm8505-3.3rc2/kernel/sched/rt.c
--- linux-3.3-rc2/kernel/sched/rt.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/kernel/sched/rt.c	2012-02-06 12:27:43.000000000 -0700
@@ -1587,6 +1587,11 @@
 	if (!next_task)
 		return 0;
 
+#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW
+       if (unlikely(task_running(rq, next_task)))
+               return 0;
+#endif
+
 retry:
 	if (unlikely(next_task == rq->curr)) {
 		WARN_ON(1);
diff -Naur linux-3.3-rc2/kernel/watchdog.c wm8505-3.3rc2/kernel/watchdog.c
--- linux-3.3-rc2/kernel/watchdog.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/kernel/watchdog.c	2012-02-06 12:27:43.000000000 -0700
@@ -296,7 +296,7 @@
 		if (__this_cpu_read(soft_watchdog_warn) == true)
 			return HRTIMER_RESTART;
 
-		printk(KERN_ERR "BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\n",
+		printk(KERN_EMERG "BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\n",
 			smp_processor_id(), duration,
 			current->comm, task_pid_nr(current));
 		print_modules();
diff -Naur linux-3.3-rc2/lib/bug.c wm8505-3.3rc2/lib/bug.c
--- linux-3.3-rc2/lib/bug.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/lib/bug.c	2012-02-06 12:27:43.000000000 -0700
@@ -169,7 +169,7 @@
 		return BUG_TRAP_TYPE_WARN;
 	}
 
-	printk(KERN_EMERG "------------[ cut here ]------------\n");
+	printk(KERN_DEFAULT "------------[ cut here ]------------\n");
 
 	if (file)
 		printk(KERN_CRIT "kernel BUG at %s:%u!\n",
diff -Naur linux-3.3-rc2/lib/clz_tab.c wm8505-3.3rc2/lib/clz_tab.c
--- linux-3.3-rc2/lib/clz_tab.c	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/lib/clz_tab.c	2012-02-06 12:27:43.000000000 -0700
@@ -0,0 +1,18 @@
+const unsigned char __clz_tab[] = {
+	0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
+	    5, 5, 5, 5, 5, 5, 5, 5,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	    6, 6, 6, 6, 6, 6, 6, 6,
+	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+	    7, 7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+	    7, 7, 7, 7, 7, 7, 7, 7,
+	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
+	    8, 8, 8, 8, 8, 8, 8, 8,
+	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
+	    8, 8, 8, 8, 8, 8, 8, 8,
+	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
+	    8, 8, 8, 8, 8, 8, 8, 8,
+	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
+	    8, 8, 8, 8, 8, 8, 8, 8,
+};
diff -Naur linux-3.3-rc2/lib/digsig.c wm8505-3.3rc2/lib/digsig.c
--- linux-3.3-rc2/lib/digsig.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/lib/digsig.c	2012-02-06 12:27:43.000000000 -0700
@@ -34,14 +34,9 @@
 			unsigned long  msglen,
 			unsigned long  modulus_bitlen,
 			unsigned char *out,
-			unsigned long *outlen,
-			int *is_valid)
+			unsigned long *outlen)
 {
 	unsigned long modulus_len, ps_len, i;
-	int result;
-
-	/* default to invalid packet */
-	*is_valid = 0;
 
 	modulus_len = (modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0);
 
@@ -50,39 +45,30 @@
 		return -EINVAL;
 
 	/* separate encoded message */
-	if ((msg[0] != 0x00) || (msg[1] != (unsigned char)1)) {
-		result = -EINVAL;
-		goto bail;
-	}
+	if ((msg[0] != 0x00) || (msg[1] != (unsigned char)1))
+		return -EINVAL;
 
 	for (i = 2; i < modulus_len - 1; i++)
 		if (msg[i] != 0xFF)
 			break;
 
 	/* separator check */
-	if (msg[i] != 0) {
+	if (msg[i] != 0)
 		/* There was no octet with hexadecimal value 0x00
 		to separate ps from m. */
-		result = -EINVAL;
-		goto bail;
-	}
+		return -EINVAL;
 
 	ps_len = i - 2;
 
 	if (*outlen < (msglen - (2 + ps_len + 1))) {
 		*outlen = msglen - (2 + ps_len + 1);
-		result = -EOVERFLOW;
-		goto bail;
+		return -EOVERFLOW;
 	}
 
 	*outlen = (msglen - (2 + ps_len + 1));
 	memcpy(out, &msg[2 + ps_len + 1], *outlen);
 
-	/* valid packet */
-	*is_valid = 1;
-	result    = 0;
-bail:
-	return result;
+	return 0;
 }
 
 /*
@@ -96,7 +82,7 @@
 	unsigned long len;
 	unsigned long mlen, mblen;
 	unsigned nret, l;
-	int valid, head, i;
+	int head, i;
 	unsigned char *out1 = NULL, *out2 = NULL;
 	MPI in = NULL, res = NULL, pkey[2];
 	uint8_t *p, *datap, *endp;
@@ -105,6 +91,10 @@
 
 	down_read(&key->sem);
 	ukp = key->payload.data;
+
+	if (ukp->datalen < sizeof(*pkh))
+		goto err1;
+
 	pkh = (struct pubkey_hdr *)ukp->data;
 
 	if (pkh->version != 1)
@@ -117,18 +107,23 @@
 		goto err1;
 
 	datap = pkh->mpi;
-	endp = datap + ukp->datalen;
+	endp = ukp->data + ukp->datalen;
+
+	err = -ENOMEM;
 
 	for (i = 0; i < pkh->nmpi; i++) {
 		unsigned int remaining = endp - datap;
 		pkey[i] = mpi_read_from_buffer(datap, &remaining);
+		if (!pkey[i])
+			goto err;
 		datap += remaining;
 	}
 
 	mblen = mpi_get_nbits(pkey[0]);
 	mlen = (mblen + 7)/8;
 
-	err = -ENOMEM;
+	if (mlen == 0)
+		goto err;
 
 	out1 = kzalloc(mlen, GFP_KERNEL);
 	if (!out1)
@@ -167,10 +162,9 @@
 	memset(out1, 0, head);
 	memcpy(out1 + head, p, l);
 
-	err = -EINVAL;
-	pkcs_1_v1_5_decode_emsa(out1, len, mblen, out2, &len, &valid);
+	err = pkcs_1_v1_5_decode_emsa(out1, len, mblen, out2, &len);
 
-	if (valid && len == hlen)
+	if (!err && len == hlen)
 		err = memcmp(out2, h, hlen);
 
 err:
@@ -178,8 +172,8 @@
 	mpi_free(res);
 	kfree(out1);
 	kfree(out2);
-	mpi_free(pkey[0]);
-	mpi_free(pkey[1]);
+	while (--i >= 0)
+		mpi_free(pkey[i]);
 err1:
 	up_read(&key->sem);
 
diff -Naur linux-3.3-rc2/lib/Kconfig wm8505-3.3rc2/lib/Kconfig
--- linux-3.3-rc2/lib/Kconfig	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/lib/Kconfig	2012-02-06 12:27:43.000000000 -0700
@@ -279,6 +279,9 @@
 
 	  If unsure, say N.
 
+config CLZ_TAB
+	bool
+
 config CORDIC
 	tristate "CORDIC algorithm"
 	help
@@ -287,6 +290,7 @@
 
 config MPILIB
 	tristate
+	select CLZ_TAB
 	help
 	  Multiprecision maths library from GnuPG.
 	  It is used to implement RSA digital signature verification,
diff -Naur linux-3.3-rc2/lib/Makefile wm8505-3.3rc2/lib/Makefile
--- linux-3.3-rc2/lib/Makefile	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/lib/Makefile	2012-02-06 12:27:43.000000000 -0700
@@ -121,6 +121,8 @@
 obj-$(CONFIG_MPILIB) += mpi/
 obj-$(CONFIG_SIGNATURE) += digsig.o
 
+obj-$(CONFIG_CLZ_TAB) += clz_tab.o
+
 hostprogs-y	:= gen_crc32table
 clean-files	:= crc32table.h
 
diff -Naur linux-3.3-rc2/lib/mpi/longlong.h wm8505-3.3rc2/lib/mpi/longlong.h
--- linux-3.3-rc2/lib/mpi/longlong.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/lib/mpi/longlong.h	2012-02-06 12:27:43.000000000 -0700
@@ -1200,18 +1200,40 @@
 	"r" ((USItype)(v)) \
 	: "%g1", "%g2" __AND_CLOBBER_CC)
 #define UMUL_TIME 39		/* 39 instructions */
-#endif
-#ifndef udiv_qrnnd
-#ifndef LONGLONG_STANDALONE
+/* It's quite necessary to add this much assembler for the sparc.
+   The default udiv_qrnnd (in C) is more than 10 times slower!  */
 #define udiv_qrnnd(q, r, n1, n0, d) \
-do { USItype __r; \
-	(q) = __udiv_qrnnd(&__r, (n1), (n0), (d)); \
-	(r) = __r; \
-} while (0)
-	extern USItype __udiv_qrnnd();
-#define UDIV_TIME 140
-#endif /* LONGLONG_STANDALONE */
-#endif /* udiv_qrnnd */
+  __asm__ ("! Inlined udiv_qrnnd\n\t"					\
+	   "mov	32,%%g1\n\t"						\
+	   "subcc	%1,%2,%%g0\n\t"					\
+	   "1:	bcs	5f\n\t"						\
+	   "addxcc %0,%0,%0	! shift n1n0 and a q-bit in lsb\n\t"	\
+	   "sub	%1,%2,%1	! this kills msb of n\n\t"		\
+	   "addx	%1,%1,%1	! so this can't give carry\n\t"	\
+	   "subcc	%%g1,1,%%g1\n\t"				\
+	   "2:	bne	1b\n\t"						\
+	   "subcc	%1,%2,%%g0\n\t"					\
+	   "bcs	3f\n\t"							\
+	   "addxcc %0,%0,%0	! shift n1n0 and a q-bit in lsb\n\t"	\
+	   "b		3f\n\t"						\
+	   "sub	%1,%2,%1	! this kills msb of n\n\t"		\
+	   "4:	sub	%1,%2,%1\n\t"					\
+	   "5:	addxcc	%1,%1,%1\n\t"					\
+	   "bcc	2b\n\t"							\
+	   "subcc	%%g1,1,%%g1\n\t"				\
+	   "! Got carry from n.  Subtract next step to cancel this carry.\n\t" \
+	   "bne	4b\n\t"							\
+	   "addcc	%0,%0,%0	! shift n1n0 and a 0-bit in lsb\n\t" \
+	   "sub	%1,%2,%1\n\t"						\
+	   "3:	xnor	%0,0,%0\n\t"					\
+	   "! End of inline udiv_qrnnd\n"				\
+	   : "=&r" ((USItype)(q)),					\
+	     "=&r" ((USItype)(r))					\
+	   : "r" ((USItype)(d)),					\
+	     "1" ((USItype)(n1)),					\
+	     "0" ((USItype)(n0)) : "%g1", "cc")
+#define UDIV_TIME (3+7*32)      /* 7 instructions/iteration. 32 iterations.  */
+#endif
 #endif /* __sparc__ */
 
 /***************************************
diff -Naur linux-3.3-rc2/lib/mpi/mpi-bit.c wm8505-3.3rc2/lib/mpi/mpi-bit.c
--- linux-3.3-rc2/lib/mpi/mpi-bit.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/lib/mpi/mpi-bit.c	2012-02-06 12:27:43.000000000 -0700
@@ -21,25 +21,6 @@
 #include "mpi-internal.h"
 #include "longlong.h"
 
-const unsigned char __clz_tab[] = {
-	0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
-	    5, 5, 5, 5, 5, 5, 5, 5,
-	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-	    6, 6, 6, 6, 6, 6, 6, 6,
-	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-	    7, 7, 7, 7, 7, 7, 7, 7,
-	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-	    7, 7, 7, 7, 7, 7, 7, 7,
-	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
-	    8, 8, 8, 8, 8, 8, 8, 8,
-	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
-	    8, 8, 8, 8, 8, 8, 8, 8,
-	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
-	    8, 8, 8, 8, 8, 8, 8, 8,
-	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
-	    8, 8, 8, 8, 8, 8, 8, 8,
-};
-
 #define A_LIMB_1 ((mpi_limb_t) 1)
 
 /****************
diff -Naur linux-3.3-rc2/lib/mpi/mpicoder.c wm8505-3.3rc2/lib/mpi/mpicoder.c
--- linux-3.3-rc2/lib/mpi/mpicoder.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/lib/mpi/mpicoder.c	2012-02-06 12:27:43.000000000 -0700
@@ -20,78 +20,15 @@
 
 #include "mpi-internal.h"
 
-#define DIM(v) (sizeof(v)/sizeof((v)[0]))
 #define MAX_EXTERN_MPI_BITS 16384
 
-static uint8_t asn[15] =	/* Object ID is 1.3.14.3.2.26 */
-{ 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03,
-	0x02, 0x1a, 0x05, 0x00, 0x04, 0x14
-};
-
-MPI do_encode_md(const void *sha_buffer, unsigned nbits)
-{
-	int nframe = (nbits + 7) / 8;
-	uint8_t *frame, *fr_pt;
-	int i = 0, n;
-	size_t asnlen = DIM(asn);
-	MPI a = MPI_NULL;
-
-	if (SHA1_DIGEST_LENGTH + asnlen + 4 > nframe)
-		pr_info("MPI: can't encode a %d bit MD into a %d bits frame\n",
-		       (int)(SHA1_DIGEST_LENGTH * 8), (int)nbits);
-
-	/* We encode the MD in this way:
-	 *
-	 *       0  A PAD(n bytes)   0  ASN(asnlen bytes)  MD(len bytes)
-	 *
-	 * PAD consists of FF bytes.
-	 */
-	frame = kmalloc(nframe, GFP_KERNEL);
-	if (!frame)
-		return MPI_NULL;
-	n = 0;
-	frame[n++] = 0;
-	frame[n++] = 1;		/* block type */
-	i = nframe - SHA1_DIGEST_LENGTH - asnlen - 3;
-
-	if (i <= 1) {
-		pr_info("MPI: message digest encoding failed\n");
-		kfree(frame);
-		return a;
-	}
-
-	memset(frame + n, 0xff, i);
-	n += i;
-	frame[n++] = 0;
-	memcpy(frame + n, &asn, asnlen);
-	n += asnlen;
-	memcpy(frame + n, sha_buffer, SHA1_DIGEST_LENGTH);
-	n += SHA1_DIGEST_LENGTH;
-
-	i = nframe;
-	fr_pt = frame;
-
-	if (n != nframe) {
-		printk
-		    ("MPI: message digest encoding failed, frame length is wrong\n");
-		kfree(frame);
-		return a;
-	}
-
-	a = mpi_alloc((nframe + BYTES_PER_MPI_LIMB - 1) / BYTES_PER_MPI_LIMB);
-	mpi_set_buffer(a, frame, nframe, 0);
-	kfree(frame);
-
-	return a;
-}
-
 MPI mpi_read_from_buffer(const void *xbuffer, unsigned *ret_nread)
 {
 	const uint8_t *buffer = xbuffer;
 	int i, j;
 	unsigned nbits, nbytes, nlimbs, nread = 0;
 	mpi_limb_t a;
-	MPI val = MPI_NULL;
+	MPI val = NULL;
 
 	if (*ret_nread < 2)
 		goto leave;
@@ -108,7 +45,7 @@
 	nlimbs = (nbytes + BYTES_PER_MPI_LIMB - 1) / BYTES_PER_MPI_LIMB;
 	val = mpi_alloc(nlimbs);
 	if (!val)
-		return MPI_NULL;
+		return NULL;
 	i = BYTES_PER_MPI_LIMB - nbytes % BYTES_PER_MPI_LIMB;
 	i %= BYTES_PER_MPI_LIMB;
 	val->nbits = nbits;
@@ -212,30 +149,6 @@
 EXPORT_SYMBOL_GPL(mpi_fromstr);
 
 /****************
- * Special function to get the low 8 bytes from an mpi.
- * This can be used as a keyid; KEYID is an 2 element array.
- * Return the low 4 bytes.
- */
-u32 mpi_get_keyid(const MPI a, u32 *keyid)
-{
-#if BYTES_PER_MPI_LIMB == 4
-	if (keyid) {
-		keyid[0] = a->nlimbs >= 2 ? a->d[1] : 0;
-		keyid[1] = a->nlimbs >= 1 ? a->d[0] : 0;
-	}
-	return a->nlimbs >= 1 ? a->d[0] : 0;
-#elif BYTES_PER_MPI_LIMB == 8
-	if (keyid) {
-		keyid[0] = a->nlimbs ? (u32) (a->d[0] >> 32) : 0;
-		keyid[1] = a->nlimbs ? (u32) (a->d[0] & 0xffffffff) : 0;
-	}
-	return a->nlimbs ? (u32) (a->d[0] & 0xffffffff) : 0;
-#else
-#error Make this function work with other LIMB sizes
-#endif
-}
-
-/****************
  * Return an allocated buffer with the MPI (msb first).
  * NBYTES receives the length of this buffer. Caller must free the
  * return string (This function does return a 0 byte buffer with NBYTES
diff -Naur linux-3.3-rc2/lib/mpi/mpi-div.c wm8505-3.3rc2/lib/mpi/mpi-div.c
--- linux-3.3-rc2/lib/mpi/mpi-div.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/lib/mpi/mpi-div.c	2012-02-06 12:27:43.000000000 -0700
@@ -149,6 +149,9 @@
 	mpi_ptr_t marker[5];
 	int markidx = 0;
 
+	if (!dsize)
+		return -EINVAL;
+
 	memset(marker, 0, sizeof(marker));
 
 	/* Ensure space is enough for quotient and remainder.
@@ -207,6 +210,8 @@
 		 * numerator would be gradually overwritten by the quotient limbs.  */
 		if (qp == np) {	/* Copy NP object to temporary space.  */
 			np = marker[markidx++] = mpi_alloc_limb_space(nsize);
+			if (!np)
+				goto nomem;
 			MPN_COPY(np, qp, nsize);
 		}
 	} else			/* Put quotient at top of remainder. */
diff -Naur linux-3.3-rc2/lib/mpi/mpih-div.c wm8505-3.3rc2/lib/mpi/mpih-div.c
--- linux-3.3-rc2/lib/mpi/mpih-div.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/lib/mpi/mpih-div.c	2012-02-06 12:27:43.000000000 -0700
@@ -217,6 +217,10 @@
 	case 0:
 		/* We are asked to divide by zero, so go ahead and do it!  (To make
 		   the compiler not remove this statement, return the value.)  */
+		/*
+		 * existing clients of this function have been modified
+		 * not to call it with dsize == 0, so this should not happen
+		 */
 		return 1 / dsize;
 
 	case 1:
diff -Naur linux-3.3-rc2/lib/mpi/mpi-pow.c wm8505-3.3rc2/lib/mpi/mpi-pow.c
--- linux-3.3-rc2/lib/mpi/mpi-pow.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/lib/mpi/mpi-pow.c	2012-02-06 12:27:43.000000000 -0700
@@ -59,7 +59,7 @@
 	ep = exp->d;
 
 	if (!msize)
-		msize = 1 / msize;	/* provoke a signal */
+		return -EINVAL;
 
 	if (!esize) {
 		/* Exponent is zero, result is 1 mod MOD, i.e., 1 or 0
diff -Naur linux-3.3-rc2/lib/mpi/mpiutil.c wm8505-3.3rc2/lib/mpi/mpiutil.c
--- linux-3.3-rc2/lib/mpi/mpiutil.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/lib/mpi/mpiutil.c	2012-02-06 12:27:43.000000000 -0700
@@ -58,6 +58,9 @@
 {
 	size_t len = nlimbs * sizeof(mpi_limb_t);
 
+	if (!len)
+		return NULL;
+
 	return kmalloc(len, GFP_KERNEL);
 }
 
@@ -135,7 +138,7 @@
 	size_t i;
 	MPI b;
 
-	*copied = MPI_NULL;
+	*copied = NULL;
 
 	if (a) {
 		b = mpi_alloc(a->nlimbs);
diff -Naur linux-3.3-rc2/MAINTAINERS wm8505-3.3rc2/MAINTAINERS
--- linux-3.3-rc2/MAINTAINERS	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/MAINTAINERS	2012-02-06 12:27:43.000000000 -0700
@@ -159,7 +159,7 @@
 F:	drivers/net/ethernet/realtek/r8169.c
 
 8250/16?50 (AND CLONE UARTS) SERIAL DRIVER
-M:	Greg Kroah-Hartman <gregkh@suse.de>
+M:	Greg Kroah-Hartman <gregkh@linuxfoundation.org>
 L:	linux-serial@vger.kernel.org
 W:	http://serial.sourceforge.net
 S:	Maintained
@@ -789,12 +789,6 @@
 F:	arch/arm/mach-imx/
 F:	arch/arm/plat-mxc/
 
-ARM/FREESCALE IMX51
-M:	Amit Kucheria <amit.kucheria@canonical.com>
-L:	linux-arm-kernel@lists.infradead.org (moderated for non-subscribers)
-S:	Maintained
-F:	arch/arm/mach-mx5/
-
 ARM/FREESCALE IMX6
 M:	Shawn Guo <shawn.guo@linaro.org>
 L:	linux-arm-kernel@lists.infradead.org (moderated for non-subscribers)
@@ -1783,9 +1777,9 @@
 
 CHAR and MISC DRIVERS
 M:	Arnd Bergmann <arnd@arndb.de>
-M:	Greg Kroah-Hartman <greg@kroah.com>
+M:	Greg Kroah-Hartman <gregkh@linuxfoundation.org>
 T:	git git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc.git
-S:	Maintained
+S:	Supported
 F:	drivers/char/*
 F:	drivers/misc/*
 
@@ -2320,7 +2314,7 @@
 F:	Documentation/blockdev/drbd/
 
 DRIVER CORE, KOBJECTS, DEBUGFS AND SYSFS
-M:	Greg Kroah-Hartman <gregkh@suse.de>
+M:	Greg Kroah-Hartman <gregkh@linuxfoundation.org>
 T:	git git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6.git
 S:	Supported
 F:	Documentation/kobject.txt
@@ -3992,11 +3986,11 @@
 L:	lguest@lists.ozlabs.org
 W:	http://lguest.ozlabs.org/
 S:	Odd Fixes
-F:	Documentation/virtual/lguest/
+F:	arch/x86/include/asm/lguest*.h
 F:	arch/x86/lguest/
 F:	drivers/lguest/
 F:	include/linux/lguest*.h
-F:	arch/x86/include/asm/lguest*.h
+F:	tools/lguest/
 
 LINUX FOR IBM pSERIES (RS/6000)
 M:	Paul Mackerras <paulus@au.ibm.com>
@@ -4136,7 +4130,7 @@
 W:	http://www.linux-ntfs.org/content/view/19/37/
 S:	Maintained
 F:	Documentation/ldm.txt
-F:	fs/partitions/ldm.*
+F:	block/partitions/ldm.*
 
 LogFS
 M:	Joern Engel <joern@logfs.org>
@@ -5633,7 +5627,7 @@
 S:	Supported
 F:	arch/s390/
 F:	drivers/s390/
-F:	fs/partitions/ibm.c
+F:	block/partitions/ibm.c
 F:	Documentation/s390/
 F:	Documentation/DocBook/s390*
 
@@ -6276,15 +6270,15 @@
 F:	arch/alpha/kernel/srm_env.c
 
 STABLE BRANCH
-M:	Greg Kroah-Hartman <greg@kroah.com>
+M:	Greg Kroah-Hartman <gregkh@linuxfoundation.org>
 L:	stable@vger.kernel.org
-S:	Maintained
+S:	Supported
 
 STAGING SUBSYSTEM
-M:	Greg Kroah-Hartman <gregkh@suse.de>
+M:	Greg Kroah-Hartman <gregkh@linuxfoundation.org>
 T:	git git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging.git
 L:	devel@driverdev.osuosl.org
-S:	Maintained
+S:	Supported
 F:	drivers/staging/
 
 STAGING - AGERE HERMES II and II.5 WIRELESS DRIVERS
@@ -6396,11 +6390,6 @@
 S:	Odd Fixes
 F:	drivers/staging/tidspbridge/
 
-STAGING - TRIDENT TVMASTER TMxxxx USB VIDEO CAPTURE DRIVERS
-L:	linux-media@vger.kernel.org
-S:	Odd Fixes
-F:	drivers/staging/tm6000/
-
 STAGING - USB ENE SM/MS CARD READER DRIVER
 M:	Al Cho <acho@novell.com>
 S:	Odd Fixes
@@ -6669,8 +6658,8 @@
 K:	^Subject:.*(?i)trivial
 
 TTY LAYER
-M:	Greg Kroah-Hartman <gregkh@suse.de>
-S:	Maintained
+M:	Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+S:	Supported
 T:	git git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty-2.6.git
 F:	drivers/tty/
 F:	drivers/tty/serial/serial_core.c
@@ -6958,7 +6947,7 @@
 F:	drivers/usb/serial/digi_acceleport.c
 
 USB SERIAL DRIVER
-M:	Greg Kroah-Hartman <gregkh@suse.de>
+M:	Greg Kroah-Hartman <gregkh@linuxfoundation.org>
 L:	linux-usb@vger.kernel.org
 S:	Supported
 F:	Documentation/usb/usb-serial.txt
@@ -6973,9 +6962,8 @@
 F:	drivers/usb/serial/empeg.c
 
 USB SERIAL KEYSPAN DRIVER
-M:	Greg Kroah-Hartman <greg@kroah.com>
+M:	Greg Kroah-Hartman <gregkh@linuxfoundation.org>
 L:	linux-usb@vger.kernel.org
-W:	http://www.kroah.com/linux/
 S:	Maintained
 F:	drivers/usb/serial/*keyspan*
 
@@ -7003,7 +6991,7 @@
 F:	drivers/media/video/sn9c102/
 
 USB SUBSYSTEM
-M:	Greg Kroah-Hartman <gregkh@suse.de>
+M:	Greg Kroah-Hartman <gregkh@linuxfoundation.org>
 L:	linux-usb@vger.kernel.org
 W:	http://www.linux-usb.org
 T:	git git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6.git
@@ -7090,7 +7078,7 @@
 
 USERSPACE I/O (UIO)
 M:	"Hans J. Koch" <hjk@hansjkoch.de>
-M:	Greg Kroah-Hartman <gregkh@suse.de>
+M:	Greg Kroah-Hartman <gregkh@linuxfoundation.org>
 S:	Maintained
 F:	Documentation/DocBook/uio-howto.tmpl
 F:	drivers/uio/
diff -Naur linux-3.3-rc2/Makefile wm8505-3.3rc2/Makefile
--- linux-3.3-rc2/Makefile	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/Makefile	2012-02-06 12:27:43.000000000 -0700
@@ -192,7 +192,7 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= mips
+ARCH		?= $(SUBARCH)
 CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
 
 # Architecture as present in compile.h
diff -Naur linux-3.3-rc2/mm/compaction.c wm8505-3.3rc2/mm/compaction.c
--- linux-3.3-rc2/mm/compaction.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/mm/compaction.c	2012-02-06 12:27:43.000000000 -0700
@@ -313,6 +313,19 @@
 		} else if (!locked)
 			spin_lock_irq(&zone->lru_lock);
 
+		/*
+		 * migrate_pfn does not necessarily start aligned to a
+		 * pageblock. Ensure that pfn_valid is called when moving
+		 * into a new MAX_ORDER_NR_PAGES range in case of large
+		 * memory holes within the zone
+		 */
+		if ((low_pfn & (MAX_ORDER_NR_PAGES - 1)) == 0) {
+			if (!pfn_valid(low_pfn)) {
+				low_pfn += MAX_ORDER_NR_PAGES - 1;
+				continue;
+			}
+		}
+
 		if (!pfn_valid_within(low_pfn))
 			continue;
 		nr_scanned++;
diff -Naur linux-3.3-rc2/mm/filemap.c wm8505-3.3rc2/mm/filemap.c
--- linux-3.3-rc2/mm/filemap.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/mm/filemap.c	2012-02-06 12:27:43.000000000 -0700
@@ -1400,15 +1400,12 @@
 	unsigned long seg = 0;
 	size_t count;
 	loff_t *ppos = &iocb->ki_pos;
-	struct blk_plug plug;
 
 	count = 0;
 	retval = generic_segment_checks(iov, &nr_segs, &count, VERIFY_WRITE);
 	if (retval)
 		return retval;
 
-	blk_start_plug(&plug);
-
 	/* coalesce the iovecs and go direct-to-BIO for O_DIRECT */
 	if (filp->f_flags & O_DIRECT) {
 		loff_t size;
@@ -1424,8 +1421,12 @@
 			retval = filemap_write_and_wait_range(mapping, pos,
 					pos + iov_length(iov, nr_segs) - 1);
 			if (!retval) {
+				struct blk_plug plug;
+
+				blk_start_plug(&plug);
 				retval = mapping->a_ops->direct_IO(READ, iocb,
 							iov, pos, nr_segs);
+				blk_finish_plug(&plug);
 			}
 			if (retval > 0) {
 				*ppos = pos + retval;
@@ -1481,7 +1482,6 @@
 			break;
 	}
 out:
-	blk_finish_plug(&plug);
 	return retval;
 }
 EXPORT_SYMBOL(generic_file_aio_read);
diff -Naur linux-3.3-rc2/mm/filemap_xip.c wm8505-3.3rc2/mm/filemap_xip.c
--- linux-3.3-rc2/mm/filemap_xip.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/mm/filemap_xip.c	2012-02-06 12:27:43.000000000 -0700
@@ -263,7 +263,12 @@
 							xip_pfn);
 		if (err == -ENOMEM)
 			return VM_FAULT_OOM;
-		BUG_ON(err);
+		/*
+		 * err == -EBUSY is fine, we've raced against another thread
+		 * that faulted-in the same page
+		 */
+		if (err != -EBUSY)
+			BUG_ON(err);
 		return VM_FAULT_NOPAGE;
 	} else {
 		int err, ret = VM_FAULT_OOM;
diff -Naur linux-3.3-rc2/mm/kmemleak.c wm8505-3.3rc2/mm/kmemleak.c
--- linux-3.3-rc2/mm/kmemleak.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/mm/kmemleak.c	2012-02-06 12:27:43.000000000 -0700
@@ -1036,7 +1036,7 @@
 {
 	pr_debug("%s(0x%p)\n", __func__, ptr);
 
-	if (atomic_read(&kmemleak_enabled) && ptr && !IS_ERR(ptr))
+	if (atomic_read(&kmemleak_enabled) && ptr && size && !IS_ERR(ptr))
 		add_scan_area((unsigned long)ptr, size, gfp);
 	else if (atomic_read(&kmemleak_early_log))
 		log_early(KMEMLEAK_SCAN_AREA, ptr, size, 0);
@@ -1757,6 +1757,7 @@
 
 #ifdef CONFIG_DEBUG_KMEMLEAK_DEFAULT_OFF
 	if (!kmemleak_skip_disable) {
+		atomic_set(&kmemleak_early_log, 0);
 		kmemleak_disable();
 		return;
 	}
diff -Naur linux-3.3-rc2/mm/memcontrol.c wm8505-3.3rc2/mm/memcontrol.c
--- linux-3.3-rc2/mm/memcontrol.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/mm/memcontrol.c	2012-02-06 12:27:43.000000000 -0700
@@ -776,7 +776,8 @@
 	/* threshold event is triggered in finer grain than soft limit */
 	if (unlikely(mem_cgroup_event_ratelimit(memcg,
 						MEM_CGROUP_TARGET_THRESH))) {
-		bool do_softlimit, do_numainfo;
+		bool do_softlimit;
+		bool do_numainfo __maybe_unused;
 
 		do_softlimit = mem_cgroup_event_ratelimit(memcg,
 						MEM_CGROUP_TARGET_SOFTLIMIT);
diff -Naur linux-3.3-rc2/mm/migrate.c wm8505-3.3rc2/mm/migrate.c
--- linux-3.3-rc2/mm/migrate.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/mm/migrate.c	2012-02-06 12:27:43.000000000 -0700
@@ -445,7 +445,6 @@
 	ClearPageSwapCache(page);
 	ClearPagePrivate(page);
 	set_page_private(page, 0);
-	page->mapping = NULL;
 
 	/*
 	 * If any waiters have accumulated on the new page then
@@ -667,6 +666,7 @@
 	} else {
 		if (remap_swapcache)
 			remove_migration_ptes(page, newpage);
+		page->mapping = NULL;
 	}
 
 	unlock_page(newpage);
diff -Naur linux-3.3-rc2/mm/process_vm_access.c wm8505-3.3rc2/mm/process_vm_access.c
--- linux-3.3-rc2/mm/process_vm_access.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/mm/process_vm_access.c	2012-02-06 12:27:43.000000000 -0700
@@ -298,22 +298,17 @@
 		goto free_proc_pages;
 	}
 
-	task_lock(task);
-	if (__ptrace_may_access(task, PTRACE_MODE_ATTACH)) {
-		task_unlock(task);
-		rc = -EPERM;
+	mm = mm_access(task, PTRACE_MODE_ATTACH);
+	if (!mm || IS_ERR(mm)) {
+		rc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;
+		/*
+		 * Explicitly map EACCES to EPERM as EPERM is a more a
+		 * appropriate error code for process_vw_readv/writev
+		 */
+		if (rc == -EACCES)
+			rc = -EPERM;
 		goto put_task_struct;
 	}
-	mm = task->mm;
-
-	if (!mm || (task->flags & PF_KTHREAD)) {
-		task_unlock(task);
-		rc = -EINVAL;
-		goto put_task_struct;
-	}
-
-	atomic_inc(&mm->mm_users);
-	task_unlock(task);
 
 	for (i = 0; i < riovcnt && iov_l_curr_idx < liovcnt; i++) {
 		rc = process_vm_rw_single_vec(
diff -Naur linux-3.3-rc2/myconfig wm8505-3.3rc2/myconfig
--- linux-3.3-rc2/myconfig	1969-12-31 17:00:00.000000000 -0700
+++ wm8505-3.3rc2/myconfig	2012-07-18 18:02:57.000000000 -0700
@@ -0,0 +1,1706 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.3.0-rc2 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+CONFIG_ARCH_VT8500=y
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+
+#
+# System MMU
+#
+CONFIG_VTWM_VERSION_VT8500=y
+CONFIG_VTWM_VERSION_WM8505=y
+CONFIG_VTWM_VERSION_WM8650=y
+CONFIG_MACH_BV07=y
+CONFIG_MACH_WM8505_7IN_NETBOOK=y
+CONFIG_MACH_WM8650REFBOARD=y
+
+#
+# LCD panel size
+#
+CONFIG_WMT_PANEL_800X480=y
+# CONFIG_WMT_PANEL_800X600 is not set
+# CONFIG_WMT_PANEL_1024X576 is not set
+# CONFIG_WMT_PANEL_1024X600 is not set
+# CONFIG_WMT_PANEL_1024X768 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_NR_BANKS=8
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_BQL=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_HAS_RC=y
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+# CONFIG_MTD_CHAR is not set
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_WMT=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_MISC_DEVICES is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=y
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_FARADAY=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTGMAC100 is not set
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_MARVELL=y
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8851_MLL is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_AX88796 is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_VENDOR_SEEQ=y
+# CONFIG_SEEQ8005 is not set
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_SMC91X is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_RHINE is not set
+CONFIG_VIA_VELOCITY=y
+# CONFIG_PHYLIB is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_ATH_COMMON is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_BRCMFMAC is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_P54_COMMON is not set
+CONFIG_RT2X00=y
+# CONFIG_RT2500USB is not set
+# CONFIG_RT73USB is not set
+CONFIG_RT2800USB=y
+CONFIG_RT2800USB_RT33XX=y
+CONFIG_RT2800USB_RT35XX=y
+# CONFIG_RT2800USB_RT53XX is not set
+# CONFIG_RT2800USB_UNKNOWN is not set
+CONFIG_RT2800_LIB=y
+CONFIG_RT2X00_LIB_USB=y
+CONFIG_RT2X00_LIB=y
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2X00_LIB_CRYPTO=y
+# CONFIG_RT2X00_DEBUG is not set
+# CONFIG_RTL8192CU is not set
+# CONFIG_WL1251 is not set
+# CONFIG_WL12XX_MENU is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_MWIFIEX is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_VT8500=y
+CONFIG_SERIAL_VT8500_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+
+#
+# I2C GPIO expanders:
+#
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_WMT_GE_ROPS=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_VT8500=y
+CONFIG_FB_WM8505=y
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_PLATFORM is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_PWM=y
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EHCI_MV is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_UHCI_HCD=y
+CONFIG_USB_UHCI_SUPPORT_NON_PCI_HC=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+CONFIG_MMC_WMT=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_VT8500=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_IOMMU_SUPPORT=y
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_PM_DEVFREQ is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+CONFIG_BTRFS_FS=y
+# CONFIG_BTRFS_FS_POSIX_ACL is not set
+# CONFIG_BTRFS_FS_CHECK_INTEGRITY is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_UBIFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_LL_UART_NONE=y
+# CONFIG_DEBUG_ICEDCC is not set
+CONFIG_EARLY_PRINTK=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
diff -Naur linux-3.3-rc2/net/ceph/ceph_common.c wm8505-3.3rc2/net/ceph/ceph_common.c
--- linux-3.3-rc2/net/ceph/ceph_common.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/net/ceph/ceph_common.c	2012-02-06 12:27:43.000000000 -0700
@@ -85,8 +85,6 @@
 	} else {
 		pr_info("client%lld fsid %pU\n", ceph_client_id(client), fsid);
 		memcpy(&client->fsid, fsid, sizeof(*fsid));
-		ceph_debugfs_client_init(client);
-		client->have_fsid = true;
 	}
 	return 0;
 }
diff -Naur linux-3.3-rc2/net/ceph/mon_client.c wm8505-3.3rc2/net/ceph/mon_client.c
--- linux-3.3-rc2/net/ceph/mon_client.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/net/ceph/mon_client.c	2012-02-06 12:27:43.000000000 -0700
@@ -8,8 +8,8 @@
 
 #include <linux/ceph/mon_client.h>
 #include <linux/ceph/libceph.h>
+#include <linux/ceph/debugfs.h>
 #include <linux/ceph/decode.h>
-
 #include <linux/ceph/auth.h>
 
 /*
@@ -340,8 +340,19 @@
 	client->monc.monmap = monmap;
 	kfree(old);
 
+	if (!client->have_fsid) {
+		client->have_fsid = true;
+		mutex_unlock(&monc->mutex);
+		/*
+		 * do debugfs initialization without mutex to avoid
+		 * creating a locking dependency
+		 */
+		ceph_debugfs_client_init(client);
+		goto out_unlocked;
+	}
 out:
 	mutex_unlock(&monc->mutex);
+out_unlocked:
 	wake_up_all(&client->auth_wq);
 }
 
diff -Naur linux-3.3-rc2/sound/pci/hda/hda_codec.c wm8505-3.3rc2/sound/pci/hda/hda_codec.c
--- linux-3.3-rc2/sound/pci/hda/hda_codec.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/sound/pci/hda/hda_codec.c	2012-02-06 12:27:43.000000000 -0700
@@ -1447,7 +1447,7 @@
 		for (i = 0; i < c->cvt_setups.used; i++) {
 			p = snd_array_elem(&c->cvt_setups, i);
 			if (!p->active && p->stream_tag == stream_tag &&
-			    get_wcaps_type(get_wcaps(codec, p->nid)) == type)
+			    get_wcaps_type(get_wcaps(c, p->nid)) == type)
 				p->dirty = 1;
 		}
 	}
diff -Naur linux-3.3-rc2/sound/pci/hda/hda_jack.c wm8505-3.3rc2/sound/pci/hda/hda_jack.c
--- linux-3.3-rc2/sound/pci/hda/hda_jack.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/sound/pci/hda/hda_jack.c	2012-02-06 12:27:43.000000000 -0700
@@ -282,7 +282,8 @@
 EXPORT_SYMBOL_HDA(snd_hda_jack_add_kctl);
 
 static int add_jack_kctl(struct hda_codec *codec, hda_nid_t nid,
-			 const struct auto_pin_cfg *cfg)
+			 const struct auto_pin_cfg *cfg,
+			 char *lastname, int *lastidx)
 {
 	unsigned int def_conf, conn;
 	char name[44];
@@ -298,6 +299,10 @@
 		return 0;
 
 	snd_hda_get_pin_label(codec, nid, cfg, name, sizeof(name), &idx);
+	if (!strcmp(name, lastname) && idx == *lastidx)
+		idx++;
+	strncpy(lastname, name, 44);
+	*lastidx = idx;
 	err = snd_hda_jack_add_kctl(codec, nid, name, idx);
 	if (err < 0)
 		return err;
@@ -311,41 +316,42 @@
 			   const struct auto_pin_cfg *cfg)
 {
 	const hda_nid_t *p;
-	int i, err;
+	int i, err, lastidx = 0;
+	char lastname[44] = "";
 
 	for (i = 0, p = cfg->line_out_pins; i < cfg->line_outs; i++, p++) {
-		err = add_jack_kctl(codec, *p, cfg);
+		err = add_jack_kctl(codec, *p, cfg, lastname, &lastidx);
 		if (err < 0)
 			return err;
 	}
 	for (i = 0, p = cfg->hp_pins; i < cfg->hp_outs; i++, p++) {
 		if (*p == *cfg->line_out_pins) /* might be duplicated */
 			break;
-		err = add_jack_kctl(codec, *p, cfg);
+		err = add_jack_kctl(codec, *p, cfg, lastname, &lastidx);
 		if (err < 0)
 			return err;
 	}
 	for (i = 0, p = cfg->speaker_pins; i < cfg->speaker_outs; i++, p++) {
 		if (*p == *cfg->line_out_pins) /* might be duplicated */
 			break;
-		err = add_jack_kctl(codec, *p, cfg);
+		err = add_jack_kctl(codec, *p, cfg, lastname, &lastidx);
 		if (err < 0)
 			return err;
 	}
 	for (i = 0; i < cfg->num_inputs; i++) {
-		err = add_jack_kctl(codec, cfg->inputs[i].pin, cfg);
+		err = add_jack_kctl(codec, cfg->inputs[i].pin, cfg, lastname, &lastidx);
 		if (err < 0)
 			return err;
 	}
 	for (i = 0, p = cfg->dig_out_pins; i < cfg->dig_outs; i++, p++) {
-		err = add_jack_kctl(codec, *p, cfg);
+		err = add_jack_kctl(codec, *p, cfg, lastname, &lastidx);
 		if (err < 0)
 			return err;
 	}
-	err = add_jack_kctl(codec, cfg->dig_in_pin, cfg);
+	err = add_jack_kctl(codec, cfg->dig_in_pin, cfg, lastname, &lastidx);
 	if (err < 0)
 		return err;
-	err = add_jack_kctl(codec, cfg->mono_out_pin, cfg);
+	err = add_jack_kctl(codec, cfg->mono_out_pin, cfg, lastname, &lastidx);
 	if (err < 0)
 		return err;
 	return 0;
diff -Naur linux-3.3-rc2/sound/pci/hda/patch_cirrus.c wm8505-3.3rc2/sound/pci/hda/patch_cirrus.c
--- linux-3.3-rc2/sound/pci/hda/patch_cirrus.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/sound/pci/hda/patch_cirrus.c	2012-02-06 12:27:43.000000000 -0700
@@ -988,8 +988,10 @@
 			change_cur_input(codec, !spec->automic_idx, 0);
 	} else {
 		if (present) {
-			spec->last_input = spec->cur_input;
-			spec->cur_input = spec->automic_idx;
+			if (spec->cur_input != spec->automic_idx) {
+				spec->last_input = spec->cur_input;
+				spec->cur_input = spec->automic_idx;
+			}
 		} else  {
 			spec->cur_input = spec->last_input;
 		}
diff -Naur linux-3.3-rc2/sound/pci/hda/patch_realtek.c wm8505-3.3rc2/sound/pci/hda/patch_realtek.c
--- linux-3.3-rc2/sound/pci/hda/patch_realtek.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/sound/pci/hda/patch_realtek.c	2012-02-06 12:27:43.000000000 -0700
@@ -177,6 +177,7 @@
 	unsigned int detect_lo:1;	/* Line-out detection enabled */
 	unsigned int automute_speaker_possible:1; /* there are speakers and either LO or HP */
 	unsigned int automute_lo_possible:1;	  /* there are line outs and HP */
+	unsigned int keep_vref_in_automute:1; /* Don't clear VREF in automute */
 
 	/* other flags */
 	unsigned int no_analog :1; /* digital I/O only */
@@ -495,13 +496,24 @@
 
 	for (i = 0; i < num_pins; i++) {
 		hda_nid_t nid = pins[i];
+		unsigned int val;
 		if (!nid)
 			break;
 		switch (spec->automute_mode) {
 		case ALC_AUTOMUTE_PIN:
+			/* don't reset VREF value in case it's controlling
+			 * the amp (see alc861_fixup_asus_amp_vref_0f())
+			 */
+			if (spec->keep_vref_in_automute) {
+				val = snd_hda_codec_read(codec, nid, 0,
+					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+				val &= ~PIN_HP;
+			} else
+				val = 0;
+			val |= pin_bits;
 			snd_hda_codec_write(codec, nid, 0,
 					    AC_VERB_SET_PIN_WIDGET_CONTROL,
-					    pin_bits);
+					    val);
 			break;
 		case ALC_AUTOMUTE_AMP:
 			snd_hda_codec_amp_stereo(codec, nid, HDA_OUTPUT, 0,
@@ -4735,7 +4747,6 @@
 	ALC262_FIXUP_FSC_H270,
 	ALC262_FIXUP_HP_Z200,
 	ALC262_FIXUP_TYAN,
-	ALC262_FIXUP_TOSHIBA_RX1,
 	ALC262_FIXUP_LENOVO_3000,
 	ALC262_FIXUP_BENQ,
 	ALC262_FIXUP_BENQ_T31,
@@ -4765,16 +4776,6 @@
 			{ }
 		}
 	},
-	[ALC262_FIXUP_TOSHIBA_RX1] = {
-		.type = ALC_FIXUP_PINS,
-		.v.pins = (const struct alc_pincfg[]) {
-			{ 0x14, 0x90170110 }, /* speaker */
-			{ 0x15, 0x0421101f }, /* HP */
-			{ 0x1a, 0x40f000f0 }, /* N/A */
-			{ 0x1b, 0x40f000f0 }, /* N/A */
-			{ 0x1e, 0x40f000f0 }, /* N/A */
-		}
-	},
 	[ALC262_FIXUP_LENOVO_3000] = {
 		.type = ALC_FIXUP_VERBS,
 		.v.verbs = (const struct hda_verb[]) {
@@ -4807,8 +4808,6 @@
 	SND_PCI_QUIRK(0x10cf, 0x1397, "Fujitsu", ALC262_FIXUP_BENQ),
 	SND_PCI_QUIRK(0x10cf, 0x142d, "Fujitsu Lifebook E8410", ALC262_FIXUP_BENQ),
 	SND_PCI_QUIRK(0x10f1, 0x2915, "Tyan Thunder n6650W", ALC262_FIXUP_TYAN),
-	SND_PCI_QUIRK(0x1179, 0x0001, "Toshiba dynabook SS RX1",
-		      ALC262_FIXUP_TOSHIBA_RX1),
 	SND_PCI_QUIRK(0x1734, 0x1147, "FSC Celsius H270", ALC262_FIXUP_FSC_H270),
 	SND_PCI_QUIRK(0x17aa, 0x384e, "Lenovo 3000", ALC262_FIXUP_LENOVO_3000),
 	SND_PCI_QUIRK(0x17ff, 0x0560, "Benq ED8", ALC262_FIXUP_BENQ),
@@ -5377,7 +5376,6 @@
 	SND_PCI_QUIRK(0x1043, 0x8330, "ASUS Eeepc P703 P900A",
 		      ALC269_FIXUP_AMIC),
 	SND_PCI_QUIRK(0x1043, 0x1013, "ASUS N61Da", ALC269_FIXUP_AMIC),
-	SND_PCI_QUIRK(0x1043, 0x1113, "ASUS N63Jn", ALC269_FIXUP_AMIC),
 	SND_PCI_QUIRK(0x1043, 0x1143, "ASUS B53f", ALC269_FIXUP_AMIC),
 	SND_PCI_QUIRK(0x1043, 0x1133, "ASUS UJ20ft", ALC269_FIXUP_AMIC),
 	SND_PCI_QUIRK(0x1043, 0x1183, "ASUS K72DR", ALC269_FIXUP_AMIC),
@@ -5589,6 +5587,25 @@
 	PINFIX_ASUS_A6RP,
 };
 
+/* On some laptops, VREF of pin 0x0f is abused for controlling the main amp */
+static void alc861_fixup_asus_amp_vref_0f(struct hda_codec *codec,
+			const struct alc_fixup *fix, int action)
+{
+	struct alc_spec *spec = codec->spec;
+	unsigned int val;
+
+	if (action != ALC_FIXUP_ACT_INIT)
+		return;
+	val = snd_hda_codec_read(codec, 0x0f, 0,
+				 AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+	if (!(val & (AC_PINCTL_IN_EN | AC_PINCTL_OUT_EN)))
+		val |= AC_PINCTL_IN_EN;
+	val |= AC_PINCTL_VREF_50;
+	snd_hda_codec_write(codec, 0x0f, 0,
+			    AC_VERB_SET_PIN_WIDGET_CONTROL, val);
+	spec->keep_vref_in_automute = 1;
+}
+
 static const struct alc_fixup alc861_fixups[] = {
 	[PINFIX_FSC_AMILO_PI1505] = {
 		.type = ALC_FIXUP_PINS,
@@ -5599,17 +5616,13 @@
 		}
 	},
 	[PINFIX_ASUS_A6RP] = {
-		.type = ALC_FIXUP_VERBS,
-		.v.verbs = (const struct hda_verb[]) {
-			/* node 0x0f VREF seems controlling the master output */
-			{ 0x0f, AC_VERB_SET_PIN_WIDGET_CONTROL, PIN_VREF50 },
-			{ }
-		},
+		.type = ALC_FIXUP_FUNC,
+		.v.func = alc861_fixup_asus_amp_vref_0f,
 	},
 };
 
 static const struct snd_pci_quirk alc861_fixup_tbl[] = {
-	SND_PCI_QUIRK(0x1043, 0x1393, "ASUS A6Rp", PINFIX_ASUS_A6RP),
+	SND_PCI_QUIRK_VENDOR(0x1043, "ASUS laptop", PINFIX_ASUS_A6RP),
 	SND_PCI_QUIRK(0x1584, 0x2b01, "Haier W18", PINFIX_ASUS_A6RP),
 	SND_PCI_QUIRK(0x1734, 0x10c7, "FSC Amilo Pi1505", PINFIX_FSC_AMILO_PI1505),
 	{}
diff -Naur linux-3.3-rc2/sound/pci/hda/patch_via.c wm8505-3.3rc2/sound/pci/hda/patch_via.c
--- linux-3.3-rc2/sound/pci/hda/patch_via.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/sound/pci/hda/patch_via.c	2012-02-06 12:27:43.000000000 -0700
@@ -199,6 +199,9 @@
 	unsigned int no_pin_power_ctl;
 	enum VIA_HDA_CODEC codec_type;
 
+	/* analog low-power control */
+	bool alc_mode;
+
 	/* smart51 setup */
 	unsigned int smart51_nums;
 	hda_nid_t smart51_pins[2];
@@ -687,6 +690,15 @@
 	}
 }
 
+static void update_power_state(struct hda_codec *codec, hda_nid_t nid,
+			       unsigned int parm)
+{
+	if (snd_hda_codec_read(codec, nid, 0,
+			       AC_VERB_GET_POWER_STATE, 0) == parm)
+		return;
+	snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_POWER_STATE, parm);
+}
+
 static void set_pin_power_state(struct hda_codec *codec, hda_nid_t nid,
 				unsigned int *affected_parm)
 {
@@ -709,7 +721,7 @@
 	} else
 		parm = AC_PWRST_D3;
 
-	snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, nid, parm);
 }
 
 static int via_pin_power_ctl_info(struct snd_kcontrol *kcontrol,
@@ -749,6 +761,7 @@
 		return 0;
 	spec->no_pin_power_ctl = val;
 	set_widgets_power_state(codec);
+	analog_low_current_mode(codec);
 	return 1;
 }
 
@@ -1036,13 +1049,19 @@
 }
 
 /* enter/exit analog low-current mode */
-static void analog_low_current_mode(struct hda_codec *codec)
+static void __analog_low_current_mode(struct hda_codec *codec, bool force)
 {
 	struct via_spec *spec = codec->spec;
 	bool enable;
 	unsigned int verb, parm;
 
-	enable = is_aa_path_mute(codec) && (spec->opened_streams != 0);
+	if (spec->no_pin_power_ctl)
+		enable = false;
+	else
+		enable = is_aa_path_mute(codec) && !spec->opened_streams;
+	if (enable == spec->alc_mode && !force)
+		return;
+	spec->alc_mode = enable;
 
 	/* decide low current mode's verb & parameter */
 	switch (spec->codec_type) {
@@ -1074,6 +1093,11 @@
 	snd_hda_codec_write(codec, codec->afg, 0, verb, parm);
 }
 
+static void analog_low_current_mode(struct hda_codec *codec)
+{
+	return __analog_low_current_mode(codec, false);
+}
+
 /*
  * generic initialization of ADC, input mixers and output mixers
  */
@@ -1446,6 +1470,7 @@
 	struct snd_kcontrol *kctl;
 	int err, i;
 
+	spec->no_pin_power_ctl = 1;
 	if (spec->set_widgets_power_state)
 		if (!via_clone_control(spec, &via_pin_power_ctl_enum))
 			return -ENOMEM;
@@ -1499,10 +1524,6 @@
 			return err;
 	}
 
-	/* init power states */
-	set_widgets_power_state(codec);
-	analog_low_current_mode(codec);
-
 	via_free_kctls(codec); /* no longer needed */
 
 	err = snd_hda_jack_add_kctls(codec, &spec->autocfg);
@@ -2295,10 +2316,7 @@
 
 	if (mux) {
 		/* switch to D0 beofre change index */
-		if (snd_hda_codec_read(codec, mux, 0,
-			       AC_VERB_GET_POWER_STATE, 0x00) != AC_PWRST_D0)
-			snd_hda_codec_write(codec, mux, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
+		update_power_state(codec, mux, AC_PWRST_D0);
 		snd_hda_codec_write(codec, mux, 0,
 				    AC_VERB_SET_CONNECT_SEL,
 				    spec->inputs[cur].mux_idx);
@@ -2776,6 +2794,10 @@
 	for (i = 0; i < spec->num_iverbs; i++)
 		snd_hda_sequence_write(codec, spec->init_verbs[i]);
 
+	/* init power states */
+	set_widgets_power_state(codec);
+	__analog_low_current_mode(codec, true);
+
 	via_auto_init_multi_out(codec);
 	via_auto_init_hp_out(codec);
 	via_auto_init_speaker_out(codec);
@@ -2922,9 +2944,9 @@
 	if (imux_is_smixer)
 		parm = AC_PWRST_D0;
 	/* SW0 (17h), AIW 0/1 (13h/14h) */
-	snd_hda_codec_write(codec, 0x17, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x13, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x14, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x17, parm);
+	update_power_state(codec, 0x13, parm);
+	update_power_state(codec, 0x14, parm);
 
 	/* outputs */
 	/* PW0 (19h), SW1 (18h), AOW1 (11h) */
@@ -2932,8 +2954,8 @@
 	set_pin_power_state(codec, 0x19, &parm);
 	if (spec->smart51_enabled)
 		set_pin_power_state(codec, 0x1b, &parm);
-	snd_hda_codec_write(codec, 0x18, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x11, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x18, parm);
+	update_power_state(codec, 0x11, parm);
 
 	/* PW6 (22h), SW2 (26h), AOW2 (24h) */
 	if (is_8ch) {
@@ -2941,20 +2963,16 @@
 		set_pin_power_state(codec, 0x22, &parm);
 		if (spec->smart51_enabled)
 			set_pin_power_state(codec, 0x1a, &parm);
-		snd_hda_codec_write(codec, 0x26, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0x24, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x26, parm);
+		update_power_state(codec, 0x24, parm);
 	} else if (codec->vendor_id == 0x11064397) {
 		/* PW7(23h), SW2(27h), AOW2(25h) */
 		parm = AC_PWRST_D3;
 		set_pin_power_state(codec, 0x23, &parm);
 		if (spec->smart51_enabled)
 			set_pin_power_state(codec, 0x1a, &parm);
-		snd_hda_codec_write(codec, 0x27, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0x25, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x27, parm);
+		update_power_state(codec, 0x25, parm);
 	}
 
 	/* PW 3/4/7 (1ch/1dh/23h) */
@@ -2966,17 +2984,13 @@
 		set_pin_power_state(codec, 0x23, &parm);
 
 	/* MW0 (16h), Sw3 (27h), AOW 0/3 (10h/25h) */
-	snd_hda_codec_write(codec, 0x16, 0, AC_VERB_SET_POWER_STATE,
-			    imux_is_smixer ? AC_PWRST_D0 : parm);
-	snd_hda_codec_write(codec, 0x10, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x16, imux_is_smixer ? AC_PWRST_D0 : parm);
+	update_power_state(codec, 0x10, parm);
 	if (is_8ch) {
-		snd_hda_codec_write(codec, 0x25, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0x27, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x25, parm);
+		update_power_state(codec, 0x27, parm);
 	} else if (codec->vendor_id == 0x11064397 && spec->hp_independent_mode)
-		snd_hda_codec_write(codec, 0x25, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x25, parm);
 }
 
 static int patch_vt1708S(struct hda_codec *codec);
@@ -3149,10 +3163,10 @@
 	if (imux_is_smixer)
 		parm = AC_PWRST_D0; /* SW0 (13h) = stereo mixer (idx 3) */
 	/* SW0 (13h), AIW 0/1/2 (12h/1fh/20h) */
-	snd_hda_codec_write(codec, 0x13, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x12, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x1f, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x20, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x13, parm);
+	update_power_state(codec, 0x12, parm);
+	update_power_state(codec, 0x1f, parm);
+	update_power_state(codec, 0x20, parm);
 
 	/* outputs */
 	/* PW 3/4 (16h/17h) */
@@ -3160,10 +3174,9 @@
 	set_pin_power_state(codec, 0x17, &parm);
 	set_pin_power_state(codec, 0x16, &parm);
 	/* MW0 (1ah), AOW 0/1 (10h/1dh) */
-	snd_hda_codec_write(codec, 0x1a, 0, AC_VERB_SET_POWER_STATE,
-			    imux_is_smixer ? AC_PWRST_D0 : parm);
-	snd_hda_codec_write(codec, 0x10, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x1d, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x1a, imux_is_smixer ? AC_PWRST_D0 : parm);
+	update_power_state(codec, 0x10, parm);
+	update_power_state(codec, 0x1d, parm);
 }
 
 static int patch_vt1702(struct hda_codec *codec)
@@ -3228,52 +3241,48 @@
 	if (imux_is_smixer)
 		parm = AC_PWRST_D0;
 	/* MUX6/7 (1eh/1fh), AIW 0/1 (10h/11h) */
-	snd_hda_codec_write(codec, 0x1e, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x1f, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x10, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x11, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x1e, parm);
+	update_power_state(codec, 0x1f, parm);
+	update_power_state(codec, 0x10, parm);
+	update_power_state(codec, 0x11, parm);
 
 	/* outputs */
 	/* PW3 (27h), MW2 (1ah), AOW3 (bh) */
 	parm = AC_PWRST_D3;
 	set_pin_power_state(codec, 0x27, &parm);
-	snd_hda_codec_write(codec, 0x1a, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0xb, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x1a, parm);
+	update_power_state(codec, 0xb, parm);
 
 	/* PW2 (26h), AOW2 (ah) */
 	parm = AC_PWRST_D3;
 	set_pin_power_state(codec, 0x26, &parm);
 	if (spec->smart51_enabled)
 		set_pin_power_state(codec, 0x2b, &parm);
-	snd_hda_codec_write(codec, 0xa, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0xa, parm);
 
 	/* PW0 (24h), AOW0 (8h) */
 	parm = AC_PWRST_D3;
 	set_pin_power_state(codec, 0x24, &parm);
 	if (!spec->hp_independent_mode) /* check for redirected HP */
 		set_pin_power_state(codec, 0x28, &parm);
-	snd_hda_codec_write(codec, 0x8, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x8, parm);
 	/* MW9 (21h), Mw2 (1ah), AOW0 (8h) */
-	snd_hda_codec_write(codec, 0x21, 0, AC_VERB_SET_POWER_STATE,
-			    imux_is_smixer ? AC_PWRST_D0 : parm);
+	update_power_state(codec, 0x21, imux_is_smixer ? AC_PWRST_D0 : parm);
 
 	/* PW1 (25h), AOW1 (9h) */
 	parm = AC_PWRST_D3;
 	set_pin_power_state(codec, 0x25, &parm);
 	if (spec->smart51_enabled)
 		set_pin_power_state(codec, 0x2a, &parm);
-	snd_hda_codec_write(codec, 0x9, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x9, parm);
 
 	if (spec->hp_independent_mode) {
 		/* PW4 (28h), MW3 (1bh), MUX1(34h), AOW4 (ch) */
 		parm = AC_PWRST_D3;
 		set_pin_power_state(codec, 0x28, &parm);
-		snd_hda_codec_write(codec, 0x1b, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0x34, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0xc, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x1b, parm);
+		update_power_state(codec, 0x34, parm);
+		update_power_state(codec, 0xc, parm);
 	}
 }
 
@@ -3433,8 +3442,8 @@
 	if (imux_is_smixer)
 		parm = AC_PWRST_D0;
 	/* SW0 (17h), AIW0(13h) */
-	snd_hda_codec_write(codec, 0x17, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x13, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x17, parm);
+	update_power_state(codec, 0x13, parm);
 
 	parm = AC_PWRST_D3;
 	set_pin_power_state(codec, 0x1e, &parm);
@@ -3442,12 +3451,11 @@
 	if (spec->dmic_enabled)
 		set_pin_power_state(codec, 0x22, &parm);
 	else
-		snd_hda_codec_write(codec, 0x22, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D3);
+		update_power_state(codec, 0x22, AC_PWRST_D3);
 
 	/* SW2(26h), AIW1(14h) */
-	snd_hda_codec_write(codec, 0x26, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x14, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x26, parm);
+	update_power_state(codec, 0x14, parm);
 
 	/* outputs */
 	/* PW0 (19h), SW1 (18h), AOW1 (11h) */
@@ -3456,8 +3464,8 @@
 	/* Smart 5.1 PW2(1bh) */
 	if (spec->smart51_enabled)
 		set_pin_power_state(codec, 0x1b, &parm);
-	snd_hda_codec_write(codec, 0x18, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x11, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x18, parm);
+	update_power_state(codec, 0x11, parm);
 
 	/* PW7 (23h), SW3 (27h), AOW3 (25h) */
 	parm = AC_PWRST_D3;
@@ -3465,12 +3473,12 @@
 	/* Smart 5.1 PW1(1ah) */
 	if (spec->smart51_enabled)
 		set_pin_power_state(codec, 0x1a, &parm);
-	snd_hda_codec_write(codec, 0x27, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x27, parm);
 
 	/* Smart 5.1 PW5(1eh) */
 	if (spec->smart51_enabled)
 		set_pin_power_state(codec, 0x1e, &parm);
-	snd_hda_codec_write(codec, 0x25, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x25, parm);
 
 	/* Mono out */
 	/* SW4(28h)->MW1(29h)-> PW12 (2ah)*/
@@ -3486,9 +3494,9 @@
 			mono_out = 1;
 	}
 	parm = mono_out ? AC_PWRST_D0 : AC_PWRST_D3;
-	snd_hda_codec_write(codec, 0x28, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x29, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x2a, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x28, parm);
+	update_power_state(codec, 0x29, parm);
+	update_power_state(codec, 0x2a, parm);
 
 	/* PW 3/4 (1ch/1dh) */
 	parm = AC_PWRST_D3;
@@ -3496,15 +3504,12 @@
 	set_pin_power_state(codec, 0x1d, &parm);
 	/* HP Independent Mode, power on AOW3 */
 	if (spec->hp_independent_mode)
-		snd_hda_codec_write(codec, 0x25, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x25, parm);
 
 	/* force to D0 for internal Speaker */
 	/* MW0 (16h), AOW0 (10h) */
-	snd_hda_codec_write(codec, 0x16, 0, AC_VERB_SET_POWER_STATE,
-			    imux_is_smixer ? AC_PWRST_D0 : parm);
-	snd_hda_codec_write(codec, 0x10, 0, AC_VERB_SET_POWER_STATE,
-			    mono_out ? AC_PWRST_D0 : parm);
+	update_power_state(codec, 0x16, imux_is_smixer ? AC_PWRST_D0 : parm);
+	update_power_state(codec, 0x10, mono_out ? AC_PWRST_D0 : parm);
 }
 
 static int patch_vt1716S(struct hda_codec *codec)
@@ -3580,54 +3585,45 @@
 	set_pin_power_state(codec, 0x2b, &parm);
 	parm = AC_PWRST_D0;
 	/* MUX9/10 (1eh/1fh), AIW 0/1 (10h/11h) */
-	snd_hda_codec_write(codec, 0x1e, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x1f, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x10, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x11, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x1e, parm);
+	update_power_state(codec, 0x1f, parm);
+	update_power_state(codec, 0x10, parm);
+	update_power_state(codec, 0x11, parm);
 
 	/* outputs */
 	/* AOW0 (8h)*/
-	snd_hda_codec_write(codec, 0x8, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x8, parm);
 
 	if (spec->codec_type == VT1802) {
 		/* PW4 (28h), MW4 (18h), MUX4(38h) */
 		parm = AC_PWRST_D3;
 		set_pin_power_state(codec, 0x28, &parm);
-		snd_hda_codec_write(codec, 0x18, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0x38, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x18, parm);
+		update_power_state(codec, 0x38, parm);
 	} else {
 		/* PW4 (26h), MW4 (1ch), MUX4(37h) */
 		parm = AC_PWRST_D3;
 		set_pin_power_state(codec, 0x26, &parm);
-		snd_hda_codec_write(codec, 0x1c, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0x37, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x1c, parm);
+		update_power_state(codec, 0x37, parm);
 	}
 
 	if (spec->codec_type == VT1802) {
 		/* PW1 (25h), MW1 (15h), MUX1(35h), AOW1 (9h) */
 		parm = AC_PWRST_D3;
 		set_pin_power_state(codec, 0x25, &parm);
-		snd_hda_codec_write(codec, 0x15, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0x35, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x15, parm);
+		update_power_state(codec, 0x35, parm);
 	} else {
 		/* PW1 (25h), MW1 (19h), MUX1(35h), AOW1 (9h) */
 		parm = AC_PWRST_D3;
 		set_pin_power_state(codec, 0x25, &parm);
-		snd_hda_codec_write(codec, 0x19, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0x35, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x19, parm);
+		update_power_state(codec, 0x35, parm);
 	}
 
 	if (spec->hp_independent_mode)
-		snd_hda_codec_write(codec, 0x9, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
+		update_power_state(codec, 0x9, AC_PWRST_D0);
 
 	/* Class-D */
 	/* PW0 (24h), MW0(18h/14h), MUX0(34h) */
@@ -3637,12 +3633,10 @@
 	set_pin_power_state(codec, 0x24, &parm);
 	parm = present ? AC_PWRST_D3 : AC_PWRST_D0;
 	if (spec->codec_type == VT1802)
-		snd_hda_codec_write(codec, 0x14, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x14, parm);
 	else
-		snd_hda_codec_write(codec, 0x18, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x34, 0, AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x18, parm);
+	update_power_state(codec, 0x34, parm);
 
 	/* Mono Out */
 	present = snd_hda_jack_detect(codec, 0x26);
@@ -3650,28 +3644,20 @@
 	parm = present ? AC_PWRST_D3 : AC_PWRST_D0;
 	if (spec->codec_type == VT1802) {
 		/* PW15 (33h), MW8(1ch), MUX8(3ch) */
-		snd_hda_codec_write(codec, 0x33, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0x1c, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0x3c, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x33, parm);
+		update_power_state(codec, 0x1c, parm);
+		update_power_state(codec, 0x3c, parm);
 	} else {
 		/* PW15 (31h), MW8(17h), MUX8(3bh) */
-		snd_hda_codec_write(codec, 0x31, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0x17, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
-		snd_hda_codec_write(codec, 0x3b, 0,
-				    AC_VERB_SET_POWER_STATE, parm);
+		update_power_state(codec, 0x31, parm);
+		update_power_state(codec, 0x17, parm);
+		update_power_state(codec, 0x3b, parm);
 	}
 	/* MW9 (21h) */
 	if (imux_is_smixer || !is_aa_path_mute(codec))
-		snd_hda_codec_write(codec, 0x21, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
+		update_power_state(codec, 0x21, AC_PWRST_D0);
 	else
-		snd_hda_codec_write(codec, 0x21, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D3);
+		update_power_state(codec, 0x21, AC_PWRST_D3);
 }
 
 /* patch for vt2002P */
@@ -3731,30 +3717,28 @@
 	set_pin_power_state(codec, 0x2b, &parm);
 	parm = AC_PWRST_D0;
 	/* MUX10/11 (1eh/1fh), AIW 0/1 (10h/11h) */
-	snd_hda_codec_write(codec, 0x1e, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x1f, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x10, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x11, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x1e, parm);
+	update_power_state(codec, 0x1f, parm);
+	update_power_state(codec, 0x10, parm);
+	update_power_state(codec, 0x11, parm);
 
 	/* outputs */
 	/* AOW0 (8h)*/
-	snd_hda_codec_write(codec, 0x8, 0,
-			    AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
+	update_power_state(codec, 0x8, AC_PWRST_D0);
 
 	/* PW4 (28h), MW4 (18h), MUX4(38h) */
 	parm = AC_PWRST_D3;
 	set_pin_power_state(codec, 0x28, &parm);
-	snd_hda_codec_write(codec, 0x18, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x38, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x18, parm);
+	update_power_state(codec, 0x38, parm);
 
 	/* PW1 (25h), MW1 (15h), MUX1(35h), AOW1 (9h) */
 	parm = AC_PWRST_D3;
 	set_pin_power_state(codec, 0x25, &parm);
-	snd_hda_codec_write(codec, 0x15, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x35, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x15, parm);
+	update_power_state(codec, 0x35, parm);
 	if (spec->hp_independent_mode)
-		snd_hda_codec_write(codec, 0x9, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
+		update_power_state(codec, 0x9, AC_PWRST_D0);
 
 	/* Internal Speaker */
 	/* PW0 (24h), MW0(14h), MUX0(34h) */
@@ -3763,15 +3747,11 @@
 	parm = AC_PWRST_D3;
 	set_pin_power_state(codec, 0x24, &parm);
 	if (present) {
-		snd_hda_codec_write(codec, 0x14, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D3);
-		snd_hda_codec_write(codec, 0x34, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D3);
+		update_power_state(codec, 0x14, AC_PWRST_D3);
+		update_power_state(codec, 0x34, AC_PWRST_D3);
 	} else {
-		snd_hda_codec_write(codec, 0x14, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
-		snd_hda_codec_write(codec, 0x34, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
+		update_power_state(codec, 0x14, AC_PWRST_D0);
+		update_power_state(codec, 0x34, AC_PWRST_D0);
 	}
 
 
@@ -3782,26 +3762,20 @@
 	parm = AC_PWRST_D3;
 	set_pin_power_state(codec, 0x31, &parm);
 	if (present) {
-		snd_hda_codec_write(codec, 0x1c, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D3);
-		snd_hda_codec_write(codec, 0x3c, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D3);
-		snd_hda_codec_write(codec, 0x3e, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D3);
+		update_power_state(codec, 0x1c, AC_PWRST_D3);
+		update_power_state(codec, 0x3c, AC_PWRST_D3);
+		update_power_state(codec, 0x3e, AC_PWRST_D3);
 	} else {
-		snd_hda_codec_write(codec, 0x1c, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
-		snd_hda_codec_write(codec, 0x3c, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
-		snd_hda_codec_write(codec, 0x3e, 0,
-				    AC_VERB_SET_POWER_STATE, AC_PWRST_D0);
+		update_power_state(codec, 0x1c, AC_PWRST_D0);
+		update_power_state(codec, 0x3c, AC_PWRST_D0);
+		update_power_state(codec, 0x3e, AC_PWRST_D0);
 	}
 
 	/* PW15 (33h), MW15 (1dh), MUX15(3dh) */
 	parm = AC_PWRST_D3;
 	set_pin_power_state(codec, 0x33, &parm);
-	snd_hda_codec_write(codec, 0x1d, 0, AC_VERB_SET_POWER_STATE, parm);
-	snd_hda_codec_write(codec, 0x3d, 0, AC_VERB_SET_POWER_STATE, parm);
+	update_power_state(codec, 0x1d, parm);
+	update_power_state(codec, 0x3d, parm);
 
 }
 
diff -Naur linux-3.3-rc2/sound/soc/codecs/wm5100.c wm8505-3.3rc2/sound/soc/codecs/wm5100.c
--- linux-3.3-rc2/sound/soc/codecs/wm5100.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/sound/soc/codecs/wm5100.c	2012-02-06 12:27:43.000000000 -0700
@@ -1405,6 +1405,7 @@
 
 	case SND_SOC_BIAS_OFF:
 		regcache_cache_only(wm5100->regmap, true);
+		regcache_mark_dirty(wm5100->regmap);
 		if (wm5100->pdata.ldo_ena)
 			gpio_set_value_cansleep(wm5100->pdata.ldo_ena, 0);
 		regulator_bulk_disable(ARRAY_SIZE(wm5100->core_supplies),
@@ -2183,6 +2184,7 @@
 		if (wm5100->jack_detecting) {
 			dev_dbg(codec->dev, "Microphone detected\n");
 			wm5100->jack_mic = true;
+			wm5100->jack_detecting = false;
 			snd_soc_jack_report(wm5100->jack,
 					    SND_JACK_HEADSET,
 					    SND_JACK_HEADSET | SND_JACK_BTN_0);
@@ -2221,6 +2223,7 @@
 					    SND_JACK_BTN_0);
 		} else if (wm5100->jack_detecting) {
 			dev_dbg(codec->dev, "Headphone detected\n");
+			wm5100->jack_detecting = false;
 			snd_soc_jack_report(wm5100->jack, SND_JACK_HEADPHONE,
 					    SND_JACK_HEADPHONE);
 
@@ -2610,6 +2613,13 @@
 	.cache_type = REGCACHE_RBTREE,
 };
 
+static const unsigned int wm5100_mic_ctrl_reg[] = {
+	WM5100_IN1L_CONTROL,
+	WM5100_IN2L_CONTROL,
+	WM5100_IN3L_CONTROL,
+	WM5100_IN4L_CONTROL,
+};
+
 static __devinit int wm5100_i2c_probe(struct i2c_client *i2c,
 				      const struct i2c_device_id *id)
 {
@@ -2742,7 +2752,7 @@
 	}
 
 	for (i = 0; i < ARRAY_SIZE(wm5100->pdata.in_mode); i++) {
-		regmap_update_bits(wm5100->regmap, WM5100_IN1L_CONTROL,
+		regmap_update_bits(wm5100->regmap, wm5100_mic_ctrl_reg[i],
 				   WM5100_IN1_MODE_MASK |
 				   WM5100_IN1_DMIC_SUP_MASK,
 				   (wm5100->pdata.in_mode[i] <<
diff -Naur linux-3.3-rc2/sound/soc/codecs/wm8962.c wm8505-3.3rc2/sound/soc/codecs/wm8962.c
--- linux-3.3-rc2/sound/soc/codecs/wm8962.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/sound/soc/codecs/wm8962.c	2012-02-06 12:27:43.000000000 -0700
@@ -96,7 +96,7 @@
 	struct wm8962_priv *wm8962 = container_of(nb, struct wm8962_priv, \
 						  disable_nb[n]); \
 	if (event & REGULATOR_EVENT_DISABLE) { \
-		regcache_cache_only(wm8962->regmap, true);	\
+		regcache_mark_dirty(wm8962->regmap);	\
 	} \
 	return 0; \
 }
diff -Naur linux-3.3-rc2/sound/soc/codecs/wm8996.c wm8505-3.3rc2/sound/soc/codecs/wm8996.c
--- linux-3.3-rc2/sound/soc/codecs/wm8996.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/sound/soc/codecs/wm8996.c	2012-02-06 12:27:43.000000000 -0700
@@ -108,7 +108,7 @@
 	struct wm8996_priv *wm8996 = container_of(nb, struct wm8996_priv, \
 						  disable_nb[n]); \
 	if (event & REGULATOR_EVENT_DISABLE) { \
-		regcache_cache_only(wm8996->regmap, true);	\
+		regcache_mark_dirty(wm8996->regmap);	\
 	} \
 	return 0; \
 }
diff -Naur linux-3.3-rc2/sound/soc/codecs/wm_hubs.c wm8505-3.3rc2/sound/soc/codecs/wm_hubs.c
--- linux-3.3-rc2/sound/soc/codecs/wm_hubs.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/sound/soc/codecs/wm_hubs.c	2012-02-06 12:27:43.000000000 -0700
@@ -592,8 +592,8 @@
 };
 
 static const struct snd_kcontrol_new line2n_mix[] = {
-SOC_DAPM_SINGLE("Left Output Switch", WM8993_LINE_MIXER2, 6, 1, 0),
-SOC_DAPM_SINGLE("Right Output Switch", WM8993_LINE_MIXER2, 5, 1, 0),
+SOC_DAPM_SINGLE("Left Output Switch", WM8993_LINE_MIXER2, 5, 1, 0),
+SOC_DAPM_SINGLE("Right Output Switch", WM8993_LINE_MIXER2, 6, 1, 0),
 };
 
 static const struct snd_kcontrol_new line2p_mix[] = {
@@ -613,6 +613,8 @@
 SND_SOC_DAPM_SUPPLY("MICBIAS2", WM8993_POWER_MANAGEMENT_1, 5, 0, NULL, 0),
 SND_SOC_DAPM_SUPPLY("MICBIAS1", WM8993_POWER_MANAGEMENT_1, 4, 0, NULL, 0),
 
+SND_SOC_DAPM_SUPPLY("LINEOUT_VMID_BUF", WM8993_ANTIPOP1, 7, 0, NULL, 0),
+
 SND_SOC_DAPM_MIXER("IN1L PGA", WM8993_POWER_MANAGEMENT_2, 6, 0,
 		   in1l_pga, ARRAY_SIZE(in1l_pga)),
 SND_SOC_DAPM_MIXER("IN1R PGA", WM8993_POWER_MANAGEMENT_2, 4, 0,
@@ -834,9 +836,11 @@
 };
 
 static const struct snd_soc_dapm_route lineout1_se_routes[] = {
+	{ "LINEOUT1N Mixer", NULL, "LINEOUT_VMID_BUF" },
 	{ "LINEOUT1N Mixer", "Left Output Switch", "Left Output PGA" },
 	{ "LINEOUT1N Mixer", "Right Output Switch", "Right Output PGA" },
 
+	{ "LINEOUT1P Mixer", NULL, "LINEOUT_VMID_BUF" },
 	{ "LINEOUT1P Mixer", "Left Output Switch", "Left Output PGA" },
 
 	{ "LINEOUT1N Driver", NULL, "LINEOUT1N Mixer" },
@@ -853,9 +857,11 @@
 };
 
 static const struct snd_soc_dapm_route lineout2_se_routes[] = {
+	{ "LINEOUT2N Mixer", NULL, "LINEOUT_VMID_BUF" },
 	{ "LINEOUT2N Mixer", "Left Output Switch", "Left Output PGA" },
 	{ "LINEOUT2N Mixer", "Right Output Switch", "Right Output PGA" },
 
+	{ "LINEOUT2P Mixer", NULL, "LINEOUT_VMID_BUF" },
 	{ "LINEOUT2P Mixer", "Right Output Switch", "Right Output PGA" },
 
 	{ "LINEOUT2N Driver", NULL, "LINEOUT2N Mixer" },
diff -Naur linux-3.3-rc2/sound/soc/samsung/neo1973_wm8753.c wm8505-3.3rc2/sound/soc/samsung/neo1973_wm8753.c
--- linux-3.3-rc2/sound/soc/samsung/neo1973_wm8753.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/sound/soc/samsung/neo1973_wm8753.c	2012-02-06 12:27:43.000000000 -0700
@@ -230,8 +230,6 @@
 
 /* GTA02 specific routes and controls */
 
-#ifdef CONFIG_MACH_NEO1973_GTA02
-
 static int gta02_speaker_enabled;
 
 static int lm4853_set_spk(struct snd_kcontrol *kcontrol,
@@ -311,10 +309,6 @@
 	return 0;
 }
 
-#else
-static int neo1973_gta02_wm8753_init(struct snd_soc_code *codec) { return 0; }
-#endif
-
 static int neo1973_wm8753_init(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_codec *codec = rtd->codec;
@@ -322,10 +316,6 @@
 	int ret;
 
 	/* set up NC codec pins */
-	if (machine_is_neo1973_gta01()) {
-		snd_soc_dapm_nc_pin(dapm, "LOUT2");
-		snd_soc_dapm_nc_pin(dapm, "ROUT2");
-	}
 	snd_soc_dapm_nc_pin(dapm, "OUT3");
 	snd_soc_dapm_nc_pin(dapm, "OUT4");
 	snd_soc_dapm_nc_pin(dapm, "LINE1");
@@ -370,50 +360,6 @@
 	return 0;
 }
 
-/* GTA01 specific controls */
-
-#ifdef CONFIG_MACH_NEO1973_GTA01
-
-static const struct snd_soc_dapm_route neo1973_lm4857_routes[] = {
-	{"Amp IN", NULL, "ROUT1"},
-	{"Amp IN", NULL, "LOUT1"},
-
-	{"Handset Spk", NULL, "Amp EP"},
-	{"Stereo Out", NULL, "Amp LS"},
-	{"Headphone", NULL, "Amp HP"},
-};
-
-static const struct snd_soc_dapm_widget neo1973_lm4857_dapm_widgets[] = {
-	SND_SOC_DAPM_SPK("Handset Spk", NULL),
-	SND_SOC_DAPM_SPK("Stereo Out", NULL),
-	SND_SOC_DAPM_HP("Headphone", NULL),
-};
-
-static int neo1973_lm4857_init(struct snd_soc_dapm_context *dapm)
-{
-	int ret;
-
-	ret = snd_soc_dapm_new_controls(dapm, neo1973_lm4857_dapm_widgets,
-			ARRAY_SIZE(neo1973_lm4857_dapm_widgets));
-	if (ret)
-		return ret;
-
-	ret = snd_soc_dapm_add_routes(dapm, neo1973_lm4857_routes,
-			ARRAY_SIZE(neo1973_lm4857_routes));
-	if (ret)
-		return ret;
-
-	snd_soc_dapm_ignore_suspend(dapm, "Stereo Out");
-	snd_soc_dapm_ignore_suspend(dapm, "Handset Spk");
-	snd_soc_dapm_ignore_suspend(dapm, "Headphone");
-
-	return 0;
-}
-
-#else
-static int neo1973_lm4857_init(struct snd_soc_dapm_context *dapm) { return 0; };
-#endif
-
 static struct snd_soc_dai_link neo1973_dai[] = {
 { /* Hifi Playback - for similatious use with voice below */
 	.name = "WM8753",
@@ -440,11 +386,6 @@
 		.name = "dfbmcs320",
 		.codec_name = "dfbmcs320.0",
 	},
-	{
-		.name = "lm4857",
-		.codec_name = "lm4857.0-007c",
-		.init = neo1973_lm4857_init,
-	},
 };
 
 static struct snd_soc_codec_conf neo1973_codec_conf[] = {
@@ -454,14 +395,10 @@
 	},
 };
 
-#ifdef CONFIG_MACH_NEO1973_GTA02
 static const struct gpio neo1973_gta02_gpios[] = {
 	{ GTA02_GPIO_HP_IN, GPIOF_OUT_INIT_HIGH, "GTA02_HP_IN" },
 	{ GTA02_GPIO_AMP_SHUT, GPIOF_OUT_INIT_HIGH, "GTA02_AMP_SHUT" },
 };
-#else
-static const struct gpio neo1973_gta02_gpios[] = {};
-#endif
 
 static struct snd_soc_card neo1973 = {
 	.name = "neo1973",
@@ -480,7 +417,7 @@
 {
 	int ret;
 
-	if (!machine_is_neo1973_gta01() && !machine_is_neo1973_gta02())
+	if (!machine_is_neo1973_gta02())
 		return -ENODEV;
 
 	if (machine_is_neo1973_gta02()) {
diff -Naur linux-3.3-rc2/tools/perf/builtin-probe.c wm8505-3.3rc2/tools/perf/builtin-probe.c
--- linux-3.3-rc2/tools/perf/builtin-probe.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/tools/perf/builtin-probe.c	2012-02-06 12:27:43.000000000 -0700
@@ -20,7 +20,6 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
  */
-#define _GNU_SOURCE
 #include <sys/utsname.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -31,7 +30,6 @@
 #include <stdlib.h>
 #include <string.h>
 
-#undef _GNU_SOURCE
 #include "perf.h"
 #include "builtin.h"
 #include "util/util.h"
diff -Naur linux-3.3-rc2/tools/perf/builtin-top.c wm8505-3.3rc2/tools/perf/builtin-top.c
--- linux-3.3-rc2/tools/perf/builtin-top.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/tools/perf/builtin-top.c	2012-02-06 12:27:43.000000000 -0700
@@ -89,8 +89,6 @@
 
 static void perf_top__update_print_entries(struct perf_top *top)
 {
-	top->print_entries = top->winsize.ws_row;
-
 	if (top->print_entries > 9)
 		top->print_entries -= 9;
 }
@@ -100,6 +98,13 @@
 	struct perf_top *top = arg;
 
 	get_term_dimensions(&top->winsize);
+	if (!top->print_entries
+	    || (top->print_entries+4) > top->winsize.ws_row) {
+		top->print_entries = top->winsize.ws_row;
+	} else {
+		top->print_entries += 4;
+		top->winsize.ws_row = top->print_entries;
+	}
 	perf_top__update_print_entries(top);
 }
 
@@ -453,8 +458,10 @@
 				};
 				perf_top__sig_winch(SIGWINCH, NULL, top);
 				sigaction(SIGWINCH, &act, NULL);
-			} else
+			} else {
+				perf_top__sig_winch(SIGWINCH, NULL, top);
 				signal(SIGWINCH, SIG_DFL);
+			}
 			break;
 		case 'E':
 			if (top->evlist->nr_entries > 1) {
diff -Naur linux-3.3-rc2/tools/perf/Makefile wm8505-3.3rc2/tools/perf/Makefile
--- linux-3.3-rc2/tools/perf/Makefile	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/tools/perf/Makefile	2012-02-06 12:27:43.000000000 -0700
@@ -104,7 +104,7 @@
 
 CFLAGS = -fno-omit-frame-pointer -ggdb3 -Wall -Wextra -std=gnu99 $(CFLAGS_WERROR) $(CFLAGS_OPTIMIZE) -D_FORTIFY_SOURCE=2 $(EXTRA_WARNINGS) $(EXTRA_CFLAGS)
 EXTLIBS = -lpthread -lrt -lelf -lm
-ALL_CFLAGS = $(CFLAGS) -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
+ALL_CFLAGS = $(CFLAGS) -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -D_GNU_SOURCE
 ALL_LDFLAGS = $(LDFLAGS)
 STRIP ?= strip
 
@@ -168,10 +168,7 @@
 
 ### --- END CONFIGURATION SECTION ---
 
-# Those must not be GNU-specific; they are shared with perl/ which may
-# be built by a different compiler. (Note that this is an artifact now
-# but it still might be nice to keep that distinction.)
-BASIC_CFLAGS = -Iutil/include -Iarch/$(ARCH)/include
+BASIC_CFLAGS = -Iutil/include -Iarch/$(ARCH)/include -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -D_GNU_SOURCE
 BASIC_LDFLAGS =
 
 # Guard against environment variables
diff -Naur linux-3.3-rc2/tools/perf/util/header.c wm8505-3.3rc2/tools/perf/util/header.c
--- linux-3.3-rc2/tools/perf/util/header.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/tools/perf/util/header.c	2012-02-06 12:27:43.000000000 -0700
@@ -2105,7 +2105,7 @@
 	strncpy(ev.event_type.event_type.name, name, MAX_EVENT_NAME - 1);
 
 	ev.event_type.header.type = PERF_RECORD_HEADER_EVENT_TYPE;
-	size = strlen(name);
+	size = strlen(ev.event_type.event_type.name);
 	size = ALIGN(size, sizeof(u64));
 	ev.event_type.header.size = sizeof(ev.event_type) -
 		(sizeof(ev.event_type.event_type.name) - size);
diff -Naur linux-3.3-rc2/tools/perf/util/probe-event.c wm8505-3.3rc2/tools/perf/util/probe-event.c
--- linux-3.3-rc2/tools/perf/util/probe-event.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/tools/perf/util/probe-event.c	2012-02-06 12:27:43.000000000 -0700
@@ -19,7 +19,6 @@
  *
  */
 
-#define _GNU_SOURCE
 #include <sys/utsname.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -33,7 +32,6 @@
 #include <limits.h>
 #include <elf.h>
 
-#undef _GNU_SOURCE
 #include "util.h"
 #include "event.h"
 #include "string.h"
diff -Naur linux-3.3-rc2/tools/perf/util/symbol.c wm8505-3.3rc2/tools/perf/util/symbol.c
--- linux-3.3-rc2/tools/perf/util/symbol.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/tools/perf/util/symbol.c	2012-02-06 12:27:43.000000000 -0700
@@ -1,4 +1,3 @@
-#define _GNU_SOURCE
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
diff -Naur linux-3.3-rc2/tools/perf/util/trace-event-parse.c wm8505-3.3rc2/tools/perf/util/trace-event-parse.c
--- linux-3.3-rc2/tools/perf/util/trace-event-parse.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/tools/perf/util/trace-event-parse.c	2012-02-06 12:27:43.000000000 -0700
@@ -21,14 +21,13 @@
  *  The parts for function graph printing was taken and modified from the
  *  Linux Kernel that were written by Frederic Weisbecker.
  */
-#define _GNU_SOURCE
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 #include <errno.h>
 
-#undef _GNU_SOURCE
 #include "../perf.h"
 #include "util.h"
 #include "trace-event.h"
diff -Naur linux-3.3-rc2/tools/perf/util/ui/browsers/hists.c wm8505-3.3rc2/tools/perf/util/ui/browsers/hists.c
--- linux-3.3-rc2/tools/perf/util/ui/browsers/hists.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/tools/perf/util/ui/browsers/hists.c	2012-02-06 12:27:43.000000000 -0700
@@ -1,6 +1,4 @@
-#define _GNU_SOURCE
 #include <stdio.h>
-#undef _GNU_SOURCE
 #include "../libslang.h"
 #include <stdlib.h>
 #include <string.h>
diff -Naur linux-3.3-rc2/tools/perf/util/ui/helpline.c wm8505-3.3rc2/tools/perf/util/ui/helpline.c
--- linux-3.3-rc2/tools/perf/util/ui/helpline.c	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/tools/perf/util/ui/helpline.c	2012-02-06 12:27:43.000000000 -0700
@@ -1,4 +1,3 @@
-#define _GNU_SOURCE
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
diff -Naur linux-3.3-rc2/tools/perf/util/util.h wm8505-3.3rc2/tools/perf/util/util.h
--- linux-3.3-rc2/tools/perf/util/util.h	2012-02-01 15:36:10.000000000 -0700
+++ wm8505-3.3rc2/tools/perf/util/util.h	2012-02-06 12:27:43.000000000 -0700
@@ -40,7 +40,6 @@
 #define decimal_length(x)	((int)(sizeof(x) * 2.56 + 0.5) + 1)
 
 #define _ALL_SOURCE 1
-#define _GNU_SOURCE 1
 #define _BSD_SOURCE 1
 #define HAS_BOOL
 
